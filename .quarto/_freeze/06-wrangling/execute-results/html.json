{
  "hash": "d0902c14aa1d59f3d22d4ed5f7737dd1",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n# Datenbereinigung {#sec-wrangle}\n\n## Beabsichtigte Lernergebnisse {#sec-ilo-wrangle .unnumbered}\n\n* Daten auswählen und filtern können, um Relevanz sicherzustellen\n* Neue Spalten erstellen und bestehende bearbeiten können\n* Mit fehlenden Daten umgehen können\n\n\n\n\n\n\n\n\nLaden Sie das [Daten-Transformation Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf) herunter.\n\n## Data Cleaning\nIm letzten Kapitel haben wir das `Tidy Data`Konzept kennengelernt. Sind die Daten erst mal in einem `tidy` Format, gestaltet sich die Datenanalyse wesentlich einfacher. Leider kann es oft eine Weile dauern, bis man an diesem Punkt ankommt. Deshalb beschäftigen wir uns in diesem Kapitel mit der Datenbereinigung und Funktionen, die dabei hilfreich sind. Wir verwenden dabei vor allem die folgenden Funktionen aus dem `tidyverse`: `select`, `filter`, `arrange`, `mutate`, `summarise` und `group_by`. \n\nDiese Funktionen werden am häufigsten für die Datenreinigung verwendet. Das `dplyr` package aus dem `tidyverse` beinhaltet jedoch noch viel mehr Funktionen, die speziell für die Datenbereinigung äusserst nützlich sind. Das [Daten-Transformation Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf) gibt einen guten Überblick über die wichtigsten Funktionen. Am besten laden Sie dieses dirket herunter, schauen es kurz an und halten es für den Rest des Semseters zur Hand. \n\n\n\n\n\n## Der `Pipe` Operator\nBevor wir beginnen, schauen wir uns den `Pipe` Operator an: `%>%`. Wie in der Abbildung unten dargestellt gibt der `pipe` Operator den Output einer Funktion an die nächste Funktion weiter, die diesen Output als ersten Input verwendet. \n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](_book/_main_files/figure-html/dplyr_pipe.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nDies ermöglich es, Funktionen auf einfache und leserliche Weise zu verknüpfen:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmtcars %>% \n  select(mpg, cyl, wt) %>% \n  filter(wt < 1.8)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|             |  mpg| cyl|    wt|\n|:------------|----:|---:|-----:|\n|Honda Civic  | 30.4|   4| 1.615|\n|Lotus Europa | 30.4|   4| 1.513|\n\n</div>\n:::\n:::\n\n\nSomit können wir verschachtelte Funktionen vermeiden:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfilter(select(mtcars, mpg, cyl, wt), wt < 1.8)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|             |  mpg| cyl|    wt|\n|:------------|----:|---:|-----:|\n|Honda Civic  | 30.4|   4| 1.615|\n|Lotus Europa | 30.4|   4| 1.513|\n\n</div>\n:::\n:::\n\n\nDie erste Schreibweise ist deutlich einfacher zu lesen, oder? Wie im Beispiel unten zu sehen, kommt man dadurch relativ einfach und leserlich von den Rohdaten über Datentransformationen bis hin zur Datenvisualisierung, alles in einer `pipe`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Umfangreiche Pipe-Operation mit mtcars-Daten, die in einem ggplot endet\nmtcars %>%\n  rownames_to_column(\"car_name\") %>%   # Konvertiere Zeilennamen in eine Spalte\n  mutate(mpg_level = cut(mpg, breaks = quantile(mpg, probs = 0:4/4), include.lowest = TRUE, labels = c(\"Niedrig\", \"Mittel\", \"Hoch\", \"Sehr Hoch\"))) %>%  # Erstelle MPG-Niveaus\n  group_by(mpg_level) %>%  # Gruppiere nach dem neu erstellten MPG-Niveau\n  summarise(\n    avg_hp = mean(hp),  # Berechne die durchschnittliche Pferdestärke für jedes Niveau\n    avg_wt = mean(wt)   # Berechne das durchschnittliche Gewicht für jedes Niveau\n  ) %>%\n  ungroup() %>%  # Entferne die Gruppierung\n  ggplot(aes(x = reorder(mpg_level, avg_hp), y = avg_hp, fill = mpg_level)) +  # Erstelle ein Balkendiagramm\n    geom_col() +  # Verwende Balken zur Darstellung der Daten\n    geom_text(aes(label = round(avg_hp, 1)), vjust = -0.5) +  # Füge Textbeschriftungen über den Balken hinzu\n    labs(\n      title = \"Durchschnittliche Pferdestärke nach MPG-Niveaus\",\n      x = \"MPG-Niveau\",\n      y = \"Durchschnittliche Pferdestärke\"\n    ) +\n    theme_minimal() +  # Verwende ein minimales Thema\n    scale_fill_brewer(palette = \"Pastel1\")  # Färbe die Balken mit einer Pastellpalette\n```\n\n::: {.cell-output-display}\n![](06-wrangling_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nFür dieses Kapitel verwenden wir einen selbst generierten Datensatz bestehend aus den Verkäufen, Ausgaben und der Zufriedenheit für zwei Jahre aus vier Regionen und zwei Produkten. Der Code der die Daten generiert stammt aus [diese] (https://psyteachr.github.io/ads-v3/04-summary.html#sec-pipes-first) Buchkapitel. Der für die Datengenerierung verwendete Code ist für sie nicht relevant. \n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nWie bereits besprochen lohnt es sich immer, die Daten als erstes kurz anzuschauen:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020| expenses_2019| expenses_2020|satisfaction_2019 |satisfaction_2020 |\n|:------|:-------|----------:|----------:|-------------:|-------------:|:-----------------|:-----------------|\n|North  |widgets |       2129|       -517|           822|          -897|high              |very high         |\n|North  |gadgets |        723|         77|          1037|          1115|very high         |very high         |\n|South  |widgets |       1123|      -1450|          1004|           672|high              |neutral           |\n|South  |gadgets |       2022|       -945|          -610|           200|low               |low               |\n|East   |widgets |       -728|        -51|          -801|          -342|very low          |very low          |\n|East   |gadgets |       -423|       -354|            94|          2036|neutral           |high              |\n|West   |widgets |        633|        790|           783|          -315|neutral           |neutral           |\n|West   |gadgets |       1204|        426|           433|          -136|low               |low               |\n\n</div>\n:::\n:::\n\n\n\nNun können wir mit dem Data Cleaning beginnen. Oft müssen wir zuerst den Datensatz einschränken, das heisst wir beschränken uns auf bestimmte Varialben (Spalten) und Beobachtungen (Zeilen). Dafür verwenden wir die Funktionen `select` und `filter`.\n\n\n### Spalten auswählen mit `select`\nMit `select` kann man Variablen auswählen. Dies ist nützlich, wenn wir nur einen Teil der Variablen für unsere Auswertung brauchen, was häufig der Fall ist. Es gibt verschiedene Arten, wie man das mit der `select` Funktion tun kann:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#Spalte nach Name auswählen\nbudget %>% select(product) \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|product |\n|:-------|\n|widgets |\n|gadgets |\n|widgets |\n|gadgets |\n|widgets |\n|gadgets |\n|widgets |\n|gadgets |\n\n</div>\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#Spalte nach Index auswählen (2. Spalte)\nbudget %>% select(2) \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|product |\n|:-------|\n|widgets |\n|gadgets |\n|widgets |\n|gadgets |\n|widgets |\n|gadgets |\n|widgets |\n|gadgets |\n\n</div>\n:::\n:::\n\n\nNatürlich wollen wir oft mehr als nur eine Spalte auswählen:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget %>% select(product, sales_2019, expenses_2019) \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|product | sales_2019| expenses_2019|\n|:-------|----------:|-------------:|\n|widgets |       2129|           822|\n|gadgets |        723|          1037|\n|widgets |       1123|          1004|\n|gadgets |       2022|          -610|\n|widgets |       -728|          -801|\n|gadgets |       -423|            94|\n|widgets |        633|           783|\n|gadgets |       1204|           433|\n\n</div>\n:::\n:::\n\n\nUm viele Spalten auf einmal auszuwählen, ist die Doppelpunktnotation hilfreich. Dadurch werden alle Variablen die sich zwischen den beiden spezifizierten Variablen befinden ausgewählt:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget %>% \n  select(region:expenses_2020)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020| expenses_2019| expenses_2020|\n|:------|:-------|----------:|----------:|-------------:|-------------:|\n|North  |widgets |       2129|       -517|           822|          -897|\n|North  |gadgets |        723|         77|          1037|          1115|\n|South  |widgets |       1123|      -1450|          1004|           672|\n|South  |gadgets |       2022|       -945|          -610|           200|\n|East   |widgets |       -728|        -51|          -801|          -342|\n|East   |gadgets |       -423|       -354|            94|          2036|\n|West   |widgets |        633|        790|           783|          -315|\n|West   |gadgets |       1204|        426|           433|          -136|\n\n</div>\n:::\n:::\n\n\n\n\n\n#### Spalten abwählen\nWenn man nur einige Spalten ausschliessen möchte kann es einfacher sein, diese abzuwählen als alle andere auszuwählen. Dies können wir tun, indem wir ein `-` vor die abzuwählende Variable setzen. \n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# einzelne Spalten abwählen\nbudget %>% select(-expenses_2019, -expenses_2020)\n\n# einen Bereich von Spalten abwählen\nbudget %>% select(-(expenses_2019:expenses_2020))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020|satisfaction_2019 |satisfaction_2020 |\n|:------|:-------|----------:|----------:|:-----------------|:-----------------|\n|North  |widgets |       2129|       -517|high              |very high         |\n|North  |gadgets |        723|         77|very high         |very high         |\n|South  |widgets |       1123|      -1450|high              |neutral           |\n|South  |gadgets |       2022|       -945|low               |low               |\n|East   |widgets |       -728|        -51|very low          |very low          |\n|East   |gadgets |       -423|       -354|neutral           |high              |\n|West   |widgets |        633|        790|neutral           |neutral           |\n|West   |gadgets |       1204|        426|low               |low               |\n\n</div><div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020|satisfaction_2019 |satisfaction_2020 |\n|:------|:-------|----------:|----------:|:-----------------|:-----------------|\n|North  |widgets |       2129|       -517|high              |very high         |\n|North  |gadgets |        723|         77|very high         |very high         |\n|South  |widgets |       1123|      -1450|high              |neutral           |\n|South  |gadgets |       2022|       -945|low               |low               |\n|East   |widgets |       -728|        -51|very low          |very low          |\n|East   |gadgets |       -423|       -354|neutral           |high              |\n|West   |widgets |        633|        790|neutral           |neutral           |\n|West   |gadgets |       1204|        426|low               |low               |\n\n</div>\n:::\n:::\n\n\n#### Hilfsfunktionen zum Auswählen\n\nSchließlich können Sie Spalten basierend auf Kriterien über die Spaltennamen auswählen.\n\n| Funktion       | Definition                                            |\n|----------------|-------------------------------------------------------|\n| `starts_with()`| wähle Spalten, die mit einer Zeichenkette beginnen    |\n| `ends_with()`  | wähle Spalten, die mit einer Zeichenkette enden       |\n| `contains()`   | wähle Spalten, die eine Zeichenkette enthalten        |\n| `num_range()`  | wähle Spalten, deren Name dem Muster `prefix` entspricht |\n\n\n### Todo\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n\n### Filtern\nOft ist man auch nur an bestimmten Beobachtungen (Zeilen) interessiert. Diese können wir mit der `filter()` Funktion auswählen. Man kann dabei nach einem oder mehreren Kriterien filtern. Dabei kommen logische Operatoren, wie wir sie bereits besprochen haben, zum Einsatz. Zum Beispiel können wir nur die Beobachtungen auswählen, die aus der Region \"North\" kommen:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# wähle alle Zeilen aus, bei denen die Region Nord entspricht\nbudget %>% filter(region == \"North\")\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020| expenses_2019| expenses_2020|satisfaction_2019 |satisfaction_2020 |\n|:------|:-------|----------:|----------:|-------------:|-------------:|:-----------------|:-----------------|\n|North  |widgets |       2129|       -517|           822|          -897|high              |very high         |\n|North  |gadgets |        723|         77|          1037|          1115|very high         |very high         |\n\n</div>\n:::\n:::\n\n\nDie Auswahl passiert hierbei über die logische Operation `region == \"North\"`. Dieses Statement generiert einen Vektor aus `TRUE` und `FALSE` Werten, über die die Auswahl der Zeilen stattfindet:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget$region == \"North\"\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nMann kann dabei verschiedene logische Operatoren verwenden:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# wähle alle Zeilen aus, bei denen die Region Nord entspricht\nbudget %>% filter(region == \"North\")\n\n# wähle alle Zeilen aus, bei denen die Ausgaben 2020 genau 200 betrugen\nbudget %>% filter(expenses_2020 == 200)\n\n# wähle alle Zeilen aus, bei denen der Verkauf 2019 mehr als 100 betrug\nbudget %>% filter(sales_2019 > 100)\n\n# alles außer dem Norden\nbudget %>% filter(region != \"North\")\n```\n:::\n\n\n::: {.callout-warning}\nDenken Sie daran, `==` und nicht `=` zu verwenden, um zu überprüfen, ob zwei Dinge gleichwertig sind. Ein einzelnes `=` weist den Wert rechts der Variablen links zu (ähnlich wie der Operator `<-`).\n:::\n\nMan kann auch mehrere Kriterien auf einmal spezifizieren. Dies kann man auf zwei verschiedene Arten tun. Werden die Statements mit einem `,` oder `&` getrennt, werden nur die Zeilen ausgewählt, die alle Bedingungen erfüllen. So können wir zum Beispiel Zeilen auswählen, die im Jahr 2019 und 2020 ausgaben über 100 hatten:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget %>% \n  filter(\n    sales_2019 > 100 & sales_2020 > 100\n  )\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020| expenses_2019| expenses_2020|satisfaction_2019 |satisfaction_2020 |\n|:------|:-------|----------:|----------:|-------------:|-------------:|:-----------------|:-----------------|\n|West   |widgets |        633|        790|           783|          -315|neutral           |neutral           |\n|West   |gadgets |       1204|        426|           433|          -136|low               |low               |\n\n</div>\n:::\n:::\n\n\nDies ist eine sogenannte \"und\" Verknüpfung. Wir können auch eine \"oder\" Verknüpfung verwenden, dann werden alle Zeilen ausgewählt, die mindestens eine der Bedingungen erfüllen:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget %>%\n  filter(\n    sales_2019 > 100 | sales_2020 > 100\n  )\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020| expenses_2019| expenses_2020|satisfaction_2019 |satisfaction_2020 |\n|:------|:-------|----------:|----------:|-------------:|-------------:|:-----------------|:-----------------|\n|North  |widgets |       2129|       -517|           822|          -897|high              |very high         |\n|North  |gadgets |        723|         77|          1037|          1115|very high         |very high         |\n|South  |widgets |       1123|      -1450|          1004|           672|high              |neutral           |\n|South  |gadgets |       2022|       -945|          -610|           200|low               |low               |\n|West   |widgets |        633|        790|           783|          -315|neutral           |neutral           |\n|West   |gadgets |       1204|        426|           433|          -136|low               |low               |\n\n</div>\n:::\n:::\n\n\nUm die Auswahl zu vereinfachen, wenn man nach mehreren Kriterien filtern will, gibt es den \"Übereinstimmungsoperator\" (`%in%`). \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# behalte alle Zeilen, bei denen die Region Nord oder Süd ist und das Produkt Widgets entspricht\nbudget %>%\n  filter(region %in% c(\"North\", \"South\"),\n         product == \"widgets\")\n```\n:::\n\n\nAbschliessend hier eine Übersicht mit den verschiedenen logischen Operatoren, die zum Filtern von Zeilen (Beobachtungen) verwendet werden können: \n\n \n`\"Operator\"`\t|Name   |ist WAHR, wenn und nur wenn\n-----------|----------------------|---------------------------------\n`A < B`    |kleiner als\t          |A ist kleiner als B\n`A <= B`   |kleiner oder gleich    |A ist kleiner oder gleich B\n`A > B`    |größer als\t          |A ist größer als B\n`A >= B`   |größer oder gleich     |A ist größer oder gleich B\n`A == B`   |Äquivalenz\t          |A entspricht genau B\n`A != B`   |nicht gleich\t          |A entspricht nicht genau B\n`A %in% B` |in\t                  |A ist ein Element des Vektors B\n\n\n::: {.callout-warning}\n`filter()` ist unglaublich leistungsfähig und kann Ihnen ermöglichen, sehr spezifische Teilmengen von Daten auszuwählen. Aber es ist auch ziemlich gefährlich, denn wenn Sie mehrere Kriterien und Operatoren kombinieren, ist es sehr einfach, versehentlich etwas leicht anders zu spezifizieren, als Sie beabsichtigt haben. **Überprüfen Sie immer Ihre Ausgabe**. Wenn Sie einen kleinen Datensatz haben, können Sie ihn visuell überprüfen, um zu sehen, ob er richtig aussieht. Bei einem größeren Datensatz möchten Sie vielleicht Zusammenfassungsstatistiken berechnen oder die Anzahl der Gruppen/Beobachtungen in jeder Variablen zählen, um zu überprüfen, ob Ihr Filter korrekt ist. Es gibt kein Expertenniveau im Codieren, das das Wissen und die Überprüfung Ihrer Daten ersetzen kann.\n:::\n\n### Anordnen {#sec-arrange}\n\nNachdem wir die gewünschten Spalten (`select`) und Zeilen (`filter`) ausgewählt haben, wollen wir die Daten eventuell noch sortieren. Dies kann zum Beispiel bei Paneldaten sinnvoll sein. Sortieren kann auch für die Darstellung in Tabellen hilfreich sein. Wir können Daten nach den Werten in bestimmten Spalten mit `arrange` sortieren:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Anordnen der Tabelle \n# zuerst nach Region in alphabetischer Reihenfolge\n# dann nach \"product\" in umgekehrter alphabetischer Reihenfolge (mit der Hilfsfunktion `desc`)\nbudget %>%\n  arrange(region, desc(product))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product | sales_2019| sales_2020| expenses_2019| expenses_2020|satisfaction_2019 |satisfaction_2020 |\n|:------|:-------|----------:|----------:|-------------:|-------------:|:-----------------|:-----------------|\n|North  |gadgets |        723|         77|          1037|          1115|very high         |very high         |\n|North  |widgets |       2129|       -517|           822|          -897|high              |very high         |\n|South  |gadgets |       2022|       -945|          -610|           200|low               |low               |\n|South  |widgets |       1123|      -1450|          1004|           672|high              |neutral           |\n|East   |gadgets |       -423|       -354|            94|          2036|neutral           |high              |\n|East   |widgets |       -728|        -51|          -801|          -342|very low          |very low          |\n|West   |gadgets |       1204|        426|           433|          -136|low               |low               |\n|West   |widgets |        633|        790|           783|          -315|neutral           |neutral           |\n\n</div>\n:::\n:::\n\n\n\n### Mutieren\n\nDie Funktion `mutate()` ermöglicht es, neue Spalten hinzuzufügen oder bestehende zu ändern. Dies geschieht mit folgender Syntax: `mutate(neue_Spalte = Berechnung)`. Es können auch mehrere neue Spalten in einem einzigen `mutate` Call generiert werden.Sobald eine neue Spalte erstellt wurde, kann diese in weiteren berechnungen innerhalb des selben `mutate` Calls verwendet werden. Zum Beispiel verwendet die Erstellung von `profit` unten die Spalte `expenses`, die darüber erstellt wird.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget2 <- budget %>%\n  mutate(\n    sales = sales_2019 + sales_2020,\n    expenses = expenses_2019 + expenses_2020,\n    profit = sales - expenses,\n    region = paste(region, \"Office\")\n  )\n\nbudget2\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region       |product | sales_2019| sales_2020| expenses_2019| expenses_2020|satisfaction_2019 |satisfaction_2020 | sales| expenses| profit|\n|:------------|:-------|----------:|----------:|-------------:|-------------:|:-----------------|:-----------------|-----:|--------:|------:|\n|North Office |widgets |       2129|       -517|           822|          -897|high              |very high         |  1612|      -75|   1687|\n|North Office |gadgets |        723|         77|          1037|          1115|very high         |very high         |   800|     2152|  -1352|\n|South Office |widgets |       1123|      -1450|          1004|           672|high              |neutral           |  -327|     1676|  -2003|\n|South Office |gadgets |       2022|       -945|          -610|           200|low               |low               |  1077|     -410|   1487|\n|East Office  |widgets |       -728|        -51|          -801|          -342|very low          |very low          |  -779|    -1143|    364|\n|East Office  |gadgets |       -423|       -354|            94|          2036|neutral           |high              |  -777|     2130|  -2907|\n|West Office  |widgets |        633|        790|           783|          -315|neutral           |neutral           |  1423|      468|    955|\n|West Office  |gadgets |       1204|        426|           433|          -136|low               |low               |  1630|      297|   1333|\n\n</div>\n:::\n:::\n\n\n`mutate()` kann auch in Verbindung mit anderen Funktionen und Logischen Operatoren verwendet werden. Zum Beispiel können wir eine weitere Spalte zu `budget2` hinzufügen, die angibt, ob in diesem Jahr ein Gewinn erzielt wurde, oder unsere `product`-Variable als Faktor überschreiben. Genau wie bei der Verwendung von Logischen Operatoren mit `filter()` wird die Gleichung ausgewertet und gibt TRUE oder FALSE zurück, je nachdem, ob die Beobachtung das Kriterium erfüllt.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget2 <- budget2 %>%\n  mutate(profit_category = profit > 0,\n         product = as.factor(product))\n```\n:::\n\n\nIst der neue Variablenname gleich wie der alte, wird die bestehende Variable überschrieben. \n\nIm Zusammenhang mit `mutate` ist `case_when` eine sehr nützliche Funktion, um basierend auf einer Reihe von Bedingungen (logischen Statmements) eine neue Variable zu generieren. So können wir zum Beispiel den Gewinn in mehrere Kategorien einteilen: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget2 %>%\n  mutate(profit_category = case_when(profit < 0 ~ \"kein Gewinn\",\n                                     profit > 100 ~ \"kleiner Gewinn\",\n                                     profit > 200 ~ \"hoher Gewinn\")) %>% \n  select(profit, profit_category)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| profit|profit_category |\n|------:|:---------------|\n|   1687|kleiner Gewinn  |\n|  -1352|kein Gewinn     |\n|  -2003|kein Gewinn     |\n|   1487|kleiner Gewinn  |\n|    364|kleiner Gewinn  |\n|  -2907|kein Gewinn     |\n|    955|kleiner Gewinn  |\n|   1333|kleiner Gewinn  |\n\n</div>\n:::\n:::\n\n\nFalls für eine Beobachtung keine der Bedingungen zutrifft, generiert die Funktion den Wert `NA`. Dem müssen wir uns bewusst sein und wenn möglich Bedingugen generieren, die allen Werten einen neuen Wert zuweisen. Diese Bedingungen wären in diesem Fall sinnvoller:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget2 %>%\n  mutate(profit_category = case_when(profit <= 0 ~ \"kein Gewinn\",\n                                     profit > 0 ~ \"kleiner Gewinn\",\n                                     profit > 100 ~ \"mittlerer Gewinn\",\n                                     profit > 200 ~ \"hoher Gewinn\")) %>% \n  select(profit, profit_category)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| profit|profit_category |\n|------:|:---------------|\n|   1687|kleiner Gewinn  |\n|  -1352|kein Gewinn     |\n|  -2003|kein Gewinn     |\n|   1487|kleiner Gewinn  |\n|    364|kleiner Gewinn  |\n|  -2907|kein Gewinn     |\n|    955|kleiner Gewinn  |\n|   1333|kleiner Gewinn  |\n\n</div>\n:::\n:::\n\n\nMann kann auch einen \"default\" Wert spezifizieren, den die Zeilen der neuen Spalte annehmen, falls keine andere Bedingung zutrifft:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget2 %>%\n  mutate(profit_category = case_when(profit <= 0 ~ \"kein Gewinn\",\n                                     .default = \"Gewinn\")) %>% \n  select(profit, profit_category)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| profit|profit_category |\n|------:|:---------------|\n|   1687|Gewinn          |\n|  -1352|kein Gewinn     |\n|  -2003|kein Gewinn     |\n|   1487|Gewinn          |\n|    364|Gewinn          |\n|  -2907|kein Gewinn     |\n|    955|Gewinn          |\n|   1333|Gewinn          |\n\n</div>\n:::\n:::\n\n\n\n\n\n### Zusammenfassen {#sec-dplyr-summarise}\nDie Funktion `mutate` generiert für jede bestehende Beobachtung einen neuen Wert. Oft wollen wir aber Berechnungen anstellen, die bestehende Werte zusammenfast. Dafür verwenden wir die Funktion `summarise`. Bevor wir Beispiele von `summarise` anschauen, bringen wir die Daten in ein `tidy` Format:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget4 <- budget %>%\n  select(-satisfaction_2019, -satisfaction_2020) %>%\n  pivot_longer(cols = sales_2019:expenses_2020,\n               names_to = c(\"type\", \"year\"),\n               names_sep = \"_\",\n               values_to = \"value\") %>%\n  pivot_wider(names_from = type,\n              values_from = value)\n\nhead(budget4) # Überprüfen Sie das Format\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product |year | sales| expenses|\n|:------|:-------|:----|-----:|--------:|\n|North  |widgets |2019 |  2129|      822|\n|North  |widgets |2020 |  -517|     -897|\n|North  |gadgets |2019 |   723|     1037|\n|North  |gadgets |2020 |    77|     1115|\n|South  |widgets |2019 |  1123|     1004|\n|South  |widgets |2020 | -1450|      672|\n\n</div>\n:::\n:::\n\n\nJetzt können wir zum Beispiel Kennzahlen wie die durchschnittlichen Verkäufe und Ausgaben, sowie das Minimum und Maximum des Gewinnes berechnen:  \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget4 %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  )\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| mean_sales| mean_expenses| min_profit| max_profit|\n|----------:|-------------:|----------:|----------:|\n|   291.1875|      318.4375|      -2632|       2390|\n\n</div>\n:::\n:::\n\nWir sehen, dass `summarise` wie `mutate` funktioniert, jedoch mehrere Beobachtungen zu einer neuen, aggregierten, Beobachtung zusammenfasst.\n\nOft interessieren wir uns aber für solche Kennzahlen getrennt nach Gruppen. Zum Beispiel wäre es gut zu wissen, inwiefern sich die durchschnittlichen Verkäufe und Ausgaben nach Region unterscheiden. Dies können wir mit der `group_by` Funktion tun. \n\n\n### Gruppieren {#sec-dplyr-groupby}\nDie Funktion `group_by()` nimmt bestehende Daten und wandelt sie in eine gruppierte Tabelle um, in der alle Berechnungen, die anschließend darauf ausgeführt werden, \"nach Gruppe\" durchgeführt werden. Schauen wir uns als erste an was passiert, wenn wir die `group_by` Funktion anwenden:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget4 %>%\n  group_by(year, product)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product |year | sales| expenses|\n|:------|:-------|:----|-----:|--------:|\n|North  |widgets |2019 |  2129|      822|\n|North  |widgets |2020 |  -517|     -897|\n|North  |gadgets |2019 |   723|     1037|\n|North  |gadgets |2020 |    77|     1115|\n|South  |widgets |2019 |  1123|     1004|\n|South  |widgets |2020 | -1450|      672|\n|South  |gadgets |2019 |  2022|     -610|\n|South  |gadgets |2020 |  -945|      200|\n|East   |widgets |2019 |  -728|     -801|\n|East   |widgets |2020 |   -51|     -342|\n|East   |gadgets |2019 |  -423|       94|\n|East   |gadgets |2020 |  -354|     2036|\n|West   |widgets |2019 |   633|      783|\n|West   |widgets |2020 |   790|     -315|\n|West   |gadgets |2019 |  1204|      433|\n|West   |gadgets |2020 |   426|     -136|\n\n</div>\n:::\n:::\n\n\nWir sehen, dass der Datensatz nun nach den Variablen `year` und `product` gruppiert ist. Zudem sehen wir, dass es vier solcher Gruppen gibt. Alle nachfolgenden Berechnungen (z.B. mit `summarise`) werden nun separat nach diesen Gruppen durchgeführt. So werden zum Beispile die Mittelwerte getrennt nach diesen vier Gruppen berechnet:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nyear_prod <- budget4 %>%\n  group_by(year, product) %>%\n  summarise(\n    mean_sales = mean(sales\n\n),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  ) %>% \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n```\n\n\n:::\n\n```{.r .cell-code}\nyear_prod\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|year |product | mean_sales| mean_expenses| min_profit| max_profit|\n|:----|:-------|----------:|-------------:|----------:|----------:|\n|2019 |widgets |     789.25|        452.00|      -1307|        150|\n|2019 |gadgets |     881.50|        238.50|      -2632|        517|\n|2020 |widgets |    -307.00|       -220.50|      -1105|       2122|\n|2020 |gadgets |    -199.00|        803.75|       -562|       2390|\n\n</div>\n:::\n:::\n\n\nDamit die Daten nicht gruppiert bleiben, wenden wir zum Schluss noch d ie Funktion `ungroup` an die wie der Name sagt, die Gruppierung aufhebt. \n\nWir können die `group_by` Funktion auch mit anderen Funktionen, die wir bereits kennengelernt haben, verwenden. So können wir zum Beispiel pro Gruppe die Beobachtung mit dem grössten Verkaufsvolumen herausfiltern:\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget4 %>% \n  group_by(year, product) %>% \n  filter(sales == max(sales))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|region |product |year | sales| expenses|\n|:------|:-------|:----|-----:|--------:|\n|North  |widgets |2019 |  2129|      822|\n|South  |gadgets |2019 |  2022|     -610|\n|West   |widgets |2020 |   790|     -315|\n|West   |gadgets |2020 |   426|     -136|\n\n</div>\n:::\n:::\n",
    "supporting": [
      "06-wrangling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}