{"title":"Datenbereinigung","markdown":{"headingText":"Datenbereinigung","headingAttr":{"id":"sec-wrangle","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n## Beabsichtigte Lernergebnisse {#sec-ilo-wrangle .unnumbered}\n\n* Daten auswählen und filtern können, um Relevanz sicherzustellen\n* Neue Spalten erstellen und bestehende bearbeiten können\n* Mit fehlenden Daten umgehen können\n\n\n```{r, include = FALSE}\n# Lade Tidyverse-Pakete separat, damit Auto-Links in `func()`-Notation funktionieren\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(tibble)\nlibrary(janitor)\nlibrary(ggplot2)\nlibrary(faux)\n```\n\n\n\nLaden Sie das [Daten-Transformation Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf) herunter.\n\n## Data Cleaning\nIm letzten Kapitel haben wir das `Tidy Data`Konzept kennengelernt. Sind die Daten erst mal in einem `tidy` Format, gestaltet sich die Datenanalyse wesentlich einfacher. Leider kann es oft eine Weile dauern, bis man an diesem Punkt ankommt. Deshalb beschäftigen wir uns in diesem Kapitel mit der Datenbereinigung und Funktionen, die dabei hilfreich sind. Wir verwenden dabei vor allem die folgenden Funktionen aus dem `tidyverse`: `select`, `filter`, `arrange`, `mutate`, `summarise` und `group_by`. \n\nDiese Funktionen werden am häufigsten für die Datenreinigung verwendet. Das `dplyr` package aus dem `tidyverse` beinhaltet jedoch noch viel mehr Funktionen, die speziell für die Datenbereinigung äusserst nützlich sind. Das [Daten-Transformation Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf) gibt einen guten Überblick über die wichtigsten Funktionen. Am besten laden Sie dieses dirket herunter, schauen es kurz an und halten es für den Rest des Semseters zur Hand. \n\n\n\n\n\n## Der `Pipe` Operator\nBevor wir beginnen, schauen wir uns den `Pipe` Operator an: `%>%`. Wie in der Abbildung unten dargestellt gibt der `pipe` Operator den Output einer Funktion an die nächste Funktion weiter, die diesen Output als ersten Input verwendet. \n\n\n```{r, echo=FALSE}\nknitr::include_graphics(\"_book/_main_files/figure-html/dplyr_pipe.png\") \n```\n\n\nDies ermöglich es, Funktionen auf einfache und leserliche Weise zu verknüpfen:\n\n```{r}\nmtcars %>% \n  select(mpg, cyl, wt) %>% \n  filter(wt < 1.8)\n```\n\nSomit können wir verschachtelte Funktionen vermeiden:\n```{r}\nfilter(select(mtcars, mpg, cyl, wt), wt < 1.8)\n```\n\nDie erste Schreibweise ist deutlich einfacher zu lesen, oder? Wie im Beispiel unten zu sehen, kommt man dadurch relativ einfach und leserlich von den Rohdaten über Datentransformationen bis hin zur Datenvisualisierung, alles in einer `pipe`.\n\n```{r}\n# Umfangreiche Pipe-Operation mit mtcars-Daten, die in einem ggplot endet\nmtcars %>%\n  rownames_to_column(\"car_name\") %>%   # Konvertiere Zeilennamen in eine Spalte\n  mutate(mpg_level = cut(mpg, breaks = quantile(mpg, probs = 0:4/4), include.lowest = TRUE, labels = c(\"Niedrig\", \"Mittel\", \"Hoch\", \"Sehr Hoch\"))) %>%  # Erstelle MPG-Niveaus\n  group_by(mpg_level) %>%  # Gruppiere nach dem neu erstellten MPG-Niveau\n  summarise(\n    avg_hp = mean(hp),  # Berechne die durchschnittliche Pferdestärke für jedes Niveau\n    avg_wt = mean(wt)   # Berechne das durchschnittliche Gewicht für jedes Niveau\n  ) %>%\n  ungroup() %>%  # Entferne die Gruppierung\n  ggplot(aes(x = reorder(mpg_level, avg_hp), y = avg_hp, fill = mpg_level)) +  # Erstelle ein Balkendiagramm\n    geom_col() +  # Verwende Balken zur Darstellung der Daten\n    geom_text(aes(label = round(avg_hp, 1)), vjust = -0.5) +  # Füge Textbeschriftungen über den Balken hinzu\n    labs(\n      title = \"Durchschnittliche Pferdestärke nach MPG-Niveaus\",\n      x = \"MPG-Niveau\",\n      y = \"Durchschnittliche Pferdestärke\"\n    ) +\n    theme_minimal() +  # Verwende ein minimales Thema\n    scale_fill_brewer(palette = \"Pastel1\")  # Färbe die Balken mit einer Pastellpalette\n```\n\n\nFür dieses Kapitel verwenden wir einen selbst generierten Datensatz bestehend aus den Verkäufen, Ausgaben und der Zufriedenheit für zwei Jahre aus vier Regionen und zwei Produkten. Der Code der die Daten generiert stammt aus [diese] (https://psyteachr.github.io/ads-v3/04-summary.html#sec-pipes-first) Buchkapitel. Der für die Datengenerierung verwendete Code ist für sie nicht relevant. \n\n\n```{r, echo = FALSE, eval = TRUE}\nset.seed(8675309)\nbudget <- faux::sim_design(\n  between = list(\n    region = c(\"North\", \"South\", \"East\", \"West\"),\n    product = c(\"widgets\", \"gadgets\")\n  ),\n  within = list(\n    type = c(\"sales\", \"expenses\"),\n    year = 2019:2020\n  ),\n  n = 1,\n  mu = rep(c(100, 50), each = 4, times = 4),\n  sd = 1000,\n  plot = FALSE\n) %>%\n  mutate_if(is.numeric, round) %>%\n  select(-id) %>%\n  mutate(satisfaction_2019 = c(\"high\", \"very high\", \"high\", \"low\", \"very low\", \"neutral\", \"neutral\", \"low\"),\n         satisfaction_2020 = c(\"very high\", \"very high\", \"neutral\", \"low\", \"very low\", \"high\", \"neutral\", \"low\"))\n\n#write_csv(budget, \"data/budget.csv\")\n```\n\nWie bereits besprochen lohnt es sich immer, die Daten als erstes kurz anzuschauen:\n```{r}\nbudget\n```\n\n\nNun können wir mit dem Data Cleaning beginnen. Oft müssen wir zuerst den Datensatz einschränken, das heisst wir beschränken uns auf bestimmte Varialben (Spalten) und Beobachtungen (Zeilen). Dafür verwenden wir die Funktionen `select` und `filter`.\n\n\n### Spalten auswählen mit `select`\nMit `select` kann man Variablen auswählen. Dies ist nützlich, wenn wir nur einen Teil der Variablen für unsere Auswertung brauchen, was häufig der Fall ist. Es gibt verschiedene Arten, wie man das mit der `select` Funktion tun kann:\n\n```{r}\n#Spalte nach Name auswählen\nbudget %>% select(product) \n```\n\n\n```{r}\n#Spalte nach Index auswählen (2. Spalte)\nbudget %>% select(2) \n```\n\nNatürlich wollen wir oft mehr als nur eine Spalte auswählen:\n```{r}\nbudget %>% select(product, sales_2019, expenses_2019) \n```\n\nUm viele Spalten auf einmal auszuwählen, ist die Doppelpunktnotation hilfreich. Dadurch werden alle Variablen die sich zwischen den beiden spezifizierten Variablen befinden ausgewählt:\n```{r}\nbudget %>% \n  select(region:expenses_2020)\n```\n\n\n\n\n#### Spalten abwählen\nWenn man nur einige Spalten ausschliessen möchte kann es einfacher sein, diese abzuwählen als alle andere auszuwählen. Dies können wir tun, indem wir ein `-` vor die abzuwählende Variable setzen. \n\n\n\n```{r}\n# einzelne Spalten abwählen\nbudget %>% select(-expenses_2019, -expenses_2020)\n\n# einen Bereich von Spalten abwählen\nbudget %>% select(-(expenses_2019:expenses_2020))\n```\n\n#### Hilfsfunktionen zum Auswählen\n\nSchließlich können Sie Spalten basierend auf Kriterien über die Spaltennamen auswählen.\n\n| Funktion       | Definition                                            |\n|----------------|-------------------------------------------------------|\n| `starts_with()`| wähle Spalten, die mit einer Zeichenkette beginnen    |\n| `ends_with()`  | wähle Spalten, die mit einer Zeichenkette enden       |\n| `contains()`   | wähle Spalten, die eine Zeichenkette enthalten        |\n| `num_range()`  | wähle Spalten, deren Name dem Muster `prefix` entspricht |\n\n\n### Todo\n\n```{r select-helpers, echo = FALSE}\nx1 <- budget %>% select(starts_with(\"sales\"))\nx2 <- budget %>% select(ends_with(\"2020\"))\nx3 <- budget %>% select(contains(\"_\"))\nx4 <- budget %>% select(num_range(\"expenses_\", 2019:2020))\n\na <- list(names(x1), names(x2), names(x3), names(x4)) %>%\n  sapply(paste, collapse = \", \")\n\n# a1 <- setNames(a, c(\"answer\", \"x\", \"x\", \"x\")) %>% longmcq()\n# a2 <- setNames(a, c(\"x\", \"answer\", \"x\", \"x\")) %>% longmcq()\n# a3 <- setNames(a, c(\"x\", \"x\", \"answer\", \"x\")) %>% longmcq()\n# a4 <- setNames(a, c(\"x\", \"x\", \"x\", \"answer\")) %>% longmcq()\n```\n\n\n\n### Filtern\nOft ist man auch nur an bestimmten Beobachtungen (Zeilen) interessiert. Diese können wir mit der `filter()` Funktion auswählen. Man kann dabei nach einem oder mehreren Kriterien filtern. Dabei kommen logische Operatoren, wie wir sie bereits besprochen haben, zum Einsatz. Zum Beispiel können wir nur die Beobachtungen auswählen, die aus der Region \"North\" kommen:\n```{r}\n# wähle alle Zeilen aus, bei denen die Region Nord entspricht\nbudget %>% filter(region == \"North\")\n```\n\nDie Auswahl passiert hierbei über die logische Operation `region == \"North\"`. Dieses Statement generiert einen Vektor aus `TRUE` und `FALSE` Werten, über die die Auswahl der Zeilen stattfindet:\n```{r}\nbudget$region == \"North\"\n```\n\nMann kann dabei verschiedene logische Operatoren verwenden:\n\n```{r filter, eval = FALSE}\n# wähle alle Zeilen aus, bei denen die Region Nord entspricht\nbudget %>% filter(region == \"North\")\n\n# wähle alle Zeilen aus, bei denen die Ausgaben 2020 genau 200 betrugen\nbudget %>% filter(expenses_2020 == 200)\n\n# wähle alle Zeilen aus, bei denen der Verkauf 2019 mehr als 100 betrug\nbudget %>% filter(sales_2019 > 100)\n\n# alles außer dem Norden\nbudget %>% filter(region != \"North\")\n```\n\n::: {.callout-warning}\nDenken Sie daran, `==` und nicht `=` zu verwenden, um zu überprüfen, ob zwei Dinge gleichwertig sind. Ein einzelnes `=` weist den Wert rechts der Variablen links zu (ähnlich wie der Operator `<-`).\n:::\n\nMan kann auch mehrere Kriterien auf einmal spezifizieren. Dies kann man auf zwei verschiedene Arten tun. Werden die Statements mit einem `,` oder `&` getrennt, werden nur die Zeilen ausgewählt, die alle Bedingungen erfüllen. So können wir zum Beispiel Zeilen auswählen, die im Jahr 2019 und 2020 ausgaben über 100 hatten:\n```{r}\nbudget %>% \n  filter(\n    sales_2019 > 100 & sales_2020 > 100\n  )\n```\n\nDies ist eine sogenannte \"und\" Verknüpfung. Wir können auch eine \"oder\" Verknüpfung verwenden, dann werden alle Zeilen ausgewählt, die mindestens eine der Bedingungen erfüllen:\n```{r}\nbudget %>%\n  filter(\n    sales_2019 > 100 | sales_2020 > 100\n  )\n```\n\nUm die Auswahl zu vereinfachen, wenn man nach mehreren Kriterien filtern will, gibt es den \"Übereinstimmungsoperator\" (`%in%`). \n\n\n```{r match-operator, eval = FALSE}\n# behalte alle Zeilen, bei denen die Region Nord oder Süd ist und das Produkt Widgets entspricht\nbudget %>%\n  filter(region %in% c(\"North\", \"South\"),\n         product == \"widgets\")\n```\n\nAbschliessend hier eine Übersicht mit den verschiedenen logischen Operatoren, die zum Filtern von Zeilen (Beobachtungen) verwendet werden können: \n\n \n`\"Operator\"`\t|Name   |ist WAHR, wenn und nur wenn\n-----------|----------------------|---------------------------------\n`A < B`    |kleiner als\t          |A ist kleiner als B\n`A <= B`   |kleiner oder gleich    |A ist kleiner oder gleich B\n`A > B`    |größer als\t          |A ist größer als B\n`A >= B`   |größer oder gleich     |A ist größer oder gleich B\n`A == B`   |Äquivalenz\t          |A entspricht genau B\n`A != B`   |nicht gleich\t          |A entspricht nicht genau B\n`A %in% B` |in\t                  |A ist ein Element des Vektors B\n\n\n::: {.callout-warning}\n`filter()` ist unglaublich leistungsfähig und kann Ihnen ermöglichen, sehr spezifische Teilmengen von Daten auszuwählen. Aber es ist auch ziemlich gefährlich, denn wenn Sie mehrere Kriterien und Operatoren kombinieren, ist es sehr einfach, versehentlich etwas leicht anders zu spezifizieren, als Sie beabsichtigt haben. **Überprüfen Sie immer Ihre Ausgabe**. Wenn Sie einen kleinen Datensatz haben, können Sie ihn visuell überprüfen, um zu sehen, ob er richtig aussieht. Bei einem größeren Datensatz möchten Sie vielleicht Zusammenfassungsstatistiken berechnen oder die Anzahl der Gruppen/Beobachtungen in jeder Variablen zählen, um zu überprüfen, ob Ihr Filter korrekt ist. Es gibt kein Expertenniveau im Codieren, das das Wissen und die Überprüfung Ihrer Daten ersetzen kann.\n:::\n\n### Anordnen {#sec-arrange}\n\nNachdem wir die gewünschten Spalten (`select`) und Zeilen (`filter`) ausgewählt haben, wollen wir die Daten eventuell noch sortieren. Dies kann zum Beispiel bei Paneldaten sinnvoll sein. Sortieren kann auch für die Darstellung in Tabellen hilfreich sein. Wir können Daten nach den Werten in bestimmten Spalten mit `arrange` sortieren:\n\n\n```{r arrange}\n# Anordnen der Tabelle \n# zuerst nach Region in alphabetischer Reihenfolge\n# dann nach \"product\" in umgekehrter alphabetischer Reihenfolge (mit der Hilfsfunktion `desc`)\nbudget %>%\n  arrange(region, desc(product))\n```\n\n\n### Mutieren\n\nDie Funktion `mutate()` ermöglicht es, neue Spalten hinzuzufügen oder bestehende zu ändern. Dies geschieht mit folgender Syntax: `mutate(neue_Spalte = Berechnung)`. Es können auch mehrere neue Spalten in einem einzigen `mutate` Call generiert werden.Sobald eine neue Spalte erstellt wurde, kann diese in weiteren berechnungen innerhalb des selben `mutate` Calls verwendet werden. Zum Beispiel verwendet die Erstellung von `profit` unten die Spalte `expenses`, die darüber erstellt wird.\n\n```{r mutate}\nbudget2 <- budget %>%\n  mutate(\n    sales = sales_2019 + sales_2020,\n    expenses = expenses_2019 + expenses_2020,\n    profit = sales - expenses,\n    region = paste(region, \"Office\")\n  )\n\nbudget2\n```\n\n`mutate()` kann auch in Verbindung mit anderen Funktionen und Logischen Operatoren verwendet werden. Zum Beispiel können wir eine weitere Spalte zu `budget2` hinzufügen, die angibt, ob in diesem Jahr ein Gewinn erzielt wurde, oder unsere `product`-Variable als Faktor überschreiben. Genau wie bei der Verwendung von Logischen Operatoren mit `filter()` wird die Gleichung ausgewertet und gibt TRUE oder FALSE zurück, je nachdem, ob die Beobachtung das Kriterium erfüllt.\n\n```{r}\nbudget2 <- budget2 %>%\n  mutate(profit_category = profit > 0,\n         product = as.factor(product))\n```\n\nIst der neue Variablenname gleich wie der alte, wird die bestehende Variable überschrieben. \n\nIm Zusammenhang mit `mutate` ist `case_when` eine sehr nützliche Funktion, um basierend auf einer Reihe von Bedingungen (logischen Statmements) eine neue Variable zu generieren. So können wir zum Beispiel den Gewinn in mehrere Kategorien einteilen: \n\n\n```{r}\nbudget2 %>%\n  mutate(profit_category = case_when(profit < 0 ~ \"kein Gewinn\",\n                                     profit > 100 ~ \"kleiner Gewinn\",\n                                     profit > 200 ~ \"hoher Gewinn\")) %>% \n  select(profit, profit_category)\n```\n\nFalls für eine Beobachtung keine der Bedingungen zutrifft, generiert die Funktion den Wert `NA`. Dem müssen wir uns bewusst sein und wenn möglich Bedingugen generieren, die allen Werten einen neuen Wert zuweisen. Diese Bedingungen wären in diesem Fall sinnvoller:\n\n```{r}\nbudget2 %>%\n  mutate(profit_category = case_when(profit <= 0 ~ \"kein Gewinn\",\n                                     profit > 0 ~ \"kleiner Gewinn\",\n                                     profit > 100 ~ \"mittlerer Gewinn\",\n                                     profit > 200 ~ \"hoher Gewinn\")) %>% \n  select(profit, profit_category)\n```\n\nMann kann auch einen \"default\" Wert spezifizieren, den die Zeilen der neuen Spalte annehmen, falls keine andere Bedingung zutrifft:\n\n```{r}\nbudget2 %>%\n  mutate(profit_category = case_when(profit <= 0 ~ \"kein Gewinn\",\n                                     .default = \"Gewinn\")) %>% \n  select(profit, profit_category)\n```\n\n\n\n\n### Zusammenfassen {#sec-dplyr-summarise}\nDie Funktion `mutate` generiert für jede bestehende Beobachtung einen neuen Wert. Oft wollen wir aber Berechnungen anstellen, die bestehende Werte zusammenfast. Dafür verwenden wir die Funktion `summarise`. Bevor wir Beispiele von `summarise` anschauen, bringen wir die Daten in ein `tidy` Format:\n\n\n```{r}\nbudget4 <- budget %>%\n  select(-satisfaction_2019, -satisfaction_2020) %>%\n  pivot_longer(cols = sales_2019:expenses_2020,\n               names_to = c(\"type\", \"year\"),\n               names_sep = \"_\",\n               values_to = \"value\") %>%\n  pivot_wider(names_from = type,\n              values_from = value)\n\nhead(budget4) # Überprüfen Sie das Format\n```\n\nJetzt können wir zum Beispiel Kennzahlen wie die durchschnittlichen Verkäufe und Ausgaben, sowie das Minimum und Maximum des Gewinnes berechnen:  \n\n```{r}\nbudget4 %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  )\n```\nWir sehen, dass `summarise` wie `mutate` funktioniert, jedoch mehrere Beobachtungen zu einer neuen, aggregierten, Beobachtung zusammenfasst.\n\nOft interessieren wir uns aber für solche Kennzahlen getrennt nach Gruppen. Zum Beispiel wäre es gut zu wissen, inwiefern sich die durchschnittlichen Verkäufe und Ausgaben nach Region unterscheiden. Dies können wir mit der `group_by` Funktion tun. \n\n\n### Gruppieren {#sec-dplyr-groupby}\nDie Funktion `group_by()` nimmt bestehende Daten und wandelt sie in eine gruppierte Tabelle um, in der alle Berechnungen, die anschließend darauf ausgeführt werden, \"nach Gruppe\" durchgeführt werden. Schauen wir uns als erste an was passiert, wenn wir die `group_by` Funktion anwenden:\n```{r}\nbudget4 %>%\n  group_by(year, product)\n```\n\nWir sehen, dass der Datensatz nun nach den Variablen `year` und `product` gruppiert ist. Zudem sehen wir, dass es vier solcher Gruppen gibt. Alle nachfolgenden Berechnungen (z.B. mit `summarise`) werden nun separat nach diesen Gruppen durchgeführt. So werden zum Beispile die Mittelwerte getrennt nach diesen vier Gruppen berechnet:\n\n```{r}\nyear_prod <- budget4 %>%\n  group_by(year, product) %>%\n  summarise(\n    mean_sales = mean(sales\n\n),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  ) %>% \n  ungroup()\n\nyear_prod\n```\n\nDamit die Daten nicht gruppiert bleiben, wenden wir zum Schluss noch d ie Funktion `ungroup` an die wie der Name sagt, die Gruppierung aufhebt. \n\nWir können die `group_by` Funktion auch mit anderen Funktionen, die wir bereits kennengelernt haben, verwenden. So können wir zum Beispiel pro Gruppe die Beobachtung mit dem grössten Verkaufsvolumen herausfiltern:\n```{r}\nbudget4 %>% \n  group_by(year, product) %>% \n  filter(sales == max(sales))\n```\n\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"wrap","code-link":true,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"html-table-processing":"none"},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["panelize","webr"],"css":["include/psyteachr.css","include/webex.css","include/style.css"],"highlight-style":"a11y","include-after-body":["include/webex.js","include/script.js"],"output-file":"06-wrangling.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.555","bibliography":["include/book.bib","include/packages.bib"],"csl":"include/apa.csl","webr":{"packages":["tidyverse"]},"theme":{"light":["flatly","include/light.scss"],"dark":["darkly","include/dark.scss"]},"code-copy":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}