[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in die Datenanalyse mit R",
    "section": "",
    "text": "Übersicht\nBei diesem Buch handelt es sich um eine Übersetzung/Adaption des Buches Applied Data Skills von Emily Nordmann and Lisa DeBruine. Das Buch bildet die Grundlate für die Veranstaltung “Einführung in die moderne Datenanalyse mit R und künstlicher Intelligenz”.\nDieses Buch bietet einen Überblick über die grundlegenden Fähigkeiten, die benötigt werden, um Daten zu Analyiseren und Visualisieren und diese Analysen in professionellen Berichten und Präsentationen darzustellen.\nNach Bearbeitung des in diesem Buch dargestellten Material sollten Sie in der Lage sein,",
    "crumbs": [
      "Übersicht"
    ]
  },
  {
    "objectID": "index.html#der-weg-zum-erfolg-im-umgang-mit-daten",
    "href": "index.html#der-weg-zum-erfolg-im-umgang-mit-daten",
    "title": "Einführung in die Datenanalyse mit R",
    "section": "Der Weg zum Erfolg im Umgang mit Daten",
    "text": "Der Weg zum Erfolg im Umgang mit Daten\n\n\n\nDas Erlernen von Datenanalyse Fähigkeiten ist wie eine Fitnessstudio-Mitgliedschaft - Sie erhalten modernste Ausrüstung und Anweisungen zur Benutzung, aber Ihre Datenanalysefähigkeiten werden nicht stärker, es sei denn, Sie üben.\n\n\n\nBeim Erwerben von Datenanalysefähigkeiten geht es nicht darum, viel Code auswendig zu lernen, obwohl Sie Verlaufe des Semseters viele verschiedene Funktionen/Code kennenlernen werden. Viel wichtiger ist es beim Erlernen von Programmieren (mit R), dass man effizient benötigte Informationen finden kann. Dies erfordert die Gewöhnung an die Struktur von Hilfedateien und Spickzettel, das Erlernen, wie Sie Ihr Problem googeln und eine hilfreiche Lösung auswählen, sowie das Lesen von Fehlermeldungen.\n   \n\n\n\nDenn das Erlernen des Programmierens beinhaltet viele Fehler. Diese Fehler sind absolut wesentlich für den Prozess, also seien Sie nicht frustriert, wenn Sie häufig Fehler machen. Viele der Kapitelübungen werden Ihnen fehlerhaften Code geben, den Sie korrigieren sollen, damit Sie Erfahrung damit sammeln, wie häufige Fehler aussehen. Wenn Sie ein erfahrenerer werden, machen Sie vielleicht nicht weniger Fehler, aber Sie werden sie viel schneller beheben können.",
    "crumbs": [
      "Übersicht"
    ]
  },
  {
    "objectID": "02-test.html",
    "href": "02-test.html",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "",
    "text": "1.1 Lerziele",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#lerziele",
    "href": "02-test.html#lerziele",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "",
    "text": "Wissen, was R und RStudio ist\nUmfang und Möglichkeiten von R kennen",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#sec-intro",
    "href": "02-test.html#sec-intro",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.2 Wieso R?",
    "text": "1.2 Wieso R?\nR ist eine Programmiersprache, die speziell für statistische Datenanalyse und grafische Darstellungen entwickelt wurde. Sie eignet sich hervorragend für eine Vielzahl von Anwendungen, von einfachen Berechnungen bis hin zu komplexen machine learning Verfahren.\nEin grosser Vorteil von R ist, dass es sich um eine ‘open-source’ und frei verfügbare Software handelt. Dies ist unterscheidet R von anderen für die statistische Datenanalyse entwickelter Software wie zum Beispiel SPSS und STATA.\nEin weiterer Pluspunkt von R ist die grosse und freundliche Community, die sich über die Jahre entwickelt hat. Diese Community entwickelt Pakete für R und bietet auf Plattformen wie Stackoverflow.com Hilfe bei Problemen mit R an. Wie wir im Verlauf der Vorlesung sehen werden, ist diese Community und Hilfe Foren wie stackoverflow ein wichtiger Grund, wieso künstliche Intelligenz wie ChatGPT besser in R als zum Beispiel in SPSS programmieren kann.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#wieso-r-studio",
    "href": "02-test.html#wieso-r-studio",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.3 Wieso R Studio?",
    "text": "1.3 Wieso R Studio?\nNachdem man R installiert hat (werden wir gleich tun) könnte man, wie im Screenshot unten dargestellt, direkt in einem Terminal losprogrammieren.\n\n\n\n\n\n\n\n\nUm das Programmieren angenehmer zu machen, werden aber sogenannte ‘integrated development environment (IDE)’ verwendet. RStudio (siehe Bild unten) ist eine solche ‘IDE’ und vereinfacht das Arbeiten mit R enorm. Rstudio ist in vier Felder aufgeteilt, die das Arbeiten mit R übersichtlicher machen. Oben links befindet sich das sogenannte “Source” fenster. Das ist nichts anderes, als ein Text Editor. Also ähnlich wie Word, aber optimiert zum Programmieren. Das erkennt man unter anderem daran, dass der Text unterschiedlich eingefärbt ist. Das erleichtert das lesen von Code. Im “Source” Fenster öffnet oder schreibt man sogenannte “Skripte”. Das sind Textdateien, die von oben nach unten von R ausgeführt werden. Diese Skripte werden normalerweise im R-Format gespeichert (an der “.R” Dateierweiterung zu erknnen). Dies sorgt dafür, das solche Skripte automatisch von RStudio geöffnet werden, wenn man sie anklickt.\n\n\n\n\n\n\n\n\nDer Code (Text) im Skript wird dann in die “Konsole” (“Console”), das Fenster unten links, “geschickt”. Wie im Video unten gezeigt, kann man dies mit dem “Run” Button tun oder besser, indem man Ctr + Enter oder Cmd + Enter drückt. Dann wird der Code von R interpretiert (ausgeführt). Je nach ausgeführtem Code sieht man dann einen output in der Konsole (unten links) oder im Fenster unten rechts, falls der ausgeführte Text eine Grafik (plot) produziert. Es kann auch sein, dass man keinen Output sieht, wenn man ein sogenanntes “Objekt” generiert. Dies geschieht mit dem Zuweisungspfeil &lt;-. Dieses Objekt sieht man dann oben rechts im “Environnment” Fenster. Mehr dazu später, jetzt installieren wir erstmal R und RStudio!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#r-und-rstudio-installieren",
    "href": "02-test.html#r-und-rstudio-installieren",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.4 R und RStudio installieren",
    "text": "1.4 R und RStudio installieren\n\n1.4.1 Für Mac\nR kann unter diesem Link heruntergeladen werden. Achte darauf, dass du die richtige Version (Mac, Windows, oder Linux installierst). Falls du einen Mac hast, musst du noch zwischen der “For Apple silicon” und der “For older Intel Macs” Option wählen. Falls du einen Mac mit “M” Chip hast, wählst du “Apple silicon” (rot umrandet), sonst “Intel” (blau umrandet). Falls du nicht weisst, welcher Chip in deinem Mac verbaut ist, kannst du auf das Apple Logo links oben klicken und dann auf “Über diesen Mac”. Wenn dann unter Chip “Apple M…” gelistet ist, installierst du die “Apple silicon” Variante, sonst die “Intel” Variante.\n\n\n\n\n\n\n\n\n\n1.4.2 Für Windows\nR kann unter diesem Link heruntergeladen werden. Klicke auf den “base” Link, um R herunterzuladen.\n\n\n\n\n\n\n\n\n\n1.4.3 RStudio\nNun können wir RStudio mit diesem Link herunterladen und installieren. Achte wieder darauf, dass du die richtige Version auswählst.\nNachdem wir RStduio zum ersten mal öffnen, müssen wir kurz etwas in den Einstellungen ändern. Auf einem Mac gehts du dafür auf Tools -&gt; Global Options, in Windows geht das über das ‘Preferences’ Menü. Im obersten Tab (‘General’) musst du unter dem Header ‘Workspace’ das Häckchen bei der Option “Restore .RData into workspace at startup” entfernen und aus dem Dropdown Menü darunter die Option “Never” auswählen.\n\n\n\n\n\n\n\n\nDas sorgt dafür, dass nichts in der Konsole gespeichert bleibt, wenn wir RStudio schliessen. Dies ist wichtig für die Reproduzierbarkeit unserer Analysen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#rstudio-projekte",
    "href": "02-test.html#rstudio-projekte",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.5 RStudio Projekte",
    "text": "1.5 RStudio Projekte\nEin weiterer Vorteil von RStudio sind sogenannte “Projekte”. Projekte können direkt in RStudio erstellt werden. Ein Projekt ist nichts anderes als ein Ordner, der alle für ein Datenanalyse Projekt notwendigen Dateien enthält. Wie wir später sehen werden, vereinfacht das die Organisation (z.B. das Laden von Datensätzen) sehr. Deshalb erstellen wir als erstes, nachdem wir RStudio geöffnet haben, ein solches Projekt. Das unten abgebildete GIF zeigt dir, wie das geht. Du kannst das Projekt nennen, wie du möchtest. Speichere das Projekt in einem Ordner, den du einfach wieder findest (z.B. in dem Ordner, in dem du auch die Vorlesungsfolien speicherst).\n\n\n\n\n\n\n\n\nNachdem du das Projekt erstellt hast wird es automatisch in RStduio geöffnet. Schliesse nun RStudio und öffne den Ordner, der durch das erstellen des Projektes erstellt wurde. In diesem Ordner sollte sich nur eine .Rproj Datei befinden, die so heisst, wie dein eben erstelltes Projekt. Durch Doppelklick auf diese Datei öffnet sich RStudio mit deinem Projekt.\nWie gesagt vereinfachen Projekte vor allem die Organisation von Datenanalyseprojekten. Dafür erstellen wir nun eine Ordner Struktur, mit der wir im Verlauf des Semesters arbeiten werden. Die Ordnerstruktur ist unten abgebildet. Zuerst erstellen wir einen Ordner namens “Data”. In diesem Ordner werden wir die Rohdaten abspeichern, die wir analysieren werden. Als nächstes erstellen wir den “Script” Ordner. In diesem Ordner werden wir unsere Analyseskripte speichern. Als letztes erstellen wir noch den “Output” Ordner. Dort speichern wir outputs wie plots und gereinigte Datensätze. Generiere dafür jeweils noch die zwei Unterordner “Plots” und “Data”.\n\n\n\n\n\n\n\n\n\n\n\nFalls alles funktioniert hat, blickst du jetzt stolz und zufrieden auf eine Ordnerstruktur, die die Grundlage für die Übungen der folgenden Wochen bildet.\n\n\n\nUnd keine Angst, falls etwas nicht wie beschrieben funktioniert hat. Das wird immer wieder vorkommen und passiert auch erfahrenen ProgramiererInnen häufig.\nVersuche es erneut, falls etwas nicht geklappt hat. Frage deine KommilitonInnen, Google, ChatGPT, oder mich um Hilfe. Wenn es nach einigem trial-and-error dann endlich funktioniert, ist die Freude oft umso grösser. GPT-4 hat das ganz gut getroffen:\n\n\n\n\n\n\n\n\nDas Lachen der von GPT-4 generierten Katze hat eine leichte “Crazyness” an sich. Um das zu vermeiden, sollte man bei Sessions mit viel trial-and-error regelmässig Pausen einlegen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#sec-packages",
    "href": "02-test.html#sec-packages",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.6 Pakete und Funktionen",
    "text": "1.6 Pakete und Funktionen\nWenn du R installierst, hast du Zugriff auf eine Reihe von Funktionen, einschließlich Optionen für data wrangling und statistische Analysen. Die Funktionen, die in der Standardinstallation enthalten sind, werden typischerweise als base R bezeichnet, und du kannst sie dir wie die Standard-Apps vorstellen, die auf deinem Handy vorinstalliert sind.\nEines der besten Features an R ist jedoch, dass es benutzererweiterbar ist: Jeder kann eine neue Erweiterung erstellen, die die Funktionalität von R erweitert. Es gibt derzeit Tausende von Paketen, die R-BenutzerInnen erstellt haben, um viele verschiedene Arten von Problemen zu lösen. Es gibt zum Beispiel Pakete für Datenvisualisierung, maschinelles Lernen, interaktive Dashboards, Web Scraping und zum Spielen von Spielen wie Sudoku.\nZusatzpakete sind bei der Installation von R noch nicht enthalten, sondern müssen von einem Archiv heruntergeladen und installiert werden, ähnlich wie du zum Beispiel PokemonGo auf dein Smartphone herunterladen und installieren würdest. Das Hauptrepository, in dem sich die Pakete befinden, heißt CRAN, das Comprehensive R Archive Network.\nEs gibt einen wichtigen Unterschied zwischen dem Installieren eines Pakets und dem Laden eines Pakets.\n\n1.6.1 Installieren eines Pakets\nDies geschieht mit install.packages(). Es ist wie das Installieren einer App auf deinem Handy: Du musst es nur einmal machen, und die App bleibt installiert, bis du sie entfernst. Wenn du zum Beispiel PokemonGo auf deinem Handy nutzen möchtest, installierst du es einmal aus dem App Store oder Play Store; du musst es nicht jedes Mal neu installieren, wenn du es benutzen möchtest. Sobald du die App startest, läuft sie im Hintergrund, bis du sie schließt oder dein Handy neu startest. Ebenso wird das Paket, wenn du es installierst, bei jedem Öffnen von R verfügbar sein (aber nicht geladen).\nInstalliere das tidyverse-Paket auf deinem Computer. Dies ist das wichtigste Paket, das wir in diesem Buch für Datenaufbereitung, Zusammenfassungen und Visualisierung verwenden werden. Es ist eigentlich ein Bündel von Paketen, was wir in Section 1.6.4 näher erklären werden.\n\n\n\nIn der Konsole ausführen\n\ninstall.packages(\"tidyverse\")\n\n\nWenn du eine Meldung erhältst, die in etwa besagt package 'tidyverse' successfully unpacked and MD5 sums checked, war die Installation erfolgreich. Wenn du einen Fehler erhältst und das Paket nicht installiert wurde, überprüfe den Abschnitt zur Fehlerbehebung in ?sec-package-install-troubleshooting.\n\n\n\n\n\n\nInstalliere Pakete nur über die Konsole\n\n\n\nInstalliere niemals ein Paket innerhalb eines Skripts. Tue dies nur über die Konsolenansicht oder die Paketansicht im unteren rechten Fenster.\n\n\nHier sind einige andere Pakete, die du für die ersten beiden Kapitel installieren solltest.\n\n\n\nIn der Konsole ausführen\n\ninstall.packages(\"beepr\") # für Pieptöne\ninstall.packages(\"rmarkdown\") # zum Erstellen von R Markdown-Dateien\ninstall.packages(\"devtools\")  # zum Installieren von Paketen von GitHub\n\n\nSobald du das devtools-Paket installiert hast, kannst du auch Pakete von anderen Repositories als CRAN installieren, wie zum Beispiel GitHub. Der folgende Code installiert die Entwicklungsversion eines Pakets zum Erstellen von Waffle-Plots.\n\n\n\nIn der Konsole ausführen\n\n# Installiere das waffle-Paket \ndevtools::install_github(\"hrbrmstr/waffle\")\n\n\n\n1.6.2 Laden eines Pakets\nDies geschieht mit der Funktion library(). Es ist wie das Starten einer App auf deinem Handy: Die Funktionalität ist nur da, wenn die App gestartet ist und bleibt dort, bis du die App schließt oder neu startest. Wenn du zum Beispiel library(devtools) innerhalb einer Sitzung ausführst, werden die Funktionen in dem Paket, auf das sich devtools bezieht, für deine R-Sitzung verfügbar gemacht. Beim nächsten Start von R musst du library(devtools) erneut ausführen, wenn du auf dieses Paket zugreifen möchtest.\nNachdem du das beepr-Paket installiert hast, kannst du es für deine aktuelle R-Sitzung wie folgt laden:\n\n\n\nIn der Konsole ausführen\n\nlibrary(beepr)\n\n\nDu könntest beim Laden eines Pakets etwas roten Text sehen, das ist normal. Es warnt dich normalerweise davor, dass dieses Paket Funktionen hat, die den gleichen Namen haben wie andere Pakete, die du bereits geladen hast.\n\n\n\n\n\n\nNote\n\n\n\nDu kannst die Konvention paket::funktion() verwenden, um anzuzeigen, in welchem Zusatzpaket sich eine Funktion befindet. Wenn du zum Beispiel readr::read_csv() siehst, bezieht sich das auf die Funktion read_csv() im Zusatzpaket {readr}. Wenn das Paket mit library() geladen ist, musst du den Paketnamen vor einer Funktion nicht angeben, es sei denn, es gibt einen conflict (z.B. wenn du zwei Pakete geladen hast, die eine Funktion mit dem gleichen Namen haben).\n\n\n\n1.6.3 Verwendung einer Funktion\nJetzt kannst du die Funktion beep() ausführen.\n\n\n\nIn der Konsole ausführen\n\nbeep()\n\n\nEine function ist ein Name, der sich auf Code bezieht, den du wiederverwenden kannst. Wir beginnen mit der Verwendung von Funktionen, die dir in Paketen zur Verfügung gestellt werden, aber du kannst auch deine eigenen Funktionen schreiben. Nach dem Funktionsnamen steht ein Paar Klammern, die null oder mehr Argumente enthalten. Dies sind Optionen, die du einstellen kannst. Im obigen Beispiel hat das Argument sound einen default value von 1, was einen “Ping”-Ton erzeugt. Versuche, das Argument in eine ganze Zahl zwischen 1 und 11 zu ändern.\n\n\n\nIn der Konsole ausführen\n\nbeep(sound = 8)\n\n\nWenn du eine Funktion in die Konsolenansicht eingibst, wird sie ausgeführt, sobald du Enter drückst. Wenn du die Funktion in ein script oder R Markdown-Dokument in der Quellenansicht einfügst, wird sie erst ausgeführt, wenn du das Skript ausführst, die R Markdown-Datei knittest oder einen Code-chunk ausführst. Du wirst mehr darüber in Chapter 2 lernen.\n\n1.6.4 Tidyverse\ntidyverse ist ein Meta-Paket, das mehrere Pakete lädt, die wir in fast jedem Kapitel dieses Buches verwenden werden:\n\n\nggplot2, für Datenvisualisierung (Chapter 8)\n\nreadr, für Datenimport (Chapter 4)\n\ntibble, für Tabellen (Chapter 4)\n\ntidyr, für Datenbereinigung (Chapter 6)\n\ndplyr, für Datenmanipulation (Chapter 6)\n\nstringr, für Zeichenketten\n\n\nforcats, für Faktoren\n\n\npurrr, für Wiederholungen\n\nWenn du tidyverse installierst, werden auch einige andere nützliche Pakete installiert, die du einzeln laden kannst. Du kannst die vollständige Liste mit tidyverse_packages() erhalten, aber die Pakete, die wir in diesem Buch verwenden werden, sind:\n\n\ngooglesheets4, für die Arbeit mit Google-Tabellen\n\nreadxl, für Excel-Dateien\n\nlubridate, für die Arbeit mit Datumsangaben\n\nhms, für die Arbeit mit Uhrzeiten\n\nrvest, für Web Scraping\n\n1.6.5 Funktionshilfe\nWenn du das tidyverse lädst, werden automatisch alle oben genannten Pakete geladen. Es kann jedoch hilfreich sein zu wissen, aus welchem Paket eine Funktion stammt, wenn du sie googeln musst. Wenn eine function in base R oder einem geladenen Paket ist, kannst du ?funktionsname in der Konsole eingeben, um auf die Hilfedatei zuzugreifen. Oben in der Hilfe wird der Funktions- und Paketname angegeben.\nWenn das Paket nicht geladen ist, verwende ?paketname::funktionsname oder gib das Paket in der Funktion help() an. Wenn du nicht sicher bist, in welchem Paket sich die Funktion befindet, verwende die Abkürzung ??funktionsname.\n\n\n\nIn der Konsole ausführen\n\n# wenn das Paket geladen ist\n?beepr\nhelp(\"beepr\")\n\n# funktioniert unabhängig davon, ob das Paket geladen ist oder nicht\n?beepr::beep\nhelp(\"beep\", package=\"beepr\") \n\n# zeigt eine Liste potenziell passender Funktionen\n??beep\n\n\n\n\n\nFunktionshilfe ist immer gleich organisiert. Schaue dir zum Beispiel die Hilfe für ?beepr::beep an. Oben steht der Name der Funktion und ihr Paket in geschweiften Klammern, gefolgt von einer kurzen Beschreibung der Funktion und einer längeren Beschreibung. Der Abschnitt Usage zeigt die Funktion mit allen ihren Argumenten. Wenn eines dieser Argumente Standardwerte hat, werden sie wie funktion(arg = standard) angezeigt. Der Abschnitt Arguments listet jedes Argument mit einer Erklärung auf. Es kann danach einen Abschnitt Details mit noch mehr Details über die Funktionen geben. Der Abschnitt Examples ist der letzte und zeigt Beispiele, die du in deinem Konsolenfenster ausführen kannst, um zu sehen, wie die Funktion funktioniert.\n\n\n\n\n\n\nFunktionshilfe\n\n\n\n\nWas ist das erste Argument der Funktion mean? \ntrim\nna.rm\nmean\nx\n\nIn welchem Paket ist read_excel? \nreadr\nreadxl\nbase\nstats\n\n\n\n\n\n1.6.6 Argumente\nDu kannst die Argumente/Optionen, die eine Funktion hat, in der Hilfedokumentation nachschlagen. Einige Argumente sind erforderlich, andere optional. Optionale Argumente verwenden oft einen Standardwert (normalerweise in der Hilfedokumentation angegeben), wenn du keinen Wert eingibst.\nSchaue dir als Beispiel die Hilfedokumentation für die Funktion sample() an, die zufällig Elemente aus einer Liste auswählt.\n\n\n\nIn der Konsole ausführen\n\n?sample\n\n\nDie Hilfedokumentation für sample() sollte im unteren rechten Hilfefenster erscheinen. Im Abschnitt “Usage” sehen wir, dass sample() die folgende Form hat:\n\nsample(x, size, replace = FALSE, prob = NULL)\n\nIm Abschnitt “Arguments” gibt es Erklärungen für jedes der Argumente. x ist die Liste der Elemente, aus denen wir auswählen wollen, size ist die Anzahl der Elemente, die wir auswählen wollen, replace gibt an, ob jedes Element mehr als einmal ausgewählt werden kann oder nicht, und prob gibt die Wahrscheinlichkeit an, mit der jedes Element ausgewählt wird. Im Abschnitt “Details” wird angemerkt, dass wenn keine Werte für replace oder prob eingegeben werden, Standardwerte von FALSE (jedes Element kann nur einmal ausgewählt werden) und NULL (alle Elemente haben die gleiche Wahrscheinlichkeit, ausgewählt zu werden) verwendet werden. Da es keine Standardwerte für x oder size gibt, müssen diese angegeben werden, sonst wird der Code nicht ausgeführt.\nLass uns ein Beispiel versuchen und nur die erforderlichen Argumente x und size ändern, um R zu bitten, 5 zufällige Buchstaben auszuwählen (letters ist ein eingebauter vector der 26 lateinischen Kleinbuchstaben).\n\nsample(x = letters, size = 5)\n\n[1] \"z\" \"v\" \"y\" \"w\" \"j\"\n\n\n\n\n\n\n\n\nWarum sind meine Buchstaben anders als deine Buchstaben?\n\n\n\n\n\nsample() erzeugt eine zufällige Stichprobe. Jedes Mal, wenn du den Code ausführst, erzeugst du eine andere Menge von zufälligen Buchstaben (probiere es aus). Die Funktion set.seed() steuert den Zufallszahlengenerator - wenn du Funktionen verwendest, die Zufälligkeit nutzen (wie sample()), stellt die Ausführung von set.seed() sicher, dass du das gleiche Ergebnis erhältst (in vielen Fällen ist das vielleicht nicht das, was du möchtest). Um die gleichen Zahlen wie wir zu erhalten, führe set.seed(1242016) in der Konsole aus und dann führe sample(x = letters, size = 5) erneut aus.\n\n\n\nJetzt können wir den Standardwert für das replace-Argument ändern, um eine Menge von Buchstaben zu erzeugen, die Duplikate enthalten darf.\n\nset.seed(8675309)\nsample(x = letters, size = 5, replace = TRUE)\n\n[1] \"t\" \"k\" \"j\" \"k\" \"m\"\n\n\nDiesmal hat R immer noch 5 zufällige Buchstaben erzeugt, aber jetzt enthält diese Menge von Buchstaben zwei Instanzen von “k”. Denke immer daran, die Hilfedokumentation zu verwenden, um zu verstehen, welche Argumente eine Funktion benötigt.\n\n1.6.7 Argumentnamen\nIn den obigen Beispielen haben wir die Argumentnamen in unserem Code ausgeschrieben (d.h. x, size, replace), dies ist jedoch nicht unbedingt notwendig. Die folgenden zwei Codezeilen würden beide das gleiche Ergebnis produzieren (obwohl jedes Mal, wenn du sample() ausführst, es ein leicht anderes Ergebnis produzieren wird, weil es zufällig ist, aber sie würden trotzdem gleich funktionieren):\n\nsample(x = letters, size = 5, replace = TRUE)\nsample(letters, 5, TRUE)\n\nWichtig ist, dass R die Standardreihenfolge der Argumente verwendet, wenn du die Argumentnamen nicht ausschreibst. Das heißt, für sample wird angenommen, dass der erste Wert, den du eingibst, x ist, der zweite Wert ist size und der dritte Wert ist replace.\nWenn du die Argumentnamen ausschreibst, kannst du die Argumente in beliebiger Reihenfolge schreiben:\n\nsample(size = 5, replace = TRUE, x = letters)\n\nWenn du gerade erst anfängst R zu lernen, kann es nützlich sein, die Argumentnamen auszuschreiben, da es dir helfen kann, dich zu erinnern und zu verstehen, was jeder Teil der Funktion tut. Mit zunehmenden Fähigkeiten findest du es vielleicht schneller, die Argumentnamen wegzulassen, und du wirst auch Codebeispiele online sehen, die keine Argumentnamen verwenden. Daher ist es wichtig, verstehen zu können, auf welches Argument sich jeder Teil des Codes bezieht (oder in der Hilfedokumentation nachzuschauen).\nIn diesem Kurs werden wir die Argumentnamen immer beim ersten Mal ausschreiben, wenn wir jede Funktion verwenden. Bei späteren Verwendungen können sie jedoch weggelassen werden.\n\n1.6.8 Tab-Autovervollständigung\nEine sehr nützliche Funktion von R Studio ist die Tab-Autovervollständigung für Funktionen. Wenn du den Namen der Funktion schreibst und dann die Tab-Taste drückst, zeigt R Studio dir die Argumente, die die Funktion annimmt, zusammen mit einer kurzen Beschreibung. Wenn du Enter auf dem Argumentnamen drückst, wird der Name für dich ausgefüllt, genau wie die Autovervollständigung auf deinem Handy. Das ist unglaublich nützlich, wenn du gerade erst R lernst, und du solltest daran denken, diese Funktion häufig zu nutzen.\n\n\n\n\n\n\n\nFigure 1.1: Tab-Autovervollständigung",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#sec-objects",
    "href": "02-test.html#sec-objects",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.7 Objekte",
    "text": "1.7 Objekte\nEin großer Teil deines Codings wird die Erstellung und Manipulation von Objekten beinhalten. Objekte enthalten Dinge. Diese Dinge können Zahlen, Wörter oder das Ergebnis von Operationen und Analysen sein. Du weist einem Objekt Inhalte zu, indem du &lt;- verwendest.\nFühre den folgenden Code in der Konsole aus, aber ändere die Werte von name und age zu deinen eigenen Details und ändere christmas zu einem Feiertag oder Datum, das dir wichtig ist.\n\n\n\nIn der Konsole ausführen\n\nname &lt;- \"Emily\"\nage &lt;- 36\ntoday &lt;- Sys.Date()\nchristmas &lt;- as.Date(\"2024-12-25\")\n\n\nDu wirst sehen, dass vier Objekte jetzt im Umgebungsfenster erscheinen:\n\n\nname ist character (Text) Daten. Damit R es als Text erkennt, muss es in doppelte Anführungszeichen \" \" eingeschlossen sein.\n\nage ist numeric Daten. Damit R dies als Zahl erkennt, darf es nicht in Anführungszeichen eingeschlossen sein.\n\ntoday speichert das Ergebnis der Funktion Sys.Date(). Diese Funktion gibt das Datum deines Computersystems zurück. Im Gegensatz zu name und age, die fest codiert sind (d.h. sie werden immer die Werte zurückgeben, die du eingibst), ändern sich die Inhalte des Objekts today dynamisch mit dem Datum. Das heißt, wenn du diese Funktion morgen ausführst, wird sie das Datum auf das morgige Datum aktualisieren.\n\nchristmas ist auch ein Datum, aber es ist als spezifisches Datum fest codiert. Es ist in die Funktion as.Date() eingewickelt, die R anweist, die von dir bereitgestellte Zeichenkette als Datum und nicht als Text zu interpretieren.\n\n\n\n\n\n\n\nNote\n\n\n\nUm den Inhalt eines Objekts auszugeben, gib den Namen des Objekts in die Konsole ein und drücke Enter. Versuche jetzt, alle vier Objekte auszugeben.\n\n\nSchließlich ist ein wichtiges Konzept zu verstehen, dass Objekte interagieren können und du die Ergebnisse dieser Interaktionen in neuen Objekten speichern kannst. Bearbeite und führe den folgenden Code aus, um diese neuen Objekte zu erstellen, und gib dann den Inhalt jedes neuen Objekts aus.\n\n\n\nIn der Konsole ausführen\n\ndecade &lt;- age + 10\nfull_name &lt;- paste(name, \"Nordmann\")\nhow_long &lt;- christmas - today",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#sec-help",
    "href": "02-test.html#sec-help",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.8 Hilfe bekommen",
    "text": "1.8 Hilfe bekommen\nDu wirst das Gefühl haben, dass du viel Hilfe brauchst, wenn du anfängst zu lernen. Das wird nicht wirklich weggehen; es ist unmöglich, sich alles zu merken. Das Ziel ist, genug über die Struktur von R zu lernen, dass du Dinge schnell nachschlagen kannst. Deshalb werden wir spezialisiertes Fachjargon im Glossar für jedes Kapitel einführen; es ist einfacher, “convert character to numeric in R” zu googeln als “make numbers in quotes be actual numbers not words”. Zusätzlich zur oben beschriebenen Funktionshilfe gibt es hier einige zusätzliche Ressourcen, die du oft nutzen solltest.\n\n1.8.1 Paket-Referenzhandbücher\nStarte die Hilfe in einem Browser, indem du help.start() in die Konsole eingibst. Klicke auf Packages unter Reference, um eine Liste der Pakete zu sehen. Scrolle zum Paket readxl und klicke darauf, um eine Liste der Funktionen zu sehen, die in diesem Paket verfügbar sind.\n\n1.8.2 Googeln\nWenn die Funktionshilfe nicht hilft oder du dir nicht sicher bist, welche Funktion du brauchst, versuche, deine Frage zu googeln. Es wird etwas Übung brauchen, um die richtigen Fachbegriffe in deinen Suchbegriffen zu verwenden, um das zu bekommen, was du willst. Es hilft, “R” oder “tidyverse” in den Suchtext zu setzen, oder den Namen des relevanten Pakets, wie “ggplot2”.\n\n1.8.3 KI\n\n\n\nGenerative KI-Plattformen haben eine explosionsartige Popularität erlebt, insbesondere wenn es ums Programmieren geht. Aus diesem Grund werden wir KI aktiv nutzen. Ich habe dafür ein CustomGPT erstellt, das Dir beim Lernen von R helfen soll.\n\n1.8.4 Vignetten\nViele Pakete, besonders tidyverse Pakete, haben hilfreiche Websites mit Vignetten, die erklären, wie man ihre Funktionen verwendet. Einige der Vignetten sind auch innerhalb von R verfügbar. Du kannst auf sie von der Hilfeseite eines Pakets zugreifen oder mit der Funktion vignette().\n\n\n\nIn der Konsole ausführen\n\n# öffnet eine Liste verfügbarer Vignetten\nvignette(package = \"ggplot2\")\n\n# öffnet eine spezifische Vignette im Hilfefenster\nvignette(\"ggplot2-specs\", package = \"ggplot2\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02-test.html#sec-glossary-intro",
    "href": "02-test.html#sec-glossary-intro",
    "title": "\n1  Einführung in R und RStudio\n",
    "section": "\n1.9 Glossar",
    "text": "1.9 Glossar\nDas Glossar am Ende jedes Kapitels definiert gängige Fachbegriffe, denen du beim Erlernen von R begegnen könntest. Dieser spezialisierte Wortschatz kann dir helfen, effizienter zu kommunizieren und nach Lösungen für Probleme zu suchen. Die unten stehenden Begriffe verlinken zum PsyTeachR-Glossar, das weitere Informationen und Beispiele enthält.\n\n\n\n\nterm\ndefinition\n\n\n\nargument\nA variable that provides input to a function.\n\n\nbase-r\nThe set of R functions that come with a basic installation of R, before you add external packages.\n\n\ncharacter\nA data type representing strings of text.\n\n\nchunk\nA section of code in an R Markdown file\n\n\nconflict\nHaving two packages loaded that have a function with the same name.\n\n\ncran\nThe Comprehensive R Archive Network: a network of ftp and web servers around the world that store identical, up-to-date, versions of code and documentation for R.\n\n\ndata-wrangling\nThe process of preparing data for visualisation and statistical analysis.\n\n\ndefault-value\nA value that a function uses for an argument if it is skipped.\n\n\nfactor\nA data type where a specific set of values are stored with labels; An explanatory variable manipulated by the experimenter\n\n\nfunction\nA named section of code that can be reused.\n\n\nknit\nTo create an HTML, PDF, or Word document from an R Markdown (Rmd) document\n\n\nnumeric\nA data type representing a real decimal number or integer.\n\n\npackage\nA group of R functions.\n\n\npanes\nRStudio is arranged with four window “panes”.\n\n\nr-markdown\nThe R-specific version of markdown: a way to specify formatting, such as headers, paragraphs, lists, bolding, and links, as well as code blocks and inline code.\n\n\nscript\nA plain-text file that contains commands in a coding language, such as R.\n\n\nstring\nA piece of text inside of quotes.\n\n\nvector\nA type of data structure that collects values with the same data type, like T/F values, numbers, or strings.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung in R und RStudio</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html",
    "href": "02.1-markdown.html",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "",
    "text": "Lernziele",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#sec-ilo-reports",
    "href": "02.1-markdown.html#sec-ilo-reports",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "",
    "text": "Ein Projekt strukturieren können\nEinen einfachen reproduzierbaren Bericht mit R Markdown erstellen können\nCodeblöcke, Tabellen, Bilder und inline R code in einem R Markdown-Dokument erstellen können",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#functions-reports",
    "href": "02.1-markdown.html#functions-reports",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.1 Verwendete Funktionen",
    "text": "2.1 Verwendete Funktionen\n\nEingebaute Funktionen (diese können immer ohne das Laden von Paketen verwendet werden)\n\nbase:: max(), min(), nrow(), str(), summary()\n\nutils:: View()\n\n\n\ntidyverse (alle diese können mit library(tidyverse) verwendet werden)\n\nreadr:: read_csv(), row_spec()\n\ndplyr:: count(), filter()\n\nggplot2:: geom_bar(), geom_col(), ggplot(), labs()\n\n\n\nAndere (Sie müssen jedes Paket laden, um diese zu verwenden)\n\nknitr:: include_graphics(), kable()\n\nkableExtra:: kable_classic(), row_spec()\n\ntinytex:: install_tinytex()\n\n\n\n\nLade den R Markdown Spickzettel herunter.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#sec-setup-reports",
    "href": "02.1-markdown.html#sec-setup-reports",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.2 Einrichtung",
    "text": "2.2 Einrichtung\nHier sind die Pakete, die wir in diesem Kapitel verwenden werden. Sie müssen sie möglicherweise installieren, wie in Section 1.6.1 erklärt, wenn das Ausführen des untenstehenden Codes im Konsolenbereich den Fehler Error in library(package_name) : there is no package called ‘packagename’ erzeugt.\n\n\n\nChapter packages\n\nlibrary(tidyverse)  # verschiedene Datenmanipulationsfunktionen\nlibrary(knitr)      # für das Rendern eines Berichts aus einem Skript\nlibrary(rmarkdown)  # für die Verwendung von R Markdown\nlibrary(kableExtra) # für das Stylen von Tabellen",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#sec-projects",
    "href": "02.1-markdown.html#sec-projects",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.3 Ein Projekt organisieren",
    "text": "2.3 Ein Projekt organisieren\nBevor wir irgendeinen Code schreiben, müssen wir uns zuerst organisieren. Projects in RStudio sind eine Möglichkeit, alle Dateien, die Sie für ein Projekt benötigen, zu gruppieren. Die meisten Projekte beinhalten scripts, Datendateien und Ausgabedateien wie den von dem Skript erstellten PDF-Bericht oder Bilder.\n\n2.3.1 Standardarbeitsverzeichnis\nZuerst erstellen Sie ein neues directory (d. h. einen Ordner) auf Ihrem Computer, in dem Sie alle Ihre R-Projekte aufbewahren. Nennen Sie es etwas wie “R-Projekte” (vermeiden Sie Leerzeichen und andere Sonderzeichen). Stellen Sie sicher, dass Sie wissen, wie Sie dieses Verzeichnis mit dem Finder oder Explorer Ihres Computers erreichen können.\n\n\n\n\n\n\nVermeiden Sie Netzwerklaufwerke\n\n\n\nWenn möglich, verwenden Sie kein Netzwerk- oder Cloud-Laufwerk (z. B. OneDrive oder Dropbox), da dies manchmal Probleme verursachen kann. Wenn Sie von einem Netzwerklaufwerk aus arbeiten und Probleme haben, ist ein hilfreicher Test, Ihren Projektordner auf den Desktop zu verschieben, um zu sehen, ob das das Problem löst.\n\n\nAls nächstes öffnen Sie Tools &gt; Global Options…, navigieren Sie zum General Bereich und setzen Sie das “Standardarbeitsverzeichnis (wenn nicht in einem Projekt)” auf dieses Verzeichnis. Wenn Sie nicht in einem Projekt arbeiten, werden alle Dateien oder Bilder, die Sie erstellen, in diesem working directory gespeichert.\n\n\n\n\n\n\nVermeiden Sie lange Pfadnamen\n\n\n\nIn einigen Versionen von Windows 10 und 11 können lange Pfadnamen, die länger als 260 Zeichen sind, Probleme verursachen. Setzen Sie Ihr Standardarbeitsverzeichnis auf einen Pfad, dessen Länge deutlich darunter liegt, um Probleme zu vermeiden, wenn R temporäre Dateien beim Rendern eines Berichts erstellt. Wenn Sie Probleme haben, ist ein hilfreicher Test, Ihren Projektordner auf den Desktop zu verschieben, da dies wahrscheinlich einen viel kürzeren Pfadnamen hat als die meisten anderen Ordner auf Ihrem Computer.\n\n\nSie können das Arbeitsverzeichnis manuell auf einen anderen Ort setzen mit Menübefehlen: Session &gt; Set Working Directory &gt; Choose Directory… Allerdings gibt es eine bessere Art, Ihre Dateien zu organisieren, indem Sie Projekte in RStudio verwenden.\n\n2.3.2 Ein Projekt starten\nBeginnen Sie, indem Sie ein Verzeichnis in Ihrem Standardprojektverzeichnis erstellen, in dem Sie alle Ihre Unterlagen für diesen Kurs aufbewahren; wir schlagen vor, es etwas wie ADS-23 zu nennen.\nUm ein neues Projekt für die Arbeit in diesem Kapitel zu erstellen:\n\nFile &gt; New Project…\nBenennen Sie das Projekt 02-reports\n\nSpeichern Sie es im ADS-23 Verzeichnis\n\nRStudio wird sich selbst neu starten und mit diesem neuen Projektverzeichnis als Arbeitsverzeichnis öffnen.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.1: Ein neues Projekt starten.\n\n\nKlicken Sie auf die Registerkarte Dateien im unteren rechten Bereich, um den Inhalt des Projektverzeichnisses zu sehen. Sie werden eine Datei mit dem Namen 02-reports.Rproj sehen, die eine Datei enthält, die alle Projektinformationen enthält. Wenn Sie im Finder/Explorer sind, können Sie darauf doppelklicken, um das Projekt zu öffnen.\n\n\n\n\n\n\nPunktdateien\n\n\n\nAbhängig von Ihren Einstellungen sehen Sie möglicherweise auch ein Verzeichnis namens .Rproj.user, das Ihre spezifischen Benutzereinstellungen enthält. Sie können dies und andere “unsichtbare” Dateien, die mit einem Punkt beginnen, ignorieren.\n\n\n\n\n\n\n\n\nVermeiden Sie verschachtelte Projekte\n\n\n\nSpeichern Sie niemals ein neues Projekt innerhalb eines anderen Projektverzeichnisses. Dies kann einige schwer zu lösende Probleme verursachen.\n\n\n\n2.3.3 Dinge benennen\nBevor wir neue Dateien erstellen, ist es wichtig, zu überprüfen, wie Sie Ihre Dateien benennen. Das mag etwas pedantisch erscheinen, aber klare Benennungsregeln zu befolgen, damit sowohl Menschen als auch Computer leicht Dinge finden können, wird Ihnen auf lange Sicht das Leben erleichtern. Hier sind einige wichtige Prinzipien:\n\nDatei- und Verzeichnisnamen sollten nur Buchstaben, Zahlen, Bindestriche und Unterstriche enthalten, mit einem Punkt (.) zwischen dem Dateinamen und extension (das bedeutet keine Leerzeichen!)\nKonsistente Groß-/Kleinschreibung (setzen Sie eine Regel fest, um es sich leicht zu merken, wie immer Kleinbuchstaben verwenden)\nVerwenden Sie Unterstriche (_) zur Trennung von Teilen des Dateinamens, wie Titel und Datum, und Bindestriche (-) zur Trennung von Wörtern in jedem Teil (z. B. social-media-report_2021-10.Rmd)\nBenennen Sie Dateien nach einem Muster, das in einer sinnvollen Reihenfolge alphabetisch sortiert wird und es Ihnen erleichtert, die Datei zu finden, die Sie suchen\nPräfixieren Sie einen Dateinamen mit einem\n\nUnterstrich, um ihn an den Anfang der Liste zu setzen, oder präfixieren Sie alle Dateien mit Zahlen, um ihre Reihenfolge zu steuern\nZum Beispiel sind diese Dateinamen ein Durcheinander:\n\nreport.doc\nreport final.doc\nData (Customers) 11-15.xls\nCustomers Data Nov 12.xls\nfinal report2.doc\nproject notes.txt\nVendor Data November 15.xls\n\nHier ist eine Möglichkeit, sie zu strukturieren, damit ähnliche Dateien dieselbe Struktur haben und es für einen Menschen einfach ist, die Liste zu scannen oder Code zu verwenden, um relevante Dateien zu finden. Sehen Sie, ob Sie herausfinden können, was das Letzte sein sollte.\n\n_project-notes.txt\nreport_v1.doc\nreport_v2.doc\nreport_v3.doc\ndata_customer_2021-11-12.xls\ndata_customer_2021-11-15.xls\n\nvendor-data_2021-11-15.xls\ndata-vendor-2021_11_15.xls\ndata_vendor_2021-11-15.xls\ndata_2021-11-15_vendor.xls\n\n\n\n\n\n\n\nBenennungsübung\n\n\n\nDenken Sie über andere Möglichkeiten nach, die oben genannten Dateien zu benennen. Sehen Sie sich einige Ihrer eigenen Projektdateien an und überlegen Sie, was Sie verbessern können.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#sec-rmarkdown",
    "href": "02.1-markdown.html#sec-rmarkdown",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.4 R Markdown",
    "text": "2.4 R Markdown\nWährend dieses Kurses verwenden wir R Markdown, um reproduzierbare Berichte mit einem Inhaltsverzeichnis, Text, Tabellen, Bildern und Code zu erstellen. Der Text kann mit markdown geschrieben werden, einer Methode zur Festlegung von Formatierungen wie Überschriften, Absätzen, Listen, Fettdruck und Links.\n\n2.4.1 Neues Dokument\nUm ein neues R Markdown-Dokument zu öffnen, klicken Sie File &gt; New File &gt; R Markdown. Sie werden aufgefordert, ihm einen Titel zu geben; benennen Sie es Wichtige Infos. Sie können auch den Autorennamen ändern. Behalten Sie das Ausgabeformat als HTML bei.\nNachdem Sie ein neues Dokument geöffnet haben, speichern Sie es, indem Sie auf File &gt; Save As… klicken. Sie sollten diese Datei important_info nennen (wenn Sie auf einem Mac sind und die Datei extension sehen können, nennen Sie sie important_info.Rmd). Diese Datei wird automatisch in Ihrem Projektordner (d. h. Ihrem Arbeitsverzeichnis) gespeichert, sodass Sie diese Datei nun in Ihrem Dateibetrachter sehen sollten.\nWenn Sie ein neues R Markdown-Dokument zum ersten Mal öffnen, sehen Sie einen Haufen Begrüßungstext, der so aussieht:\n\n\n\n\n\n\n\nFigure 2.2: Neuer R Markdown-Text\n\n\n\n\nFühren Sie die folgenden Schritte aus:\n\nÄndern Sie den Titel in “Wichtige Informationen” und den Autor in Ihren Namen\nLöschen Sie alles nach dem Setup-Block\nLassen Sie eine Zeile nach dem Setup-Block frei und tippen Sie “## Meine Infos” (mit den Rauten, aber ohne die Anführungszeichen); stellen Sie sicher, dass keine Leerzeichen vor den Rauten sind und mindestens ein Leerzeichen nach den Rauten vor dem Untertitel\nLassen Sie eine Zeile frei und klicken Sie auf das Menü zum Einfügen eines neuen Codes (ein grünes Kästchen mit einem C und einem Pluszeichen) und wählen Sie R\n\n\nIhr Markdown-Dokument sollte jetzt etwa so aussehen:\n\n\n\n\n\n\n\nFigure 2.3: Neuer R-Block\n\n\n\n\n\n2.4.2 Codeblöcke\nWas Sie erstellt haben, ist ein Untertitel und ein Codeblock. In R Markdown wird alles, was in einem grauen Codeblock geschrieben steht, als Code angesehen, und alles, was im weißen Raum (zwischen den Codeblöcken) geschrieben wird, wird als normaler Text betrachtet (die tatsächlichen Farben hängen davon ab, welches Thema Sie angewendet haben, aber wir beziehen uns auf das Standardweiß und Grau). Dies erleichtert die Kombination von Text und Code in einem Dokument.\n\n\n\n\n\n\nFehler in Codeblöcken\n\n\n\nWenn Sie einen neuen Codeblock erstellen, sollten Sie beachten, dass der graue Kasten mit drei Rückwärts-Apostrophen \\``` beginnt und endet. Ein häufiger Fehler ist es, diese Rückwärts-Apostrophen versehentlich zu löschen. Denken Sie daran, dass Codeblöcke und Texteingaben unterschiedliche Farben haben - wenn die Farbe bestimmter Teile Ihres Markdown nicht richtig aussieht, überprüfen Sie, ob Sie die Rückwärts-Apostrophen nicht gelöscht haben.\n\n\nIn Ihrem Codeblock schreiben Sie den Code, den Sie in Section 1.7 erstellt haben.\n\n\n\nimportant_info.Rmd\n\nname &lt;- \"Emily\"\nage &lt;- 36\ntoday &lt;- Sys.Date()\nchristmas &lt;- as.Date(\"2024-12-25\")\n\n\n\n\n\n\n\n\nKonsole vs. Skripte\n\n\n\nIn Section 1.2 haben wir Sie gebeten, Code in die Konsole einzugeben. Jetzt möchten wir, dass Sie Code in Codeblöcke in R Markdown-Dateien eingeben, um den Code reproduzierbar zu machen. Auf diese Weise können Sie Ihren Code jederzeit neu ausführen, wenn sich die Daten ändern, um den Bericht zu aktualisieren, und Sie oder andere können den Code überprüfen, um Fehler zu identifizieren und zu beheben.\nEs gibt jedoch immer noch Zeiten, in denen Sie Code in die Konsole statt in ein Skript eingeben müssen, beispielsweise wenn Sie ein neues Paket installieren. In diesem Buch werden Codeblöcke mit gekennzeichnet, ob Sie sie in der Konsole ausführen oder den Code zu einem Skript hinzufügen sollten.\n\n\n\n2.4.3 Code ausführen\nWenn Sie in einem R Markdown-Dokument arbeiten, gibt es mehrere Möglichkeiten, Ihre Codezeilen auszuführen.\nZuerst können Sie den Code, den Sie ausführen möchten, markieren und dann auf Run &gt; Run Selected Line(s) klicken, dies ist jedoch mühsam und kann Probleme verursachen, wenn Sie nicht genau den Code markieren, den Sie ausführen möchten.\nAlternativ können Sie die grüne “Play”-Schaltfläche oben rechts im Codeblock drücken, und dies wird alle Codezeilen in diesem Block ausführen.\n\n\n\n\n\n\n\nFigure 2.4: Klicken Sie auf den grünen Pfeil, um allen Code im Block auszuführen.\n\n\n\n\nNoch besser ist es, einige der Tastenkürzel für R Studio zu lernen. Um eine einzelne Codezeile auszuführen, stellen Sie sicher, dass sich der Cursor in der Codezeile befindet, die Sie ausführen möchten (er kann sich irgendwo befinden), und drücken Sie Ctrl+Enter oder Cmd+Enter. Wenn Sie allen Code im Codeblock ausführen möchten, drücken Sie Ctrl+Shift+Enter oder Cmd+Shift+Enter. Lernen Sie diese Tastenkürzel; sie werden Ihr Leben einfacher machen!\n\n\n\n\n\n\n\nFigure 2.5: Verwenden Sie das Tastenkürzel, um nur markierten Code auszuführen, oder führen Sie eine Zeile nach der anderen aus, indem Sie den Cursor auf einer Zeile platzieren, ohne etwas zu markieren.\n\n\n\n\nFühren Sie Ihren Code mit jeder der oben genannten Methoden aus. Sie sollten sehen, dass die Variablen name, age, today und christmas im Umgebungsbereich erscheinen. (Starten Sie R neu, um zurückzusetzen.)\n\n2.4.4 Inline-Code\nWir sprechen immer wieder davon, R Markdown für reproduzierbare Berichte zu verwenden, aber es ist einfacher, Ihnen zu zeigen, warum dies so mächtig ist und Ihnen einen Einblick zu geben, wie dieser Kurs (hoffentlich!) die Art und Weise ändern wird, wie Sie mit Daten für immer arbeiten!\nEin wichtiges Merkmal von R Markdown ist, dass Sie Text und Code kombinieren können, um Werte in Ihre Texte einzufügen, indem Sie Inline-Coding verwenden. Wenn Sie jemals einen Wert oder Text von einer Datei in eine andere kopieren und einfügen mussten, wissen Sie, wie einfach es sein kann, Fehler zu machen. Inline-Code vermeidet dies. Wieder ist es einfacher, Ihnen zu zeigen, was Inline-Code macht, als es zu erklären, also lassen Sie es uns versuchen.\nKopieren und fügen Sie zuerst diesen Text in den weißen Raum unterhalb Ihres Codeblocks ein. Wenn Sie einen anderen Variablennamen als christmas verwendet haben, sollten Sie diesen mit dem Namen des Objekts aktualisieren, das Sie erstellt haben, aber ändern Sie sonst nichts.\nMein Name ist `r name` und ich bin `r age` Jahre alt. \nEs sind `r christmas - today` Tage bis Weihnachten, \nwas mein Lieblingsfeiertag ist.\n\n\n\n\n\n\nDiagramme anzeigen\n\n\n\nSie können kein Diagramm mit Inline-R anzeigen. Diagramme sollten aus Codeblöcken angezeigt werden. Wir kommen bald darauf zurück, wie man das macht.\n\n\n\n2.4.5 Ihre Datei stricken\nJetzt werden wir knit, oder die Datei in einen Dokumententyp unserer Wahl kompilieren. In diesem Fall erstellen wir eine Standard-HTML-Datei, aber Sie werden lernen, wie man andere Dateien wie Word und PDF im Verlauf dieses Kurses erstellt. Um Ihre Datei zu stricken, klicken Sie Knit &gt; Knit to HMTL.\nR Markdown wird ein neues HTML-Dokument erstellen und anzeigen, aber es wird auch automatisch diese Datei in Ihrem Arbeitsverzeichnis speichern.\nWie durch Zauberei erscheint dieser etwas seltsame Text, den Sie kopiert und eingefügt haben, nun als normaler Satz mit den Werten, die aus den von Ihnen erstellten Objekten gezogen wurden.\n\nMein Name ist Emily und ich bin 36 Jahre alt. Es sind 84 Tage bis Weihnachten, was mein Lieblingsfeiertag ist.\n\n\n\n\n\n\n\nStricken mit Code\n\n\n\n\n\nSie können auch stricken, indem Sie den folgenden Code in die Konsole eingeben. Geben Sie diesen niemals in ein Rmd-Skript selbst ein, da es versuchen würde, sich selbst in einer Endlosschleife zu stricken.\n\n\n\nIn der Konsole ausführen\n\nrmarkdown::render(\"important_info.Rmd\")\n\n# alternativ können Sie dies verwenden, aber Sie erhalten möglicherweise eine Warnung\nknitr::knit2html(\"important_info.Rmd\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#daten-laden",
    "href": "02.1-markdown.html#daten-laden",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.5 Daten laden",
    "text": "2.5 Daten laden\nLassen Sie uns nun ein weiteres Beispiel dafür versuchen, Markdown zu verwenden, aber diesmal anstatt Objekte zu verwenden, die wir von Grund auf neu erstellt haben, werden wir eine Datendatei einlesen.\nSpeichern und schließen Sie Ihr important_info.Rmd Dokument. Öffnen und speichern Sie dann ein neues Markdown-Dokument, diesmal mit dem Namen sales_data.Rmd. Sie können wieder alles nach dem Setup-Block löschen. Fügen Sie library(tidyverse) zum Setup-Block hinzu, damit die tidyverse-Funktionen für Ihr Skript verfügbar sind.\n\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(tidyverse)\n```\n\n\n\n2.5.1 Online-Quellen\nLassen Sie uns zuerst versuchen, Daten zu laden, die online gespeichert sind. Erstellen Sie einen Codeblock in Ihrem Dokument und kopieren, fügen Sie den unten stehenden Code ein und führen Sie ihn aus. Dieser Code lädt einige simulierte Verkaufsdaten.\n\nDie Daten sind in einer .csv-Datei gespeichert, daher verwenden wir die Funktion read_csv(), um sie zu laden.\nBeachten Sie, dass die URL in doppelten Anführungszeichen steht - ohne diese funktioniert sie nicht.\n\n\n\n\nsales_data.Rmd\n\nsales_online &lt;- read_csv(\"https://psyteachr.github.io/ads-v2/data/sales_data_sample.csv\")\n\n\n\n\n\n\n\n\nFunktion nicht gefunden\n\n\n\nWenn Sie eine Fehlermeldung erhalten, die so aussieht:\n\nError in read_csv(“https://psyteachr.github.io/ads-v2/data/sales_data_sample.csv”) :\ncould not find function “read_csv”\n\nDas bedeutet, dass Sie tidyverse nicht geladen haben. Überprüfen Sie, ob library(tidyverse) im Setup-Block steht und dass Sie den Setup-Block ausgeführt haben.\n\n\nDieser Datensatz ist simulierte Verkaufsdaten für verschiedene Fahrzeugtypen (ursprünglich von Kaggle), wobei jede Zeile der Daten eine einzelne Bestellung ist. Es gibt mehrere Möglichkeiten, einen Datensatz in R zu betrachten und zu überprüfen. Führen Sie jede der folgenden Aktionen durch und machen Sie sich Notizen darüber, welche Informationen jeder Ansatz zu geben scheint. Wenn Sie mehr Informationen zu jeder dieser Funktionen wünschen, können Sie die Hilfedokumentation mit ?function aufrufen:\n\nKlicken Sie auf das Objekt sales_online im Umgebungsbereich\nFühren Sie head(sales_online) in der Konsole aus\nFühren Sie summary(sales_online) in der Konsole aus\nFühren Sie str(sales_online) in der Konsole aus\nFühren Sie View(sales_online) in der Konsole aus\n\n2.5.2 Lokale Datendateien\nHäufiger werden Sie jedoch mit Datendateien arbeiten, die lokal auf Ihrem Computer gespeichert sind. Aber wo sollten Sie all Ihre Dateien speichern? Normalerweise möchten Sie alle Ihre Skripte und Datendateien für ein einzelnes Projekt in einem Ordner auf Ihrem Computer haben, dem working directory des Projekts, und wir haben bereits das Hauptverzeichnis 02-reports für dieses Kapitel eingerichtet.\nSie können Dateien in Unterordnern innerhalb dieses Hauptprojektverzeichnisses organisieren, wie das Speichern aller Rohdatendateien in einem Unterordner namens data und das Speichern aller Bilddateien in einem Unterordner namens images. Die Verwendung von Unterordnern hilft, zu verhindern, dass ein einzelner Ordner zu überfüllt wird, was wichtig ist, wenn Sie an großen Projekten arbeiten.\nErstellen Sie in Ihrem 02-reports Verzeichnis einen neuen Ordner namens data, laden Sie eine Kopie der Verkaufsdatendatei herunter, und speichern Sie sie in diesem neuen Unterordner.\nUm Daten aus einer lokalen Datei zu laden, können wir wieder die Funktion read_csv() verwenden, aber diesmal geben wir anstelle einer URL den Unterordner und den Dateinamen an.\n\n\n\nsales_data.Rmd\n\nsales_local &lt;- read_csv(\"data/sales_data_sample.csv\")\n\n\n\n\n\n\n\n\nDateinamen mit Tab-Autovervollständigung\n\n\n\nVerwenden Sie die Tab-Autovervollständigung, wenn Sie Dateinamen in einem Codeblock eingeben. Nachdem Sie das erste Anführungszeichen eingegeben haben, drücken Sie Tab, um ein Dropdown-Menü der Dateien in Ihrem Arbeitsverzeichnis zu sehen. Sie können den Namen des Unterordners oder der Datei eingeben, um es einzugrenzen. Dies ist sehr nützlich, um ärgerliche Fehler aufgrund von Tippfehlern oder Dateien, die nicht dort sind, wo Sie sie erwarten, zu vermeiden.\n\n\nDinge zu beachten:\n\nSie müssen die Dateiendung (in diesem Fall .csv) einschließen\nDer Unterordnername (data) und der Dateiname werden durch einen Schrägstrich / getrennt\nGenauigkeit ist wichtig, wenn Sie einen Tippfehler im Dateinamen haben, wird Ihre Datei nicht gefunden; denken Sie daran, dass R groß- und kleinsch\n\nreibungsabhängig ist - Sales_Data.csv ist eine völlig andere Datei als sales_data.csv, soweit es R betrifft.\n\n\n\n\n\n\nsales_local anzeigen\n\n\n\nFühren Sie head(), summary(), str() und View() auf sales_local aus, um zu bestätigen, dass die Daten mit sales_online übereinstimmen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#einen-bericht-schreiben",
    "href": "02.1-markdown.html#einen-bericht-schreiben",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.6 Einen Bericht schreiben",
    "text": "2.6 Einen Bericht schreiben\nWir werden einen grundlegenden Bericht für diesen Verkaufsdatensatz mit R Markdown schreiben, um Ihnen einige der Funktionen zu zeigen. Wir werden fast jeden Aspekt dessen, was wir Ihnen gerade zeigen, im Verlauf dieses Kurses erweitern; das wichtigste Ergebnis ist, dass Sie anfangen, sich mit der Funktionsweise von R Markdown vertraut zu machen und zu verstehen, wozu Sie es verwenden können.\n\n2.6.1 Datenanalyse\nFür diesen Bericht werden wir nur einige einfache Verkaufsstatistiken für drei Fahrzeugtypen vorstellen: Flugzeuge, Motorräder und klassische Autos. Wir werden darauf zurückkommen, wie Sie diesen Code selbst schreiben können, in ?sec-summary. Für jetzt sehen Sie, ob Sie der Logik des Codes folgen können, den wir Ihnen durch die Codekommentare erklären.\nErstellen Sie einen neuen Codeblock, kopieren, fügen Sie den folgenden Code ein und führen Sie ihn aus, und sehen Sie sich dann sales_counts an, indem Sie auf das Objekt im Umgebungsbereich klicken. Beachten Sie, dass es nicht wirklich wichtig ist, ob Sie sales_local oder sales_online in der ersten Zeile verwenden, da sie identisch sind.\n\n\n\nsales_data.Rmd\n\n# behalte nur die Daten von Flugzeugen, Motorrädern und Autos\nsales_pmc &lt;- filter(sales_online,\n         PRODUCTLINE %in% c(\"Planes\", \"Motorcycles\", \"Classic Cars\"))\n\n# zähle, wie viele es in jeder PRODUCTLINE gibt\nsales_counts &lt;-count(sales_pmc, PRODUCTLINE)\n\n\nDa jede Zeile des Datensatzes einen Verkauf darstellt, gibt uns dieser Code eine schöne und einfache Möglichkeit zu sehen, wie viele Verkäufe von jedem Fahrzeugtyp gemacht wurden; er zählt einfach die Anzahl der Zeilen in jeder Gruppe.\n\n\n\n\n\nPRODUCTLINE\nn\n\n\n\nClassic Cars\n967\n\n\nMotorcycles\n331\n\n\nPlanes\n306\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nEinfach ein Objekt für sich auf einer Zeile “ausdrucken”. Section 2.6.5 zeigt Ihnen, wie Sie die Tabelle in verschiedenen Formaten für Ihren Bericht ausdrucken.\n\n\n\n2.6.2 Textformatierung\nSie können den visuellen markdown-Editor verwenden, wenn Sie RStudio Version 1.4 oder höher haben. Dies wird ein Knopf oben in der Quellfenster sein, und die Menüoptionen sollten jedem vertraut sein, der mit Software wie Microsoft Word gearbeitet hat.\n\n\n\n\n\n\n\nFigure 2.6: Der visuelle Editor.\n\n\n\n\nDies ist nützlich für komplexe Stile, aber Sie können auch diese häufigen Klartext-Stil-Markups verwenden:\n\nÜberschriften werden erstellt, indem Sie Untertitel mit einer oder mehreren Rauten (#) und einem Leerzeichen präfixieren (lassen Sie das Leerzeichen nicht aus). Wenn Sie ein Inhaltsverzeichnis einschließen, wird dies aus Ihren Dokumentüberschriften erstellt.\nFormatieren Sie Text mit Kursivschrift oder Fettdruck, indem Sie den Text mit ein oder zwei Sternchen oder Unterstrichen umgeben.\nErstellen Sie Listen mit Zahlen, Sternchen oder Bindestrichen vor den Elementen. Rücken Sie Elemente ein, um verschachtelte Listen zu erstellen.\nErstellen Sie Links so: [psyTeachR](https://psyteachr.github.io/)\n\nLaden Sie den R Markdown Spickzettel herunter, um mehr zu erfahren.\n\nKopieren und fügen Sie den unten stehenden Text in den weißen Raum unterhalb des Codeblocks, der die Daten lädt, ein. Speichern Sie die Datei und klicken Sie dann auf Stricken, um die Ergebnisse zu sehen. Es wird ein wenig unordentlich aussehen, da es den Code und die Nachrichten vom Laden der Daten enthält, aber keine Sorge, wir werden das bald loswerden.\n## Beispiel-Verkaufsbericht\n\nDieser Bericht fasst die Verkaufsdaten für verschiedene Fahrzeugtypen zusammen, die zwischen 2003 und 2005 verkauft wurden. Diese Daten stammen von [Kaggle](https://www.kaggle.com/kyanyoga/sample-sales-data).\n\n### Verkäufe nach Typ\n\nDie *gesamte* Anzahl verkaufter **Flugzeuge** betrug `r sales_counts$n[3]`\n\nDie *gesamte* Anzahl verkaufter **klassischer Autos** betrug `r sales_counts$n[1]`.\n\n\n\n\n\n\nWarning\n\n\n\nDas obige Beispiel-Markdown (und der Rest in diesem Buch) wird für den regulären Editor gezeigt, nicht für den visuellen Editor. Im visuellen Editor sehen Sie nicht die Rauten, die Überschriften erstellen, oder die Sternchen, die fetten und kursiven Text erstellen. Sie sehen auch nicht die Rückwärts-Apostrophen, die Inline-Code kennzeichnen.\n\n\n\n\nDer obige Beispielcode im visuellen Editor.\n\n\n\nWenn Sie versuchen, die Rauten, Sternchen und Rückwärts-Apostrophen zum visuellen Editor hinzuzufügen, werden Sie frustriert sein, da sie verschwinden. Wenn Sie Erfolg haben, wird Ihr Code im regulären Editor so aussehen:\n\\#\\#\\# Verkäufe nach Typ\n\nDer \\*gesamte\\* Anzahl von \\*\\*Flugzeugen\\*\\* verkauft war \\`r sales_counts\\$n\\[3]\\`\n\n\nVersuchen Sie, den Inline-Code mit dem zu vergleichen, was in der Tabelle sales_counts steht. Zu beachten:\n\nDas $-Zeichen wird verwendet, um bestimmte Variablen (oder Spalten) in einem Objekt mit der Syntax object$variable anzugeben.\nEckige Klammern mit einer Zahl, z. B. [3], geben eine bestimmte Beobachtung an\nAlso fragt sales_counts$n[3] den Inline-Code, die dritte Beobachtung der Variablen n im Datensatz sales_online anzuzeigen.\n\n\n\n\n\n\n\nWeitere Übung\n\n\n\nFügen Sie eine weitere Zeile hinzu, die die Gesamtzahlen der Motorräder mit Inline-Code meldet. Verwenden Sie entweder den visuellen Editor oder Text-Markups, um Fettdruck und Kursivschrift hinzuzufügen, damit es den anderen entspricht.\n\n\nSolution\n\nDie *gesamte* Anzahl verkaufter **Motorräder** betrug `r sales_counts$n[2]`.\n\n\n\n\n2.6.3 Codekommentare\nIm obigen Code haben wir Code Kommentare verwendet, und es ist wichtig zu betonen, wie nützlich diese sind. Sie können Kommentare in R-Blöcken mit dem Rautensymbol (#) hinzufügen. R wird Zeichen vom Rautensymbol bis zum Ende der Zeile ignorieren.\n\n# wichtige Zahlen\n\nn &lt;- nrow(sales_online) # die Gesamtanzahl der Verkäufe (Anzahl der Zeilen)\nfirst &lt;- min(sales_online$YEAR_ID) # das erste (minimale) Jahr\nlast &lt;- max(sales_online$YEAR_ID) # das letzte (maximale) Jahr\n\nEs ist normalerweise eine gute Praxis, einen Codeblock mit einem Kommentar zu beginnen, der erklärt, was Sie dort tun, besonders wenn der Code nicht im Text des Berichts erklärt wird.\nWenn Sie Ihre Objekte klar benennen, müssen Sie oft keine klärenden Kommentare hinzufügen. Zum Beispiel, wenn ich die drei oben genannten Objekte total_number_of_sales, first_year und last_year genannt hätte, würde ich die Kommentare weglassen. Es ist eine Kunst, Ihren Code gut zu kommentieren, aber versuchen Sie, Kommentare hinzuzufügen, während Sie durch dieses Buch arbeiten - es wird Ihnen helfen, Ihr Lernen zu festigen, und wenn das z\nukünftige Sie Ihren Code überprüft, werden Sie dem vergangenen Sie für die Klarheit danken.\n\n2.6.4 Bilder\nWie das Sprichwort sagt, malt ein Bild tausend Worte und manchmal möchten Sie Ihre Daten mithilfe von Visualisierungen kommunizieren.\nErstellen Sie einen Codeblock, um ein Diagramm der Daten in Ihrem Dokument nach dem bisher geschriebenen Text anzuzeigen. Wir verwenden einen Code, den Sie in Chapter 8 genauer kennenlernen werden, um ein einfaches Balkendiagramm zu erstellen, das die Verkaufsdaten darstellt – konzentrieren Sie sich darauf zu versuchen, zu verstehen, wie Teile des Codes auf das erstellte Diagramm abgebildet werden.\nKopieren und fügen Sie den unten stehenden Code ein. Führen Sie den Code in Ihrem Markdown aus, um das Diagramm zu sehen, das es erstellt, und stricken Sie dann die Datei, um zu sehen, wie es in Ihrem Dokument angezeigt wird.\n\n\n\nsales_data.Rmd\n\nggplot(data = sales_counts, \n       mapping = aes(x = PRODUCTLINE, \n                     y = n, \n                     fill = PRODUCTLINE)) +\n  geom_col(show.legend = FALSE) +\n  labs(x = \"Fahrzeugtyp\",\n       y = \"Anzahl der Verkäufe\",\n       title = \"Verkäufe nach Fahrzeugtyp\",\n       subtitle = \"2003 - 2005\")\n\n\n\n\n\n\n\n\nSie können auch Bilder einfügen, die Sie nicht in R erstellt haben, indem Sie die Markdown-Syntax für Bilder oder knitr::include_graphics() verwenden. Dies ist sehr ähnlich dem Laden von Daten, da Sie entweder ein Bild verwenden können, das auf Ihrem Computer gespeichert ist, oder über eine URL.\nErstellen Sie einen neuen Codeblock unterhalb jeder der Verkaufszahlen für Flugzeuge, klassische Autos und Motorräder und fügen Sie ein Bild von Google oder Wikipedia für jedes hinzu (klicken Sie mit der rechten Maustaste auf ein Bild und wählen Sie Bildadresse kopieren, um eine URL zu erhalten). Sehen Sie sich den Abschnitt über Chunk-Standards an, um zu sehen, wie Sie die Anzeigegröße ändern können.\n\n\n\nsales_data.Rmd\n\nknitr::include_graphics(\"https://upload.wikimedia.org/wikipedia/commons/3/3f/P-51_Mustang_edit1.jpg\")\n\n\n\n\n\n\n\n\nBildlizenzen\n\n\n\n\n\nDie meisten Bilder auf Wikipedia sind gemeinfrei oder haben eine offene Lizenz. Sie können Bilder nach Lizenz auf Google Bilder suchen, indem Sie auf die Schaltfläche Tools klicken und “Creative Commons-Lizenzen” aus dem Menü “Nutzungsrechte” wählen.\n\n\n\n\n\n\n\n\n\n\n\nAlternativ können Sie die Markdown-Notation ![caption](url) verwenden, um ein Bild anzuzeigen. Dies geht in den Markdown-Textbereich des Dokuments, nicht innerhalb eines grauen Codeblocks. Die Beschriftung ist optional; Sie können sie weglassen, wie dies:\n![](images/reports/google-images.png)\n\n2.6.5 Tabellen\nAnstatt eine Abbildung zu verwenden, möchten wir vielleicht unsere Daten in einer Tabelle anzeigen.\n\nFügen Sie eine neue Überschrift der Ebene 2 (zwei Rauten) zu Ihrem Dokument hinzu, benennen Sie die Überschrift “Daten in Tabellenform”, und erstellen Sie dann einen neuen Codeblock darunter.\n\nZuerst sehen wir, wie die Tabelle aussieht, wenn wir keine Änderungen vornehmen. Schreiben Sie einfach den Namen der Tabelle, die Sie anzeigen möchten, in den Codeblock (in unserem Fall sales_counts), und klicken Sie dann auf Stricken, um zu sehen, wie sie aussieht.\n\n\n\nsales_data.Rmd\n\nsales_counts\n\n\n## # A tibble: 3 × 2\n## # Groups:   PRODUCTLINE [3]\n##   PRODUCTLINE      n\n##   &lt;chr&gt;        &lt;int&gt;\n## 1 Classic Cars   967\n## 2 Motorcycles    331\n## 3 Planes         306\nEs ist gerade noch lesbar, aber nicht großartig.\nEine andere Möglichkeit, Tabellen anzupassen, verwendet die Funktion kable() aus dem Paket kableExtra.\nÄndern Sie Ihren Code, um das Paket kableExtra zu laden und die Funktion kable() auf die Tabelle anzuwenden. Stricken Sie die Datei erneut, um das Ergebnis zu sehen.\n\n\n\nsales_data.Rmd\n\nlibrary(kableExtra) # für die Tabellenanzeige\n\nkable(sales_counts) # wende die kable-Funktion an\n\n\n\n\nPRODUCTLINE\nn\n\n\n\nClassic Cars\n967\n\n\nMotorcycles\n331\n\n\nPlanes\n306\n\n\n\n\n\nEs ist besser, aber immer noch nicht erstaunlich. Also lassen Sie uns einige Anpassungen vornehmen. Wir können die Namen der Spalten ändern, eine Beschriftung hinzufügen und auch die Ausrichtung des Zellinhalts mithilfe von Argumenten für kable() ändern.\nWir können auch ein Thema hinzufügen, um den Gesamtstil zu ändern. In diesem Beispiel haben wir kable_classic verwendet, aber es gibt 5 andere: kable_paper, kable_classic_2, kable_minimal, kable_material und kable_material_dark. Probieren Sie sie alle aus und sehen Sie, welchen Sie bevorzugen.\nSchließlich können wir die Formatierung der ersten Zeile mithilfe von row_spec ändern. Schauen Sie sich die Hilfedokumentation für row_spec an, um zu sehen, welche anderen Optionen verfügbar sind. Versuchen Sie, den Wert eines der folgenden Argumente zu ändern, um herauszufinden, was sie tun.\n\n\n\nsales_data.Rmd\n\nk &lt;- kable(sales_counts, \n      col.names = c(\"Produkt\", \"Verkäufe\"),\n      caption = \"Anzahl der Verkäufe pro Produktlinie.\", \n      align = \"c\")\nk_style &lt;- kable_classic(k, full_width = FALSE) \nk_highlighted &lt;- row_spec(k_style, row = 0, bold = TRUE, color = \"red\") \n\nk_highlighted\n\n\n\nAnzahl der Verkäufe pro Produktlinie.\n \n Produkt \n    Verkäufe \n  \n\n\n Classic Cars \n    967 \n  \n\n Motorcycles \n    331 \n  \n\n Planes \n    306 \n  \n\n\n\n\n\n\n\n\n\n\nPlatzierung der Beschriftung\n\n\n\nDas Aussehen und die Platzierung der Tabellenbeschriftung hängen von der Art des Dokuments ab, das Sie erstellen. Ihre Beschriftungen sehen möglicherweise anders aus als die in diesem Buch, da Sie ein html_document mit einer einzigen Seite erstellen, während dieses Buch den html-Stil von quarto verwendet, einer neueren Alternative zu R Markdown. Sie werden mehr über andere Dokumentausgabetypen in ?sec-custom-reports lernen.\n\n\n\n\n\n\n\n\nErweiterte Tabellenanpassung\n\n\n\n\n\nWenn Sie sich mit dem bisher Besprochenen sicher fühlen, gibt das kableExtra-Vignette viel mehr Details darüber, wie Sie Ihre Tabellen mithilfe von kableExtra bearbeiten können.\nSie können auch das gt-Paket erkunden, das komplex ist, aber es Ihnen ermöglicht, wunderschöne angepasste Tabellen zu erstellen. Riding tables with {gt} and {gtExtras} ist ein hervorragendes Tutorial.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#ihren-bericht-verfeinern",
    "href": "02.1-markdown.html#ihren-bericht-verfeinern",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.7 Ihren Bericht verfeinern",
    "text": "2.7 Ihren Bericht verfeinern\n\n2.7.1 Chunk-Standards\nLassen Sie uns damit abschließen, den Bericht aufzuräumen und unseren Code etwas besser zu organisieren. Wenn Sie eine neue R Markdown-Datei in RStudio erstellen, wird automatisch ein Setup-Block erstellt - wir haben diesen Block bisher größtenteils ignoriert.\n\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n\nSie können hier weitere Standardoptionen für Ihr Dokument festlegen. Geben Sie den folgenden Code in die Konsole ein, um die vollständige Liste der Optionen, die Sie festlegen können, und ihrer Standardwerte zu sehen. Die nützlichsten und häufigsten Optionen, die Sie für das Schreiben von Berichten ändern möchten, drehen sich jedoch darum, ob Sie Ihren Code anzeigen möchten und wie groß Ihre Bilder sein sollen.\n\n\n\nIn der Konsole ausführen\n\n# Liste der Standardoptionen\nstr(knitr::opts_chunk$get())\n\n\nErsetzen Sie den Code in Ihrem Setup-Block mit dem unten stehenden Code und versuchen Sie dann, jede Option von FALSE auf TRUE zu ändern und die numerischen Werte zu ändern, und stricken Sie die Datei erneut, um den Unterschied zu sehen, den es macht.\n\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(\n  echo       = FALSE, # ob Codeblöcke angezeigt werden\n  message    = FALSE, # ob Nachrichten von Ihrem Code angezeigt werden\n  warning    = FALSE, # ob Warnungen von Ihrem Code angezeigt werden\n  fig.width  = 8,     # Abbildungsbreite in Zoll (bei 96 dpi)\n  fig.height = 5,     # Abbildungshöhe in Zoll (bei 96 dpi)\n  out.width = \"50%\"   # Abbildungen/Bilder nehmen 50% der Seitenbreite ein\n)\n```\n\n\n\n\n\n\n\n\nAbbildungs- versus Ausgabedimensionen\n\n\n\n\n\nBeachten Sie, dass fig.width und fig.height die ursprüngliche Größe und das Seitenverhältnis von Bildern steuern, die von R generiert werden, wie z. B. Diagramme. Dies beeinflusst die relative Größe von Text und anderen Elementen in Diagrammen. Es hat keinen Einfluss auf die Größe vorhandener Bilder. out.width steuert jedoch die Anzeigegröße sowohl vorhandener Bilder als auch von R generierter Abbildungen. Dies wird normalerweise als Prozentsatz der Seitenbreite eingestellt.\n\n\n\n\n\n\n\nFigure 2.7: Ein Diagramm mit den Standardwerten von fig.width = 8, fig.height = 5, out.width = “100%”\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.8: Das gleiche Diagramm mit der Hälfte der Standardbreite und -höhe: fig.width = 4, fig.height = 2.5, out.width = “100%”\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.9: Das gleiche Diagramm wie oben bei der Hälfte der Ausgabebreite: fig.width = 4, fig.height = 2.5, out.width = “50%”\n\n\n\n\n\n\n\n\n2.7.2 Standards überschreiben\nDiese Setup-Optionen ändern das Verhalten für das gesamte Dokument, jedoch können Sie das Verhalten für einzelne Codeblöcke überschreiben.\nZum Beispiel möchten Sie standardmäßig vielleicht Ihren Code verbergen, aber es könnte auch eine Gelegenheit geben, bei der Sie den Code, den Sie zur Analyse Ihrer Daten verwendet haben, anzeigen möchten. Sie können echo = FALSE in Ihrem Setup-Block einstellen, um das Verbergen von Code zur Standardeinstellung zu machen, aber im einzelnen Codeblock für Ihr Diagramm echo = TRUE einstellen. Versuchen Sie dies jetzt und stricken Sie die Datei, um die Ergebnisse zu sehen.\n\n\n```{r, echo = TRUE}\nggplot(data = sales_counts, \n       mapping = aes(x = PRODUCTLINE, \n                     y = n, \n                     fill = PRODUCTLINE)) +\n  geom_col(show.legend = FALSE) +\n  labs(x = \"Fahrzeugtyp\",\n       y = \"Anzahl der Verkäufe\",\n       title = \"Verkäufe nach Fahrzeugtyp\",\n       subtitle = \"2003 - 2005\")\n```\n\n\nZusätzlich können Sie auch die Standardanzeigegröße oder -abmessungen von Bildern überschreiben.\n\n\n```{r, out.width='25%'}\nknitr::include_graphics(\"https://upload.wikimedia.org/wikipedia/commons/3/3f/P-51_Mustang_edit1.jpg\")  \n```\n\n\n\n\n```{r, fig.width = 10, fig.height = 20}\nggplot(data = sales_counts,  \n       mapping = aes(x = PRODUCTLINE, y = n, fill = PRODUCTLINE)) +  \n  geom_bar(stat = \"identity\", show.legend = FALSE) +  \n  labs(x = \"Fahrzeugtyp\",  \n       y = \"Anzahl der Verkäufe\",  \n       title = \"Verkäufe nach Fahrzeugtyp\",  \n       subtitle = \"2003 - 2005\")  \n```\n\n\n\n2.7.3 Pakete laden\nSie sollten die Pakete, die Sie benötigen, in Ihrem Setup-Block mit library() laden. Oft, wenn Sie an einem Skript arbeiten, stellen Sie fest, dass Sie ein weiteres Add-on-Paket laden müssen. Vergraben Sie den Aufruf von library(package_I_need) nicht irgendwo im Skript. Fügen Sie es in den Setup-Block ein, damit der Benutzer einen Überblick darüber hat, welche Pakete benötigt werden.\n\n\n\n\n\n\nBibliotheksaufrufe in den Setup-Block verschieben\n\n\n\nVerschieben Sie den Code, der tidyverse und kableExtra lädt, in den Setup-Block.\n\n\n\n2.7.4 YAML-Header\nSchließlich ist der YAML-Header der Teil ganz oben in Ihrem Markdown-Dokument. Hier können Sie auch mehrere Optionen festlegen.\n---  \ntitle: \"Verkaufsdaten-Bericht\"  \nauthor: \"Ihr Name\"  \noutput:  \n  html_document:  \n    df_print: paged  \n    theme:  \n      version: 4  \n      bootswatch: yeti  \n    toc: true  \n    toc_float:  \n      collapsed: false  \n      smooth_scroll: false  \n    toc_depth: 3  \n    number_sections: false  \n---  \n\n\n\n\n\n\nVersuchen\n\n\n\nÄndern Sie die Werte von false auf true, um zu sehen, was die Optionen bewirken.\n\n\nDie Option df_print: paged druckt dataframes automatisch mit rmarkdown::paged_table() aus. Sie können df_print: kable verwenden, um standardmäßig den einfachen kable-Stil zu verwenden, aber Sie benötigen den Code aus Section 2.6.5 für komplexere Tabellen mit kableExtra.\nDie eingebauten Bootstrap-Themen sind: default, cerulean, cosmo, darkly, flatly, journal, lumen, paper, readable, sandstone, simplex, spacelab, united und yeti. Sie können mehr Themen anzeigen und herunterladen. Ändern Sie das Thema, um zu sehen, welches Ihnen am besten gefällt.\n\n\n\n\n\n\n\nFigure 2.10: Helle Themen in den Versionen 3 und 4.\n\n\n\n\n\n\n\n\n\n\nYAML-Formatierung\n\n\n\nYAML-Header können sehr wählerisch in Bezug auf Leerzeichen und Semikolons sein (der Rest von R Markdown ist viel verzeihender). Wenn Sie beispielsweise ein Leerzeichen vor “author” einfügen, erhalten Sie einen Fehler, der wie folgt aussieht:\nError in yaml::yaml.load(..., eval.expr = TRUE) :  \n  Parser error: while parsing a block mapping at line 1,  \n  column 1 did not find expected key at line 2, column 2  \nDie Fehlermeldung zeigt Ihnen genau, wo das Problem liegt (das zweite Zeichen der zweiten Zeile des YAML-Headers), und es handelt sich normalerweise um Tippfehler oder falsche Einrückungen.\n\n\n\n2.7.5 Inhaltsverzeichnis\nDas Inhaltsverzeichnis wird erstellt, indem toc: true gesetzt wird. Es wird oben in Ihrem Dokument angezeigt, es sei denn, Sie setzen toc_float: true oder fügen toc_float: mit den Optionen collapsed und smooth_scroll hinzu (Optionen für eine Einstellung werden darunter eingerückt).\n---  \noutput:  \n  html_document:  \n    toc: true  \n    toc_float:  \n      collapsed: false  \n      smooth_scroll: false  \n    toc_depth: 3  \n---  \nDies verwendet die Markdown-Überschriftenstruktur, um das Inhaltsverzeichnis zu erstellen. toc_depth: 3 bedeutet, dass das Inhaltsverzeichnis nur Überschriften bis Ebene 3 anzeigt (d. h. diejenigen, die mit drei Rauten beginnen: ###). Fügen Sie {-} nach dem Überschriftentitel hinzu, um es aus dem Inhaltsverzeichnis zu entfernen (z. B. ### Übersicht {-}).\n\n\n\n\n\n\nFalsch formatiertes ToC\n\n\n\nWenn Ihr Inhaltsverzeichnis nicht richtig angezeigt wird, bedeutet dies wahrscheinlich, dass Ihre Überschriften nicht richtig eingerichtet sind. Stellen Sie sicher, dass Überschriften keine Leerzeichen vor den Rauten und mindestens ein Leerzeichen nach den Rauten haben. Zum Beispiel wird ##Analysis nicht als Überschrift angezeigt und dem Inhaltsverzeichnis hinzugefügt, aber ## Analysis schon.\n\n\n\n2.7.6 Formate\nBisher haben wir nur nach HTML gestrickt. Um PDF-Berichte zu erstellen, müssen Sie tinytex(Xie, 2021) installieren und den folgenden Code in der Konsole ausführen (fügen Sie dies nicht in Ihr Rmd-Skript ein):\n\ninstall.packages(\"tinytex\")  \ntinytex::install_tinytex()  \n\nSobald Sie dies getan haben, aktualisieren Sie Ihren YAML-Header, um einen pdf_document-Abschnitt hinzuzufügen, und stricken Sie ein PDF-Dokument. Die Optionen für PDFs sind im Vergleich zu HTML-Dokumenten eingeschränkter, daher müssen Sie möglicherweise einige Optionen entfernen, wie z. B. toc_float, wenn Sie eine Fehlermeldung erhalten, die so aussieht: “Functions that produce HTML output found in document targeting PDF output.”\n---  \noutput:  \n  pdf_document:  \n    toc: TRUE  \n  html_document:  \n    toc: TRUE  \n    toc_float: TRUE  \n---  \nAls Alternative können Sie auch in ein Word-Dokument stricken. Wenn Sie auf die Schaltfläche Knit klicken, wird standardmäßig das erste Format gestrickt, aber Sie können das Dropdown-Menü unter der Schaltfläche Knit verwenden, um ein anderes Format auszuwählen.\n---  \noutput:  \n  pdf_document:  \n    toc: TRUE  \n  html_document:  \n    toc: TRUE  \n    toc_float: TRUE  \n  word_document:  \n    toc: TRUE  \n---  \n\n\n\n\n\n\nStrickfehler\n\n\n\nWenn Sie auf Fehler stoßen, fragen Sie im Teams um Hilfe - das Stricken zu PDF oder Word kann knifflig sein.\n\n\n\n2.7.7 Zusammenfassung\nDieses Kapitel hat viel abgedeckt, aber hoffentlich haben Sie jetzt eine viel bessere Vorstellung davon, was Markdown leisten kann. Während die Arbeit in Markdown am Anfang länger dauert, können Sie, sobald Sie einen vollständig reproduzierbaren Bericht haben, neue Daten jede Woche oder jeden Monat einfügen und einfach auf Stricken klicken, um doppelten Aufwand und menschliche Fehler zu reduzieren.\nSie können eine arbeitsfähige R Markdown-Datei mit dem Code aus dem obigen Beispiel vergleichen.\nIm weiteren Verlauf des Buches werden Sie lernen, wie man Daten bereinigt und analysiert und wie man Markdown verwendet, um sie zu präsentieren. Wir werden die verfügbaren Anpassungsoptionen langsam erweitern, sodass Ihre Markdown-Berichte im Laufe der nächsten Wochen immer polierter und professioneller aussehen werden.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "02.1-markdown.html#sec-glossary-intro",
    "href": "02.1-markdown.html#sec-glossary-intro",
    "title": "2  Berichte mit R Markdown erstellen",
    "section": "\n2.8 Glossar",
    "text": "2.8 Glossar\nDas Glossar am Ende jedes Kapitels definiert gängige Fachbegriffe, denen du beim Erlernen von R begegnen könntest. Dieser spezialisierte Wortschatz kann dir helfen, effizienter zu kommunizieren und nach Lösungen für Probleme zu suchen. Die unten stehenden Begriffe verlinken zum PsyTeachR-Glossar, das weitere Informationen und Beispiele enthält.\n\n\n\n\nterm\ndefinition\n\n\n\ndirectory\nA collection or “folder” of files on a computer.\n\n\nextension\nThe end part of a file name that tells you what type of file it is (e.g., .R or .Rmd).\n\n\nknit\nTo create an HTML, PDF, or Word document from an R Markdown (Rmd) document\n\n\nmarkdown\nA way to specify formatting, such as headers, paragraphs, lists, bolding, and links.\n\n\nproject\nA way to organise related files in RStudio\n\n\nr-markdown\nThe R-specific version of markdown: a way to specify formatting, such as headers, paragraphs, lists, bolding, and links, as well as code blocks and inline code.\n\n\nscript\nA plain-text file that contains commands in a coding language, such as R.\n\n\nworking-directory\nThe filepath where R is currently reading and writing files.\n\n\nyaml\nA structured format for information\n\n\n\n\n\n\n\n\n\nXie, Y. (2021). Tinytex: Helper functions to install and maintain TeX live, and compile LaTeX documents. https://github.com/yihui/tinytex",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Berichte mit R Markdown erstellen</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html",
    "href": "03-coding-basics.html",
    "title": "\n3  Coding basics\n",
    "section": "",
    "text": "3.1 Erstellung des ersten Skripts\nWie wir im ersten Kapitel gesehen haben ist ein Grund für die Verwendung von RStduio, dass wir damit R-Skripte erstellen und ausführen können. Wir könnten den Code zwar auch direkt in der Konsole ausführen, das ist jedoch mühsam und unübersichtlich. Deshalb erstellen wir als erstes ein neues R-Skript, in dem wir die hier besprochenen “Befehle” (Codes) sammeln und abspeichern. Dies hat auch den Vorteil, dass die ausgeführten Analysen reproduzierbar sind. Wollen wir die durchgeführten Analysen zu einem späteren Zeitpunkt nochmals wiederholen, öffnen wir einfach wieder das gespeicherte Skript und lassen dieses laufen (sprich “schicken” den Code an die R-Konsole).\nDie Verwendung der Konsole ist sehr praktisch, zeichnet jedoch nicht auf, was wir gemacht haben. R-Skripte dienen genau diesem Zweck: Sie sammeln Ihre Befehle, die Sie als Datei speichern und jederzeit erneut ausführen können. Dies ist die erste Säule guter Codierung: reproduzierbare Codes.\nUm ein neues Skript zu erstellen, kann man auf Datei -&gt; Neues Dokument -&gt; R-Skript klicken oder einfach Umschalt+cmd+N auf dem Mac oder Umschalt+Ctrl+N auf Windows drücken.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#code-über-skripte-ausführen",
    "href": "03-coding-basics.html#code-über-skripte-ausführen",
    "title": "\n3  Coding basics\n",
    "section": "\n3.2 Code über Skripte ausführen",
    "text": "3.2 Code über Skripte ausführen\nIm Grunde genommen ist R nichts anderes, als ein fancy Taschenrechner. So können wir die Summe von 1 + 1 berechnen:\n\n1 + 1\n\n[1] 2\n\n\nUm diesen Code auszuführen müssen wir ihn wie gesagt an die Konsole “schicken”. Dies geschieht am einfachsten, indem man mit dem Cursor auf die Zeile klickt, die man ausführen möchte (die horizontale Position spielt dabei keine Rolle) und dann Ctrl + Enter (Windows) oder Cmd + Enter (Mac) drückt.\nUm diesen Code auszuführen, müssen Sie ihn über die Konsole ausführen, was auf verschiedene Arten geschehen kann. Der offensichtlichste Weg ist, ihn in die Konsole zu kopieren und einzufügen, was jedoch nicht sehr effizient ist. Am schnellsten ist es, den Cursor in die Zeile zu bringen, die Sie ausführen möchten, und cmd+Return oder Strg+Eingabe zu drücken.\nTipp: Man mann mehrere Zeilen auf einmal auswählen und dieselbe Methode verwenden, um mehrere Codes (Codeblock) auf einmal auszuführen.\nNeben zahlen versteht R auch Zeichen (Text), dabei müssen wir jedoch vor und nach dem Text die Anführungszeichen ’ oder ” verwenden:\n\n\"Hello world!\"\n\n[1] \"Hello world!\"\n\n\nDies müssen wir tun, damit R weiss, dass es sich bei diesem Text nicht um Code handelt, den R interpretieren (ausführen) soll. Tun wir dies nicht, sehen wir eine Fehlermeldung.\n\nHello world!\n\nError: &lt;text&gt;:1:7: unexpected symbol\n1: Hello world\n          ^",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#variablen",
    "href": "03-coding-basics.html#variablen",
    "title": "\n3  Coding basics\n",
    "section": "\n3.3 Variablen",
    "text": "3.3 Variablen\nFühren wir Code wie oben beschrieben aus, wird dieser ausgeführt und das Ergebnis erscheint in der Konsole. Das Resultat der Berechnung(en) wird jedoch nicht gespeichert. Oft wollen wir aber das Resultat unserer Berechnungen speichern. Wenn wir eine Regression berechnen, wollen wir das Resultat speichern, damit wir später wieder darauf zugreifen können. Um dies zu tun, können wir die Berechnung in sogenannten Objekten oder Variablen speichern. Diese Objekte/Variablen enthalten dann das Resultat unserer Berechnung. Der folgende Code speichert das Resultat der Berechnung 1 + 1 im Objekt resultat_der_berechnung\n\nresultat_der_berechnung &lt;- 1 + 1\n\nBeim Ausführen dieses Befehls scheint nichts zu passieren – zumindest wird im Konsolenfenster nichts angezeigt, nur der Befehl wird ausgeführt. Allerdings erscheint eine neue Variable im Environment-Fenster im Abschnitt Werte (Values), mit dem Namen resultat_der_berechnung und dem Wert 2. Dies zeigt uns an, dass diese Variable in der aktiven R-Session gespeichert wurde und wir später wieder darauf zugreifen können (die Variable ist jedoch nur solange gespeichert, bis wir RStudio schliessen!).\n\nresultat_der_berechnung\n\n[1] 2",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#coding-best-practices",
    "href": "03-coding-basics.html#coding-best-practices",
    "title": "\n3  Coding basics\n",
    "section": "\n3.4 Coding best practices",
    "text": "3.4 Coding best practices\nBevor wir uns vertieft mit der Syntax (Grammatik) von R beschäftigen, besprechen wir ein paar “best practices” die das Programmieren in R langfristig erleichtern.\n\n3.4.1 Sinnvolle Variablennamen\nDurch das Ausführen verschiedener Berechnungen werden wir schnell mehrere Objekte/Variablen in der “Environment” haben. Damit wir da nicht den Überblick verlieren, ist es wichtig, diese Objekte sinnvoll zu benennen. Sinnvoll liegt hier im Ermessen des Programmierenden. Es gibt jedoch zwei häufig verwendete Namenskonventionen und ein paar Symbole, die nicht verwendet werden können.\nDie Namenskonvention in der Programmierung hat im Großen und Ganzen zwei große Zweige. Der eine nutzt Großbuchstaben, der andere Unterstriche. Beide sind gut, aber versuchen Sie, sie nicht zu mischen. Sie sind völlig frei, jeden Variablennamen zu verwenden, aber beachten Sie immer die drei Anforderungen:\n\nsnake_case:\n\n\nDie erste Konvention heisst snake case. Dabei trennt man Wörter in Variablennamen mit einem Unterstrich _.\n\n\nCamelCase:\n\n\nDie zweite Konvention heisst camel case. Dabei werden Wörter durch Grossbuchstaben getrennt.\n\nSnake Case wird etwas häufiger verwendet und ist meiner Meinung nach besser lesbar, deshalb verwenden wir in diesem Skript diese Namenskonvention. Einige Zeichen dürfen/können nicht für Objektnamen verwendet werden (-,.,!~=&^%$). Zudem dürfen Objektnamen nicht mit Zahlen beginnen. Darüber hinaus sind der Fantasie keine Grenzen gesetzt. Kürzere Objektnamen sind jedoch zu bevorzugen. Obwohl wohl jedem klar wird, was in dem Objekt mit dem Namen das_resultat_der_ersten_regression_meiner_bachelorarbeit gespeichert wird, ist der Name wohl etwas zu lange. Was wäre ein guter, aber kürzerer, Name?\n\n\n\n\nBeispiel eines schlechten Objektnamens.\n\n\n\n\n3.4.2 Kommentare\nDas Kommentieren des geschriebenen Codes ist fast genau so wichtig wie der Code selbst. Zeilen, die mit dem #-Zeichen beginnen, werden von R als Kommentar erkannt und nicht ausgeführt:\n\n#das ist ein Kommentar\nprint(\"Das ist kein Kommentar\")\n\n[1] \"Das ist kein Kommentar\"\n\n\nDas Kommentieren hat zwei Zwecke:\n\nJemand anderem (oder dem zukünftigen Ich!) mitteilen, was der Befehl in der nächsten Zeile tut (oder tun soll…)\n“In-progress” Code oder alten Code auskommentieren, damit er nicht ausgeführt wird, jedoch noch ersichtlich ist. Um Code auszukommentieren kan man die Tastenkombination cmd+shift+c (Mac) oder ctrl+shift+c (Windows) verwenden. Markiert man dabei mehrere Zeilen, werden alle markierten Zeilen auskommentiert.\n\nTipp:: je länger man schon programmiert, desto eher vergisst man mal, den geschriebenen Code zu kommentieren. Dies liegt unter anderem daran, dass man den Code schneller lesen kann/versteht. Trotzdem ist es eine gute Gewohnheit, Code kontinuierlich zu kommentieren. Dies weiss auch ChatGPT:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#platzierung-und-formatierung-des-codes",
    "href": "03-coding-basics.html#platzierung-und-formatierung-des-codes",
    "title": "\n3  Coding basics\n",
    "section": "\n3.5 Platzierung und Formatierung des Codes",
    "text": "3.5 Platzierung und Formatierung des Codes\nUm Code lesbarer zu machen, gibt es sogenannte Style-guides die vorschreiben, wie man code strukturieren und formattieren soll.\nWir wollen hier nur zwei Grundsätze nennen:\n\nAbstände verwenden\n\n\n#schlecht\na&lt;-1\n\n#gut \na &lt;- 1\n\n\nLängere codes/Skripte in Codeblöcke unterteilen, die durch Absätze getrennt sind",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#r-objekte",
    "href": "03-coding-basics.html#r-objekte",
    "title": "\n3  Coding basics\n",
    "section": "\n3.6 R-Objekte",
    "text": "3.6 R-Objekte\nOben haben wir bereits ein R-Objekt erstellt, message_world, eine Variable mit einem einzelnen Wert, die ein Zeichen-R-Objekt enthielt. Objekte können verschiedene Werte enthalten. Hier ein paar Beispiele von solchen Werten, die zu unterschiedlichen Objektclassen führen:\nR-Objekte:\n\n\nZeichen (character) - auch bekannt als ‘string’. Jede Variable, die Buchstaben, Sonderzeichen oder Zahlen zwischen ’’ oder “” enthält. Wenn Sie ein Zeichen erstellen, entscheiden Sie, ob Sie ’ oder ” verwenden und verwenden Sie sie konsistent.\n\nnumerisch - jeder numerische Wert wird im Allgemeinen als ‘double’ bezeichnet.\n\ninteger - Ganzzahl. Ein zusätzliches ‘L’ wird neben dem Wert im ‘Environment’ Fenster angezeigt, um zu zeigen, dass es sich um einen Integer und nicht um einen numerischen (‘double’) Wert handelt.\n\nlogisch - hat nur zwei Werte: TRUE oder FALSE, möglicherweise nachdem eine Aussage ausgeführt und als wahr oder falsch bewertet wurde\n\nFaktor - spezielles R-Objekt, das wir in späteren Vorlesungen besprechen werden.\n\nWir können den Typ eines Objektes mit der Funktion typeofermitteln:\n\n#Zeichen \ncharacter_object &lt;- \"hello\"\nclass(character_object)\n\n[1] \"character\"\n\n\n\n#numerisch \ndouble_object &lt;- 1.3\nclass(double_object)\n\n[1] \"numeric\"\n\n\n\n#integer \ninteger_object &lt;- 1L\nclass(integer_object)\n\n[1] \"integer\"\n\n\n\n#Faktor\nfactor_object &lt;- factor(c(1 ,2, 3), levels = c(\"low\", \"medium\", \"high\"))\nclass(factor_object)\n\n[1] \"factor\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#operationen-mit-numerischen-werten",
    "href": "03-coding-basics.html#operationen-mit-numerischen-werten",
    "title": "\n3  Coding basics\n",
    "section": "\n3.7 Operationen mit numerischen Werten",
    "text": "3.7 Operationen mit numerischen Werten\nMan kann numerische Variablen ähnlich wie Zeichenwerte definieren:\n\na &lt;- 2\nb &lt;- 3\n\nJetzt können wir anstelle der Zahlen 2 und 3 a und b verwenden, wenn wir mathematische Operationen durchführen:\n\na + b\n\n[1] 5\n\n\n\na+b-(a*b)^a\n\n[1] -31\n\n\nWir können neue Variablen erstellen, die durch bereits vorhandene Variablen definiert sind:\n\nc &lt;- a + b\nd &lt;- a*c/b*c",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#operationen-mit-logischen-werten",
    "href": "03-coding-basics.html#operationen-mit-logischen-werten",
    "title": "\n3  Coding basics\n",
    "section": "\n3.8 Operationen mit logischen Werten",
    "text": "3.8 Operationen mit logischen Werten\nLogische Operatoren kann man verwenden um zu prüfen, ob zwei Werte/Objekte identisch sind oder nicht.\nÜberprüfen, ob Werte gleich sind, mit dem == Befehl\n\n6 == 12\n\n[1] FALSE\n\n\nÜberprüfen, ob zwei Variablen/Objekte identisch sind,\n\na == b\n\n[1] FALSE\n\n\nÜberprüfen, ob eine modifizierte Variable gleich der anderen ist,\n\n(a + 1) == b\n\n[1] TRUE\n\n\nMan kann auch überprüfen, ob die zwei Variablen nicht gleich sind, mit dem != Befehl:\n\na != b\n\n[1] TRUE\n\n\nEs ist auch möglich, komplexere Vergleiche mit mehreren Aussagen zu machen. Z.B. können wir vergleichen, ob 2==2 und 3==2 mit dem & Operator:\n\n2 == 2 & 3 == 2\n\n[1] FALSE\n\n\noder, ob 2==2 oder 3==2 mit dem | Operator\n\n2 == 2 | 3 == 2\n\n[1] TRUE\n\n\nHinweis: Später werden wir den Unterschied zwischen &, | und &&, || Operatoren besprechen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#operationen-mit-r-objekten",
    "href": "03-coding-basics.html#operationen-mit-r-objekten",
    "title": "\n3  Coding basics\n",
    "section": "\n3.9 Operationen mit R-Objekten",
    "text": "3.9 Operationen mit R-Objekten\nIm Allgemeinen haben unterschiedliche R-Objekte unterschiedliche Grundoperationen. Die wichtigsten Grundoperationen sind die zuvor erwähnten numerischen und logischen Operationen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#einfache-funktionen",
    "href": "03-coding-basics.html#einfache-funktionen",
    "title": "\n3  Coding basics\n",
    "section": "\n3.10 Einfache Funktionen",
    "text": "3.10 Einfache Funktionen\nWir brauchen R natürlich nicht, um einfache Berechnungen wie oben aufgeführt durchzuführen, sondern um etwas komplexere Berechnungen wie zum Beispiel Regressionen durchzuführen. Hier kommen Funktionen ins Spiel. Funktionen haben einen oder mehrere Inputs, stellen mit diesem Input etwas an, und ergeben dann einen Output.\nBis jetzt haben wir schon einige Funktionen gesehen, auch einfache Berechnungen wie 2 + 3 basieren auf der + Funktion. In der Regel sind Funktionen aber etwas komplexer, indem sie eine Reihe von Berechnungen bündeln. Funktionen sind durch ihren Namen definiert und wie folgt aufgebaut:\nname(input)\nwobei name der Name der Funktion ist, der R mitteilt, welche Funktion (sprich Berechnung) mit dem Input ausgeführt werden soll. Funktionen verwenden immer ( und ) Klammern, und innerhalb der Klammern müssen Sie den Input definieren, die von der Funktion abhängt. Auch die + Funktion kann in diesem Format verwendet werden:\n\n`+`(2, 3)\n\n[1] 5\n\n\nEin Beispiel für eine etwas komlexere Funktion ist die Funktion mean, die den Mittelwert berechnet:\n\nmean(c(2,3))\n\n[1] 2.5\n\n\nDieses Beispiel zeigt auch, dass Funktionen genestet werden können. Dann werden, genau wie in der Mathematik, die Funktionen von innne nach aussen ausgeführt. Um R Code lesbarer zu machen, sollte man genestete Funktionen wenn möglich vermeiden. So kann man en obigen Code auch so schreiben:\n\nnumeric_vector &lt;- c(2, 3)\nmean(numeric_vector)\n\n[1] 2.5\n\n\nSo haben wir die beiden Funktionen voneinander getrennt und den Code so lesbarer gemacht. Wenn wir mehr über eine Funktion erfahren möchten, können wir das mit dem ? Symbol tun, also ?name:\n\n#?mean\n\nDadurch wird das Hilfefenster aufgerufen, wo wir mehr über die Funktion erfahren (erwartete Inputs, Argumente, Output). Die Hilfeseite der Funktion meansieht wie folgt aus:\n\n\n\n\n\n\n\n\nDiese Hilfeseiten sehen zu Beginn etwas kryptisch aus, enthalten aber fast alles, was es über eine Funktion zu wissen gilt. Besonders wichtig ist der Abschnitt Arguments. Dort werden alle Inputs gelistet, die eine Funktion erwartet.\nWir sehen, dass das erste Argument der Funktion mean x heisst und einen Vektor erwartet. Generell ist es eine gute Konvention, Inputs mit Namen den entsprechenden Argumenten zuzuweisen, also\n\nmean(x = numeric_vector)\n\n[1] 2.5\n\n\nDies ist jedoch nicht zwingend. Wenn wir die Namen weglasssen, werden die Inputs der Reihe nach den entsprechenden Argumenten zugewiesen. Deshalb funktioniert auch die Schreibweise mean(numeric_vector). Bei Funktionen, die häufig verwendet werden und (oft) nur einen Input brauchen, wird der Name des Arguments auch häufig weggelassen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#variablen-kombinieren-mehrerer-r-objekte-in-einer-variable",
    "href": "03-coding-basics.html#variablen-kombinieren-mehrerer-r-objekte-in-einer-variable",
    "title": "\n3  Coding basics\n",
    "section": "\n3.11 Variablen: Kombinieren mehrerer R-Objekte in einer Variable",
    "text": "3.11 Variablen: Kombinieren mehrerer R-Objekte in einer Variable\nDurch die Verwendung einer einfachen, aber sehr wichtigen, Basisfunktion können wir mehrere numerische Werte zu einem Vektor zusammenfassen. Wir haben diese Funktion bereits bei der Berechnung des Mittelwerts oben verwendet, nämlich die c()Funktion.\n\nv &lt;- c(2,5,10)\nz &lt;- c(3,4,7)\n\nJetzt haben wir zwei Vektoren, die wir verwenden können, um verschiedene Vektoroperationen durchzuführen, wie Addition, Multiplikation usw.\n\nv + z\n\n[1]  5  9 17\n\n\nIn diesem Kontext ermöglicht uns die Vektorisierung, Operationen alle Elemente der Vektoren gleichzeitig auszuführen, anstatt einzelne Elemente in einer Schleife zu bearbeiten. Diese Methode ist nicht nur effizienter, sondern auch einfacher zu schreiben und zu lesen.\nWenn wir also wie oben zwei Vektoren in R haben und eine Operation wie Addition ausführen, führt R die Addition elementweise durch. Das bedeutet, dass jedes Element des Vektors v mit dem entsprechenden Element des Vektors z addiert wird. Das Ergebnis ist ein neuer Vektor, dessen Elemente die Summen der entsprechenden Elemente von v und z sind.\nDiese Art der Vektorisierung ist besonders mächtig, da sie es uns erlaubt, komplexe Berechnungen mit sehr wenig Code effizient durchzuführen. Im Gegensatz zu Schleifen (“Loops”), die in vielen anderen Programmiersprachen verwendet werden, kann die Vektorisierung Code vereinfachen und beschleunigen, indem sie interne Optimierungen von R nutzt.\nWenn wir die Vektorisierung verwenden (was R autmomatisch tut) müssen wir schauen, dass die Inputs die Selbe Länge haben. Dies können wir mit der length()Funktion überprüfen:\n\nlength(v)\n\n[1] 3\n\n\n\nlength(v) == length(z)\n\n[1] TRUE\n\n\nVerwenden wir die Vektorisierung, obwhol die beiden Elemente nicht die selbe Länge haben, werden wir von R gewarnt:\n\nb &lt;- c(1, 2)\n\nb + z\n\nWarning in b + z: longer object length is not a multiple of shorter object\nlength\n\n\n[1] 4 6 8\n\n\nR wendet in diesem Fall trotzdem Vektorisierung an, recycelt aber den kürzeren Vektor. Es finden also folgende (elementenweisen) Berechnungen statt: 1 + 3, 2 + 4, und 1 + 7. Der kürzere Vektor wird also recycelt (das erste Elemnt von bwird zwei mal verwendet). Hat der kürzere Vektor eine Länge von 1, werden wir hingegen nicht gewarnt:\n\nc(2) * z\n\n[1]  6  8 14\n\n\nNebenbemerkung: die c() Funktion kann auch verwendet werden, um Vektoren zu verbinden:\n\nw &lt;- c(v,z)\nw\n\n[1]  2  5 10  3  4  7\n\n\n\nlength(w)\n\n[1] 6",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#indizierung",
    "href": "03-coding-basics.html#indizierung",
    "title": "\n3  Coding basics\n",
    "section": "\n3.12 Indizierung",
    "text": "3.12 Indizierung\nOft werden wir in R mit Ojekten/Daten arbeiten, die deutlich grösser/länger sind als die, die wir bis jetzt verwendet haben. Oft wollen wir dabei aber Berechnungen durchführen, die nur einen Teil der Daten betreffen. Zum Beispiel den Mittelwert für eine Variable getrennt nach dem Geschlecht der ProbandInnen. Dabei kommt die sogenannte Indizierung ins Spiel.\nDurch Indizierung können wir bestimmte Teile eines Vektors auswählen. Dies tun wir mit eckigen Klammern []. So können wir zum Beispiel das erste Element eines Vektors auswählen:\n\nv[1]\n\n[1] 2\n\n\noder das erste und das dritte:\n\nv[c(1, 3)]\n\n[1]  2 10\n\n\nWenn wir längere Vektoren haben, hilft die : Funktion bei der Auswahl. Die :Funktion generiert ein Intervall von Ganzzahlen:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nSo können wir zum Beispiel die Elemente 2 bis 3 auswählen:\n\nv[2:3]\n\n[1]  5 10\n\n\nDie Indizierung ist sehr wichtig uns wird uns noch häufiger begegnen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#spezielle-variablenwerte",
    "href": "03-coding-basics.html#spezielle-variablenwerte",
    "title": "\n3  Coding basics\n",
    "section": "\n3.13 Spezielle Variablen/Werte",
    "text": "3.13 Spezielle Variablen/Werte\n\n3.13.1 Leere Variable\nEs gibt einen Nullvektor oder eine leere Variable, die nichts enthält. Später werden wir sehen, dass dies nützlich ist für die Programmierung von Loops.\n\nnull_vector &lt;- c()\nnull_vector\n\nNULL\n\n\n\n3.13.2 NA- oder NaN-Wert\nWenn ein Wert fehlt oder unbekannt ist, wird er normalerweise als NA oder NaN gekennzeichnet. NA steht für unbekannten Wert, während NaN für „Not-a-Number“ steht, speziell für fehlende numerische Werte entworfen. In der Praxis sind sie auf unserem Niveau jedoch im Wesentlichen gleich, und wir werden eher NA verwenden.\nDer Umgang mit NA-Werten ist ziemlich gleich: sie reagieren nicht auf Operationen und bleiben NAs:\n\nna_vec &lt;- c(NA,1,2,3,4)\nna_vec + 3\n\n[1] NA  4  5  6  7\n\n\nIn anderen Fällen können fehlende Werte jedoch tükisch sein, zum Beispiel beim Berechnen des Mittelwertes:\n\nmean(na_vec)\n\n[1] NA\n\n\nDer Mittelwert ist in diesem Fall nicht definiert, weil wir den Wert einer Zahl nicht wissen.\n\n3.13.3 Inf-Wert\nIn R steht Inf für ‚Unendlich‘, was sich von NA unterscheidet, da es für eine sehr große Zahl steht. Es wird normalerweise angetroffen, wenn eine mathematische Operation keinen Wert hat, aber im Grenzfall gegen Unendlich konvergiert, wie zum Beispiel:\n\n5/0\n\n[1] Inf\n\n\nSie können auch eine Variable definieren, die einen unendlichen Wert hat, und Operationen damit durchführen,\n\ninf_val &lt;- Inf\ninf_val*-1\n\n[1] -Inf\n\n\n\ninf_val*3\n\n[1] Inf\n\n\n\n3.13.4 Gut zu wissen: Rundungsgenauigkeit in R\nAuch wenn R ein sehr mächtiger Taschenrechner ist, hat er auch seine Limitationen. So kann R die Genauigkeit von Zahlen nur bis zu einem gewissen Grad räpresentieren. Dies kann dann zu kleinen Ungenauigkeiten und verblüffenden Ergebnissen führen:\n\nsqrt(2)^2 == 2\n\n[1] FALSE\n\n\nWir können die Berechnungen mit der round Funktion runden um zu schauen, wie genau R die Zahlen repräsentiert. Runden wir die Zahlen auf 14 Nachkommastellen, erhalten wir das erwartete Resultat:\n\nround(sqrt(2)^2, 14) == round(2, 14)\n\n[1] TRUE\n\n\nJedoch nicht mehr, wenn wir auf 15 Nachkommastellen runden:\n\nround(sqrt(2)^2, 15) == round(2, 15)\n\n[1] FALSE\n\n\nFür Forschung wie wir sie in den Sozialwissenschaften betreiben reicht dies jedoch mehr als aus.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "03-coding-basics.html#variablentypen",
    "href": "03-coding-basics.html#variablentypen",
    "title": "\n3  Coding basics\n",
    "section": "\n3.14 Variablentypen",
    "text": "3.14 Variablentypen\nWir haben nun schon einige Variablentypen gesehen (z.B. Vektoren). Hier eine kurze Übersicht von weiteren, häufig verwendeten Typen:\n\nVektoren: enthalten nur dieselben R-Objekte (Werte) in einem eindimensionalen Vektor\nListen: können unterschiedliche R-Objekte als Elemente mischen\nMatrizen: enthalten dieselben R-Objekte (Werte) in einer zweidimensionalen Matrix\nArrays: ermöglichen mehrdimensionale Matrizen\nFaktoren: ein spezieller Vektor, der kategoriale oder ordinale Werte enthält. Wir werden diese in späteren Klassen sehen\nDataframe: enthalten Daten, im Grunde eine flexible Matrix, die unterschiedliche Vektoren mit unterschiedlichen R-Objekten enthalten kann und organisiert ist, als hätte sie Variablen und Beobachtungen. Wir werden dies im nächsten Kapitel genauer besprechen.\n\n\n3.14.1 Vektoren\nWir haben bereits numerische Vektoren erstellt. Nur der Vollständigkeit halber können wir auch Zeichen- und logische Vektoren erstellen:\n\nchar_vec &lt;- c('a','b','banana','I love R')\nlog_vec &lt;- c(TRUE,FALSE,T,NA,F)\n\nZu tun: Versuchen Sie, unterschiedliche R-Objekttypen in einem Vektor zu mischen! Was passiert? Spielen Sie mit verschiedenen Typen und überprüfen Sie mit der Funktion typeof!\n\n3.14.2 Listen\nListen sind sehr nützlich, um unterschiedliche Typen von R-Objekten zu kombinieren. Diese werden über die Funktion list() erstellt:\n\nmy_list &lt;- list('a',2,0==1)\nmy_list\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] FALSE\n\n\nwobei my_list diese unterschiedlichen Typen kombiniert. Wenn man aufpasst, ist leicht zu erkennen, dass die Ausgabe anders ist als bei einem einfachen Vektor. Tatsächlich ist sie so strukturiert, dass sie 3 Elemente hat und innerhalb jedes Elements ein R-Objekt oder möglicherweise ein Vektor ist:\n\nmy_list2 &lt;- list(c('a','b'),c(1,2,3),sqrt(2)^2==2)\nmy_list2\n\n[[1]]\n[1] \"a\" \"b\"\n\n[[2]]\n[1] 1 2 3\n\n[[3]]\n[1] FALSE\n\n\nmy_list2 zeigt, dass Listen im Wesentlichen unterschiedliche Vektoren in ihren Elementen speichern, und diese Vektoren müssen die gleichen R-Objektwerte in ihnen haben, aber die Länge kann unterschiedlich sein.\nDa Listen auf diese Weise erstellt werden, unterscheidet sich die Indizierung ein wenig. Sie können die unterschiedlichen Elemente ähnlich wie bei den Vektoren auswählen:\n\nmy_list2[1]\n\n[[1]]\n[1] \"a\" \"b\"\n\n\nund das ausgewählte Element wird immer noch ein Listentyp sein. Wenn Sie den Vektor aus diesem bestimmten Element haben möchten, müssen Sie doppelte Klammern verwenden:\n\nmy_list2[[1]]\n\n[1] \"a\" \"b\"\n\n\nund schließlich können Sie bestimmte Elemente aus dem Vektor, den Sie ausgewählt haben, auf folgende Weise erhalten:\n\nmy_list2[[1]][2]\n\n[1] \"b\"\n\n\nDiese Art der Indizierung wird praktisch sein, wenn man mit Listen arbeitet und auch hilft, besser zu verstehen, wie man mit Datentypen von Datenrahmen arbeitet.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Coding basics</span>"
    ]
  },
  {
    "objectID": "04-import-export.html",
    "href": "04-import-export.html",
    "title": "4  Daten Import und Export in R",
    "section": "",
    "text": "4.1 Daten importieren\nZum Importieren von Daten in R gibt es verschiedene Methoden, die je nach Quelle und Dateityp variieren können. Wir werden drei häufige Ansätze betrachten:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten Import und Export in R</span>"
    ]
  },
  {
    "objectID": "04-import-export.html#daten-importieren",
    "href": "04-import-export.html#daten-importieren",
    "title": "4  Daten Import und Export in R",
    "section": "",
    "text": "4.1.1 Import durch Klicken\nIn RStudio können Sie Daten einfach durch Klicken importieren, via Datei -&gt; Import Dataset -&gt; From Text (readr). Dies ist besonders nützlich für Anfänger oder wenn Sie schnell eine Datei ohne vorherige Skripterstellung laden möchten.\nBeachten Sie: - Durch diese Methode wird der entsprechende Code in der Konsole angezeigt. Dies ist hilfreich, um den genutzten Befehl zu lernen und bei Bedarf anzupassen.\n\n4.1.2 Import durch Pfadangabe\nDie oben genannt Methode hat einen erheblichen Nachteil: sie ist durch andere nicht reporduzierbar. Wie schon gesagt ist ein grosser Vorteil von R, dass die Analysen durch das Ausführen gesamter Skripte reproduzierbar sind. Erfordert ein Skript menschlichen Input (Auswahl der Datei via Menü) ist es nicht mehr 100% reproduzierbar. Deshalb verwenden wir diese Mehtode nur zu Beginn. Besser ist es, die Daten via Pfadangabe einzulesen. Anstatt die Datei manuell auszuwählen, spezifizieren wir dabei den Pfad der Datei (also der Ort auf dem Computer, wo sich die Datei befindet).\nUnd nun zahlt es sich aus, dass wir im ersten Kapitel ein Projekt und eine Ordnerstruktur erstellt haben. Dies vereinfacht nämlich die Arbeit mit externen Daten und deren Pfaden enorm. Der Grund dafür ist, dass R nun bei der Angabe von Pfaden bereits im Projektordner “sucht”. Dies können wir verifizieren, indem wir uns das Arbeitsverzeichnis (working directory) von R anzeigen lassen:\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\n\ngetwd()\n\n[1] \"/Users/meidom02/Dropbox/Uni/Psychologie/PhD/Teaching/Data Analysis Introduction/data_analysis_quarto\"\n\n\nDas heisst, dass wir nicht den ganzen Pfad zu einer Datei, also zum Beispiel \"/Users/dominik/Dropbox/Uni/Psychologie/PhD/Teaching/Data Analysis Introduction/book/data/test_data.csv\" angeben müssen, sondern nur den letzten Teil, data/test_data.csv.\nWenn sich die Datei test_data.csv also innerhlab ihres Projektordners in einem Ordner Namens data befinden würde, könnten sie die Datei folgendermassen einlesen:\n\nlibrary(tidyverse)\n\ndf_0 &lt;- read_csv('data/test_data.csv')\n\nDaten werden häufig im sogenannten csv Format abgespeichert, dies steht für “comma-separated values”. CSV Dateien sind Textdateien, bei denen Spalten durch Kommas getrennt werden.\n\n4.1.3 Import über URL\nDer Import über eine URL ist effizient, wenn Daten regelmäßig aktualisiert werden oder sehr groß sind. Beispiel:\n\ndf &lt;- read_csv(\"https://github.com/tidyverse/readr/raw/main/inst/extdata/mtcars.csv\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten Import und Export in R</span>"
    ]
  },
  {
    "objectID": "04-import-export.html#daten-prüfen",
    "href": "04-import-export.html#daten-prüfen",
    "title": "4  Daten Import und Export in R",
    "section": "\n4.2 Daten prüfen",
    "text": "4.2 Daten prüfen\nNach dem Import ist es wichtig, die Daten zu prüfen, um ein Verständnis für die Struktur und mögliche Probleme zu entwickeln: - glimpse(df) zeigt die Struktur der Daten, wir sehen alle Spalten und die Klasse der Variablen (in diesem Fall alles double)\n\nglimpse(df)\n\nRows: 32\nColumns: 11\n$ mpg  &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…\n$ cyl  &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…\n$ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…\n$ hp   &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…\n$ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…\n$ wt   &lt;dbl&gt; 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…\n$ qsec &lt;dbl&gt; 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…\n$ vs   &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…\n$ am   &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…\n$ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…\n$ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…\n\n\n\n\nhead(df) zeigt die ersten Zeilen.\n\n\nhead(df)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\nMazda RX4\n21.0\n6\n160\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\nMazda RX4 Wag\n21.0\n6\n160\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\nDatsun 710\n22.8\n4\n108\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\nHornet 4 Drive\n21.4\n6\n258\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\nHornet Sportabout\n18.7\n8\n360\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\nValiant\n18.1\n6\n225\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\n\n\n\n\n\n\nsummary(df) liefert eine Zusammenfassung der Daten.\n\n\nsummary(df)\n\n      mpg             cyl             disp             hp       \n Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n      drat             wt             qsec             vs        \n Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n       am              gear            carb      \n Min.   :0.0000   Min.   :3.000   Min.   :1.000  \n 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000  \n Median :0.0000   Median :4.000   Median :2.000  \n Mean   :0.4062   Mean   :3.688   Mean   :2.812  \n 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  \n Max.   :1.0000   Max.   :5.000   Max.   :8.000",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten Import und Export in R</span>"
    ]
  },
  {
    "objectID": "04-import-export.html#daten-exportieren",
    "href": "04-import-export.html#daten-exportieren",
    "title": "4  Daten Import und Export in R",
    "section": "\n4.3 Daten exportieren",
    "text": "4.3 Daten exportieren\nNach einer Analyse möchten wir Daten oft exporiteren. Dies erfolgt ähnlich wie das Importieren.\n\n4.3.1 Export als CSV\n\nwrite_csv(df, 'pfad/zum/speichern/my_data.csv')\n\n\n4.3.2 Export als XLSX\nNach Installation von writexl:\n\n#install.packages(\"writexl\")\nlibrary(writexl)\nwrite_xlsx(df, 'pfad/zum/speichern/my_data.xlsx')\n\n\n4.3.3 Export als RData\nFür R-spezifische Datenformate:\n\nsave(df, file = 'pfad/zum/speichern/my_data.RData')",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten Import und Export in R</span>"
    ]
  },
  {
    "objectID": "04-import-export.html#aufgaben",
    "href": "04-import-export.html#aufgaben",
    "title": "4  Daten Import und Export in R",
    "section": "\n4.4 Aufgaben",
    "text": "4.4 Aufgaben\n\nLaden Sie die hotelbookingdata.csv von ADAM herunter und importieren Sie sie in R. Eine Beschreibung des Datensatzes finden Sie hier\n\nExportieren Sie die Daten als XLSX und RData.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten Import und Export in R</span>"
    ]
  },
  {
    "objectID": "05-tibbles.html",
    "href": "05-tibbles.html",
    "title": "\n5  Einführung in Tibbles\n",
    "section": "",
    "text": "5.1 Tibbles als Datentyp\nTibbles sind ein Objekttyp in R, entwickelt, um mit dem Tidyverse kompatibel zu sein. Im Gegensatz zu traditionellen Dataframes bieten Tibbles eine vereinfachte, aber robustere Datenmanipulation, was sie ideal für Datenanalyse macht.\nTibbles sind eine moderne Variante von dataframes. Dataframes sind Teil der “Grundausstattung” von R (auch häufig “base-R” genannt). Einfach gesagt sind Dataframes nichts anderes als eine Sammlung von (identisch langen) Vektoren. Dataframes kann man wie folgt erstellen:\ndf_base_r &lt;- data.frame(\n  id = c(1,2,3,4,5,6),\n  age = c(25,30,33,NA,26,38),\n  grade = c('A','A+','B','B-','B+','A')\n)\n\nhead(df_base_r)\n\n\n\n\nid\nage\ngrade\n\n\n\n1\n25\nA\n\n\n2\n30\nA+\n\n\n3\n33\nB\n\n\n4\nNA\nB-\n\n\n5\n26\nB+\n\n\n6\n38\nA\nFür die Erstellung eines Tibbles verwendet man anstatt der Funktion data.frame die Funktion tibble:\n# Tibble erstellen\ndf &lt;- tibble(\n  id = c(1, 2, 3, 4, 5, 6),\n  age = c(25, 30, 33, NA, 26, 38),\n  grade = c('A', 'A+', 'B', 'B-', 'B+', 'A')\n)\n\n# Daten überprüfen\nhead(df)\n\n\n\n\nid\nage\ngrade\n\n\n\n1\n25\nA\n\n\n2\n30\nA+\n\n\n3\n33\nB\n\n\n4\nNA\nB-\n\n\n5\n26\nB+\n\n\n6\n38\nA",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Einführung in Tibbles</span>"
    ]
  },
  {
    "objectID": "05-tibbles.html#indexierung-im-allgemeinen",
    "href": "05-tibbles.html#indexierung-im-allgemeinen",
    "title": "\n5  Einführung in Tibbles\n",
    "section": "\n5.2 Indexierung im Allgemeinen",
    "text": "5.2 Indexierung im Allgemeinen\n\n5.2.1 Indexierung mit Ganzzahlen\nMan kann bestimmte Elemente auswählen, indem man Ganzzahlen verwendet.\n\n# Erste Spalte als Tibble-Variable\ndf[1]\n\n# Erste Spalte alle Beobachtungen\ndf[, 1]\n\n# Zweite Zeile\ndf[2, ]\n\n# Spezifische Zelle (2. Beobachtung, 1. Variable)\ndf[2, 1]\n\n# Mehrere Zeilen für mehrere Variablen\ndf[1:3, c(1, 3)]\n\n\n\n\nid\n\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n\n\n\n\n\nid\n\n\n\n1\n\n\n2\n\n\n3\n\n\n4\n\n\n5\n\n\n6\n\n\n\n\n\n\n\nid\nage\ngrade\n\n\n2\n30\nA+\n\n\n\n\n\n\nid\n\n\n2\n\n\n\n\n\n\nid\ngrade\n\n\n\n1\nA\n\n\n2\nA+\n\n\n3\nB\n\n\n\n\n\n\n\n5.2.2 Indexierung mit logischen Werten\nMan kann einen logischen Vektor anstelle der Ganzzahlen-Indexierung verwenden, um bestimmte Elemente zu filtern.\n\n# Alter der Beobachtung mit id == 3\ndf$age[df$id == 3]\n\n# Notenwerte für Schüler mit Alter zwischen 25 und 35\ndf$grade[df$age &gt;= 25 & df$age &lt; 35]\n\n[1] 33\n[1] \"A\"  \"A+\" \"B\"  NA   \"B+\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Einführung in Tibbles</span>"
    ]
  },
  {
    "objectID": "05-tibbles.html#einfache-funktionen",
    "href": "05-tibbles.html#einfache-funktionen",
    "title": "\n5  Einführung in Tibbles\n",
    "section": "\n5.3 Einfache Funktionen",
    "text": "5.3 Einfache Funktionen\nOft will man bestimmte Eigenschaften der Daten ermitteln. Funktionen wie sum(), mean() und sd() sind hierbei nützlich. Im Verlaufe des Semesters werden wir noch mehr solche Funktionen kennenlernen.\n\n# Summe des Alters\nmean(df$age)\n\n[1] NA\n\n\nWie wir oben gesehen haben, enthält die Variable age fehlende Werte. Um den Mittelwert der nicht fehlenden Werte zu berechnen, müssen wir deshalb das Argument na.rm = TRUE hinzufügen:\n\n# Mittelwert des Alters\nmean(df$age, na.rm = TRUE)\n\n# Summe des Alters\nsum(df$age, na.rm = TRUE)\n\n# Standardabweichung des Alters\nsd(df$age, na.rm = TRUE)\n\n[1] 30.4\n[1] 152\n[1] 5.319774",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Einführung in Tibbles</span>"
    ]
  },
  {
    "objectID": "05-tibbles.html#werte-zurücksetzen-neue-spalten-oder-zeilen-hinzufügen",
    "href": "05-tibbles.html#werte-zurücksetzen-neue-spalten-oder-zeilen-hinzufügen",
    "title": "\n5  Einführung in Tibbles\n",
    "section": "\n5.4 Werte zurücksetzen, neue Spalten oder Zeilen hinzufügen",
    "text": "5.4 Werte zurücksetzen, neue Spalten oder Zeilen hinzufügen\n\n5.4.1 Werte zurücksetzen\nFehler in den Daten können einfach korrigiert werden.\n\n# Setzt das Alter für id == 1 auf den Wert 40\ndf$age[df$id == 1] &lt;- 40\nprint(df)\n\n# A tibble: 6 × 3\n     id   age grade\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\n1     1    40 A    \n2     2    30 A+   \n3     3    33 B    \n4     4    NA B-   \n5     5    26 B+   \n6     6    38 A    \n\n\n\n5.4.2 Spalten hinzufügen\nNeue Variablen können auch leicht hinzugefügt werden.\n\n# Neue Variable 'gender' hinzufügen\ngender &lt;- c('F', 'F', 'M', 'M', 'M', 'F')\ndf$gender &lt;- gender\n\n# Alternativ mit add_column\ndf &lt;- add_column(df, gender_new = gender)\n\n# Variable entfernen\ndf &lt;- select(df, -gender_new)\nprint(df)\n\n# A tibble: 6 × 4\n     id   age grade gender\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1     1    40 A     F     \n2     2    30 A+    F     \n3     3    33 B     M     \n4     4    NA B-    M     \n5     5    26 B+    M     \n6     6    38 A     F     \n\n\n\n5.4.3 Zeilen hinzufügen\nNeue Beobachtungen können mit der Funktion add_row() hinzugefügt werden.\n\n# Neue Zeile hinzufügen\ndf &lt;- add_row(df, id = 7, age = 25, grade = 'C+', gender = 'M')\nprint(df)\n\n# A tibble: 7 × 4\n     id   age grade gender\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1     1    40 A     F     \n2     2    30 A+    F     \n3     3    33 B     M     \n4     4    NA B-    M     \n5     5    26 B+    M     \n6     6    38 A     F     \n7     7    25 C+    M     \n\n\nZeilen können genauso einfach entfernt werden. Dazu verwendet man häufig logische Operatoren um die entsprechenden Zeilen rauszufiltern.\n\n# Zeile entfernen\n# df$id != 7 generiert den folgenden Vektor: TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE, der die Grundlage für die Indizierung bildet\ndf_new &lt;- df[df$id != 7, ]\n\nprint(df_new)\n\n# A tibble: 6 × 4\n     id   age grade gender\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1     1    40 A     F     \n2     2    30 A+    F     \n3     3    33 B     M     \n4     4    NA B-    M     \n5     5    26 B+    M     \n6     6    38 A     F     \n\n\nMit der filter Funktion des dplyr packages geht das etwas eleganter:\n\ndf_new &lt;- df %&gt;% \n  filter(id != 7)\n\nprint(df_new)\n\n# A tibble: 6 × 4\n     id   age grade gender\n  &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; \n1     1    40 A     F     \n2     2    30 A+    F     \n3     3    33 B     M     \n4     4    NA B-    M     \n5     5    26 B+    M     \n6     6    38 A     F",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Einführung in Tibbles</span>"
    ]
  },
  {
    "objectID": "05-tibbles.html#tidy-data",
    "href": "05-tibbles.html#tidy-data",
    "title": "\n5  Einführung in Tibbles\n",
    "section": "\n5.5 Tidy Data",
    "text": "5.5 Tidy Data\nTidy Data ist ein Konzept in der Datenanalyse, das sicherstellt, dass Daten in einem klaren und konsistenten Format vorliegen. In Tidy Data hat jede Variable ihre eigene Spalte, jede Beobachtung ihre eigene Zeile und jede Art von beobachteter Einheit bildet eine Tabelle. Dies erleichtert die Manipulation, Visualisierung und Modellierung der Daten.\n\n5.5.1 Prinzipien des Tidy Data Ansatzes\n\nJede Variable hat ihre eigene Spalte.\nJede Beobachtung hat ihre eigene Zeile.\nJeder Wert hat seine eigene Zelle\n\n\n\n\n\nQuelle: https://r4ds.hadley.nz\n\n\n\n\n5.5.2 Beispiel für Tidy Data\nSchauen wir uns ein Beispiel an, um die Prinzipien von Tidy Data zu verdeutlichen:\n\n# Erstellen eines Tidy Data Tibble\ntidy_data &lt;- tibble(\n  country = c('Afghanistan', 'Brazil', 'China', 'Afghanistan', 'Brazil', 'China'),\n  year = c(1999, 1999, 1999, 2000, 2000, 2000),\n  value = c(745, 37737, 212258, 2666, 80488, 213766)\n)\n\n# Daten anzeigen\ntidy_data\n\n\n\n\ncountry\nyear\nvalue\n\n\n\nAfghanistan\n1999\n745\n\n\nBrazil\n1999\n37737\n\n\nChina\n1999\n212258\n\n\nAfghanistan\n2000\n2666\n\n\nBrazil\n2000\n80488\n\n\nChina\n2000\n213766\n\n\n\n\n\n\n\n5.5.3 Beispiel für Nicht-Tidy Data\nIm Gegensatz dazu sehen Nicht-Tidy Data oft unorganisiert aus und erschweren die Analyse. Hier ist ein Beispiel für Nicht-Tidy Data, das dem Datensatz table4a ähnelt:\n\n# Erstellen eines Nicht-Tidy Data Frames\nnon_tidy_data &lt;- tibble(\n  country = c('Afghanistan', 'Brazil', 'China'),\n  `1999` = c(745, 37737, 212258),\n  `2000` = c(2666, 80488, 213766)\n)\n\n# Daten anzeigen\nnon_tidy_data\n\n\n\n\ncountry\n1999\n2000\n\n\n\nAfghanistan\n745\n2666\n\n\nBrazil\n37737\n80488\n\n\nChina\n212258\n213766\n\n\n\n\n\n\n\n5.5.4 Umwandeln von Nicht-Tidy Data in Tidy Data\nUm Nicht-Tidy Data in Tidy Data zu konvertieren, kann man die Funktion pivot_longer() verwenden. Hier zeigen wir, wie man dies erreicht:\n\n5.5.4.1 Beispiel für Weites Format zu Langem Format\n\n# Nicht-Tidy Data in Tidy Data umwandeln (Weit zu Lang)\ntidy_from_non_tidy &lt;- pivot_longer(non_tidy_data, \n                                   cols = c(`1999`, `2000`),\n                                   names_to = \"year\",\n                                   values_to = \"value\")\n\n# Daten anzeigen\ntidy_from_non_tidy\n\n\n\n\ncountry\nyear\nvalue\n\n\n\nAfghanistan\n1999\n745\n\n\nAfghanistan\n2000\n2666\n\n\nBrazil\n1999\n37737\n\n\nBrazil\n2000\n80488\n\n\nChina\n1999\n212258\n\n\nChina\n2000\n213766\n\n\n\n\n\n\nMit diesen Prinzipien und Techniken können Sie sicherstellen, dass Ihre Daten stets im Tidy Format vorliegen, was die Datenanalyse erheblich erleichtert. Leider kommt “non-tidy data” in alle Farben und Formen. Deshalb gibt es kein einfaches Rezept, wie man von nicht-tidy zu tidy Data kommt. Wir werden aber im Verlauf des Semesters (vor allem im nächsten Kapitel) Funktionen kennenlernen, die dafür hilfreich sind.\n\n\n\n\n\n\n\n\nDurch das Verständnis dieser grundlegenden Operationen können Sie Daten in R effizient verwalten und analysieren.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Einführung in Tibbles</span>"
    ]
  },
  {
    "objectID": "06-wrangling.html",
    "href": "06-wrangling.html",
    "title": "6  Datenbereinigung",
    "section": "",
    "text": "Beabsichtigte Lernergebnisse\nLaden Sie das Daten-Transformation Cheat Sheet herunter.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenbereinigung</span>"
    ]
  },
  {
    "objectID": "06-wrangling.html#sec-ilo-wrangle",
    "href": "06-wrangling.html#sec-ilo-wrangle",
    "title": "6  Datenbereinigung",
    "section": "",
    "text": "Daten auswählen und filtern können, um Relevanz sicherzustellen\nNeue Spalten erstellen und bestehende bearbeiten können\nMit fehlenden Daten umgehen können",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenbereinigung</span>"
    ]
  },
  {
    "objectID": "06-wrangling.html#data-cleaning",
    "href": "06-wrangling.html#data-cleaning",
    "title": "6  Datenbereinigung",
    "section": "\n6.1 Data Cleaning",
    "text": "6.1 Data Cleaning\nIm letzten Kapitel haben wir das Tidy DataKonzept kennengelernt. Sind die Daten erst mal in einem tidy Format, gestaltet sich die Datenanalyse wesentlich einfacher. Leider kann es oft eine Weile dauern, bis man an diesem Punkt ankommt. Deshalb beschäftigen wir uns in diesem Kapitel mit der Datenbereinigung und Funktionen, die dabei hilfreich sind. Wir verwenden dabei vor allem die folgenden Funktionen aus dem tidyverse: select, filter, arrange, mutate, summarise und group_by.\nDiese Funktionen werden am häufigsten für die Datenreinigung verwendet. Das dplyr package aus dem tidyverse beinhaltet jedoch noch viel mehr Funktionen, die speziell für die Datenbereinigung äusserst nützlich sind. Das Daten-Transformation Cheat Sheet gibt einen guten Überblick über die wichtigsten Funktionen. Am besten laden Sie dieses dirket herunter, schauen es kurz an und halten es für den Rest des Semseters zur Hand.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenbereinigung</span>"
    ]
  },
  {
    "objectID": "06-wrangling.html#der-pipe-operator",
    "href": "06-wrangling.html#der-pipe-operator",
    "title": "6  Datenbereinigung",
    "section": "\n6.2 Der Pipe Operator",
    "text": "6.2 Der Pipe Operator\nBevor wir beginnen, schauen wir uns den Pipe Operator an: %&gt;%. Wie in der Abbildung unten dargestellt gibt der pipe Operator den Output einer Funktion an die nächste Funktion weiter, die diesen Output als ersten Input verwendet.\n\n\n\n\n\n\n\n\nDies ermöglich es, Funktionen auf einfache und leserliche Weise zu verknüpfen:\n\nmtcars %&gt;% \n  select(mpg, cyl, wt) %&gt;% \n  filter(wt &lt; 1.8)\n\n\n\n\n\nmpg\ncyl\nwt\n\n\n\nHonda Civic\n30.4\n4\n1.615\n\n\nLotus Europa\n30.4\n4\n1.513\n\n\n\n\n\n\nSomit können wir verschachtelte Funktionen vermeiden:\n\nfilter(select(mtcars, mpg, cyl, wt), wt &lt; 1.8)\n\n\n\n\n\nmpg\ncyl\nwt\n\n\n\nHonda Civic\n30.4\n4\n1.615\n\n\nLotus Europa\n30.4\n4\n1.513\n\n\n\n\n\n\nDie erste Schreibweise ist deutlich einfacher zu lesen, oder? Wie im Beispiel unten zu sehen, kommt man dadurch relativ einfach und leserlich von den Rohdaten über Datentransformationen bis hin zur Datenvisualisierung, alles in einer pipe.\n\n# Umfangreiche Pipe-Operation mit mtcars-Daten, die in einem ggplot endet\nmtcars %&gt;%\n  rownames_to_column(\"car_name\") %&gt;%   # Konvertiere Zeilennamen in eine Spalte\n  mutate(mpg_level = cut(mpg, breaks = quantile(mpg, probs = 0:4/4), include.lowest = TRUE, labels = c(\"Niedrig\", \"Mittel\", \"Hoch\", \"Sehr Hoch\"))) %&gt;%  # Erstelle MPG-Niveaus\n  group_by(mpg_level) %&gt;%  # Gruppiere nach dem neu erstellten MPG-Niveau\n  summarise(\n    avg_hp = mean(hp),  # Berechne die durchschnittliche Pferdestärke für jedes Niveau\n    avg_wt = mean(wt)   # Berechne das durchschnittliche Gewicht für jedes Niveau\n  ) %&gt;%\n  ungroup() %&gt;%  # Entferne die Gruppierung\n  ggplot(aes(x = reorder(mpg_level, avg_hp), y = avg_hp, fill = mpg_level)) +  # Erstelle ein Balkendiagramm\n    geom_col() +  # Verwende Balken zur Darstellung der Daten\n    geom_text(aes(label = round(avg_hp, 1)), vjust = -0.5) +  # Füge Textbeschriftungen über den Balken hinzu\n    labs(\n      title = \"Durchschnittliche Pferdestärke nach MPG-Niveaus\",\n      x = \"MPG-Niveau\",\n      y = \"Durchschnittliche Pferdestärke\"\n    ) +\n    theme_minimal() +  # Verwende ein minimales Thema\n    scale_fill_brewer(palette = \"Pastel1\")  # Färbe die Balken mit einer Pastellpalette\n\n\n\n\n\n\n\nFür dieses Kapitel verwenden wir einen selbst generierten Datensatz bestehend aus den Verkäufen, Ausgaben und der Zufriedenheit für zwei Jahre aus vier Regionen und zwei Produkten. Der Code der die Daten generiert stammt aus [diese] (https://psyteachr.github.io/ads-v3/04-summary.html#sec-pipes-first) Buchkapitel. Der für die Datengenerierung verwendete Code ist für sie nicht relevant.\nWie bereits besprochen lohnt es sich immer, die Daten als erstes kurz anzuschauen:\n\nbudget\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nexpenses_2019\nexpenses_2020\nsatisfaction_2019\nsatisfaction_2020\n\n\n\nNorth\nwidgets\n2129\n-517\n822\n-897\nhigh\nvery high\n\n\nNorth\ngadgets\n723\n77\n1037\n1115\nvery high\nvery high\n\n\nSouth\nwidgets\n1123\n-1450\n1004\n672\nhigh\nneutral\n\n\nSouth\ngadgets\n2022\n-945\n-610\n200\nlow\nlow\n\n\nEast\nwidgets\n-728\n-51\n-801\n-342\nvery low\nvery low\n\n\nEast\ngadgets\n-423\n-354\n94\n2036\nneutral\nhigh\n\n\nWest\nwidgets\n633\n790\n783\n-315\nneutral\nneutral\n\n\nWest\ngadgets\n1204\n426\n433\n-136\nlow\nlow\n\n\n\n\n\n\nNun können wir mit dem Data Cleaning beginnen. Oft müssen wir zuerst den Datensatz einschränken, das heisst wir beschränken uns auf bestimmte Varialben (Spalten) und Beobachtungen (Zeilen). Dafür verwenden wir die Funktionen select und filter.\n\n6.2.1 Spalten auswählen mit select\n\nMit select kann man Variablen auswählen. Dies ist nützlich, wenn wir nur einen Teil der Variablen für unsere Auswertung brauchen, was häufig der Fall ist. Es gibt verschiedene Arten, wie man das mit der select Funktion tun kann:\n\n#Spalte nach Name auswählen\nbudget %&gt;% select(product) \n\n\n\n\nproduct\n\n\n\nwidgets\n\n\ngadgets\n\n\nwidgets\n\n\ngadgets\n\n\nwidgets\n\n\ngadgets\n\n\nwidgets\n\n\ngadgets\n\n\n\n\n\n\n\n#Spalte nach Index auswählen (2. Spalte)\nbudget %&gt;% select(2) \n\n\n\n\nproduct\n\n\n\nwidgets\n\n\ngadgets\n\n\nwidgets\n\n\ngadgets\n\n\nwidgets\n\n\ngadgets\n\n\nwidgets\n\n\ngadgets\n\n\n\n\n\n\nNatürlich wollen wir oft mehr als nur eine Spalte auswählen:\n\nbudget %&gt;% select(product, sales_2019, expenses_2019) \n\n\n\n\nproduct\nsales_2019\nexpenses_2019\n\n\n\nwidgets\n2129\n822\n\n\ngadgets\n723\n1037\n\n\nwidgets\n1123\n1004\n\n\ngadgets\n2022\n-610\n\n\nwidgets\n-728\n-801\n\n\ngadgets\n-423\n94\n\n\nwidgets\n633\n783\n\n\ngadgets\n1204\n433\n\n\n\n\n\n\nUm viele Spalten auf einmal auszuwählen, ist die Doppelpunktnotation hilfreich. Dadurch werden alle Variablen die sich zwischen den beiden spezifizierten Variablen befinden ausgewählt:\n\nbudget %&gt;% \n  select(region:expenses_2020)\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nexpenses_2019\nexpenses_2020\n\n\n\nNorth\nwidgets\n2129\n-517\n822\n-897\n\n\nNorth\ngadgets\n723\n77\n1037\n1115\n\n\nSouth\nwidgets\n1123\n-1450\n1004\n672\n\n\nSouth\ngadgets\n2022\n-945\n-610\n200\n\n\nEast\nwidgets\n-728\n-51\n-801\n-342\n\n\nEast\ngadgets\n-423\n-354\n94\n2036\n\n\nWest\nwidgets\n633\n790\n783\n-315\n\n\nWest\ngadgets\n1204\n426\n433\n-136\n\n\n\n\n\n\n\n6.2.1.1 Spalten abwählen\nWenn man nur einige Spalten ausschliessen möchte kann es einfacher sein, diese abzuwählen als alle andere auszuwählen. Dies können wir tun, indem wir ein - vor die abzuwählende Variable setzen.\n\n# einzelne Spalten abwählen\nbudget %&gt;% select(-expenses_2019, -expenses_2020)\n\n# einen Bereich von Spalten abwählen\nbudget %&gt;% select(-(expenses_2019:expenses_2020))\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nsatisfaction_2019\nsatisfaction_2020\n\n\n\nNorth\nwidgets\n2129\n-517\nhigh\nvery high\n\n\nNorth\ngadgets\n723\n77\nvery high\nvery high\n\n\nSouth\nwidgets\n1123\n-1450\nhigh\nneutral\n\n\nSouth\ngadgets\n2022\n-945\nlow\nlow\n\n\nEast\nwidgets\n-728\n-51\nvery low\nvery low\n\n\nEast\ngadgets\n-423\n-354\nneutral\nhigh\n\n\nWest\nwidgets\n633\n790\nneutral\nneutral\n\n\nWest\ngadgets\n1204\n426\nlow\nlow\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nsatisfaction_2019\nsatisfaction_2020\n\n\n\nNorth\nwidgets\n2129\n-517\nhigh\nvery high\n\n\nNorth\ngadgets\n723\n77\nvery high\nvery high\n\n\nSouth\nwidgets\n1123\n-1450\nhigh\nneutral\n\n\nSouth\ngadgets\n2022\n-945\nlow\nlow\n\n\nEast\nwidgets\n-728\n-51\nvery low\nvery low\n\n\nEast\ngadgets\n-423\n-354\nneutral\nhigh\n\n\nWest\nwidgets\n633\n790\nneutral\nneutral\n\n\nWest\ngadgets\n1204\n426\nlow\nlow\n\n\n\n\n\n\n\n6.2.1.2 Hilfsfunktionen zum Auswählen\nSchließlich können Sie Spalten basierend auf Kriterien über die Spaltennamen auswählen.\n\n\n\n\n\n\nFunktion\nDefinition\n\n\n\nstarts_with()\nwähle Spalten, die mit einer Zeichenkette beginnen\n\n\nends_with()\nwähle Spalten, die mit einer Zeichenkette enden\n\n\ncontains()\nwähle Spalten, die eine Zeichenkette enthalten\n\n\nnum_range()\nwähle Spalten, deren Name dem Muster prefix entspricht\n\n\n\n6.2.2 Todo\n\n6.2.3 Filtern\nOft ist man auch nur an bestimmten Beobachtungen (Zeilen) interessiert. Diese können wir mit der filter() Funktion auswählen. Man kann dabei nach einem oder mehreren Kriterien filtern. Dabei kommen logische Operatoren, wie wir sie bereits besprochen haben, zum Einsatz. Zum Beispiel können wir nur die Beobachtungen auswählen, die aus der Region “North” kommen:\n\n# wähle alle Zeilen aus, bei denen die Region Nord entspricht\nbudget %&gt;% filter(region == \"North\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nexpenses_2019\nexpenses_2020\nsatisfaction_2019\nsatisfaction_2020\n\n\n\nNorth\nwidgets\n2129\n-517\n822\n-897\nhigh\nvery high\n\n\nNorth\ngadgets\n723\n77\n1037\n1115\nvery high\nvery high\n\n\n\n\n\n\nDie Auswahl passiert hierbei über die logische Operation region == \"North\". Dieses Statement generiert einen Vektor aus TRUE und FALSE Werten, über die die Auswahl der Zeilen stattfindet:\n\nbudget$region == \"North\"\n\n[1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nMann kann dabei verschiedene logische Operatoren verwenden:\n\n# wähle alle Zeilen aus, bei denen die Region Nord entspricht\nbudget %&gt;% filter(region == \"North\")\n\n# wähle alle Zeilen aus, bei denen die Ausgaben 2020 genau 200 betrugen\nbudget %&gt;% filter(expenses_2020 == 200)\n\n# wähle alle Zeilen aus, bei denen der Verkauf 2019 mehr als 100 betrug\nbudget %&gt;% filter(sales_2019 &gt; 100)\n\n# alles außer dem Norden\nbudget %&gt;% filter(region != \"North\")\n\n\n\n\n\n\n\nWarning\n\n\n\nDenken Sie daran, == und nicht = zu verwenden, um zu überprüfen, ob zwei Dinge gleichwertig sind. Ein einzelnes = weist den Wert rechts der Variablen links zu (ähnlich wie der Operator &lt;-).\n\n\nMan kann auch mehrere Kriterien auf einmal spezifizieren. Dies kann man auf zwei verschiedene Arten tun. Werden die Statements mit einem , oder & getrennt, werden nur die Zeilen ausgewählt, die alle Bedingungen erfüllen. So können wir zum Beispiel Zeilen auswählen, die im Jahr 2019 und 2020 ausgaben über 100 hatten:\n\nbudget %&gt;% \n  filter(\n    sales_2019 &gt; 100 & sales_2020 &gt; 100\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nexpenses_2019\nexpenses_2020\nsatisfaction_2019\nsatisfaction_2020\n\n\n\nWest\nwidgets\n633\n790\n783\n-315\nneutral\nneutral\n\n\nWest\ngadgets\n1204\n426\n433\n-136\nlow\nlow\n\n\n\n\n\n\nDies ist eine sogenannte “und” Verknüpfung. Wir können auch eine “oder” Verknüpfung verwenden, dann werden alle Zeilen ausgewählt, die mindestens eine der Bedingungen erfüllen:\n\nbudget %&gt;%\n  filter(\n    sales_2019 &gt; 100 | sales_2020 &gt; 100\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nexpenses_2019\nexpenses_2020\nsatisfaction_2019\nsatisfaction_2020\n\n\n\nNorth\nwidgets\n2129\n-517\n822\n-897\nhigh\nvery high\n\n\nNorth\ngadgets\n723\n77\n1037\n1115\nvery high\nvery high\n\n\nSouth\nwidgets\n1123\n-1450\n1004\n672\nhigh\nneutral\n\n\nSouth\ngadgets\n2022\n-945\n-610\n200\nlow\nlow\n\n\nWest\nwidgets\n633\n790\n783\n-315\nneutral\nneutral\n\n\nWest\ngadgets\n1204\n426\n433\n-136\nlow\nlow\n\n\n\n\n\n\nUm die Auswahl zu vereinfachen, wenn man nach mehreren Kriterien filtern will, gibt es den “Übereinstimmungsoperator” (%in%).\n\n# behalte alle Zeilen, bei denen die Region Nord oder Süd ist und das Produkt Widgets entspricht\nbudget %&gt;%\n  filter(region %in% c(\"North\", \"South\"),\n         product == \"widgets\")\n\nAbschliessend hier eine Übersicht mit den verschiedenen logischen Operatoren, die zum Filtern von Zeilen (Beobachtungen) verwendet werden können:\n\n\n\"Operator\"\nName\nist WAHR, wenn und nur wenn\n\n\n\nA &lt; B\nkleiner als\nA ist kleiner als B\n\n\nA &lt;= B\nkleiner oder gleich\nA ist kleiner oder gleich B\n\n\nA &gt; B\ngrößer als\nA ist größer als B\n\n\nA &gt;= B\ngrößer oder gleich\nA ist größer oder gleich B\n\n\nA == B\nÄquivalenz\nA entspricht genau B\n\n\nA != B\nnicht gleich\nA entspricht nicht genau B\n\n\nA %in% B\nin\nA ist ein Element des Vektors B\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nfilter() ist unglaublich leistungsfähig und kann Ihnen ermöglichen, sehr spezifische Teilmengen von Daten auszuwählen. Aber es ist auch ziemlich gefährlich, denn wenn Sie mehrere Kriterien und Operatoren kombinieren, ist es sehr einfach, versehentlich etwas leicht anders zu spezifizieren, als Sie beabsichtigt haben. Überprüfen Sie immer Ihre Ausgabe. Wenn Sie einen kleinen Datensatz haben, können Sie ihn visuell überprüfen, um zu sehen, ob er richtig aussieht. Bei einem größeren Datensatz möchten Sie vielleicht Zusammenfassungsstatistiken berechnen oder die Anzahl der Gruppen/Beobachtungen in jeder Variablen zählen, um zu überprüfen, ob Ihr Filter korrekt ist. Es gibt kein Expertenniveau im Codieren, das das Wissen und die Überprüfung Ihrer Daten ersetzen kann.\n\n\n\n6.2.4 Anordnen\nNachdem wir die gewünschten Spalten (select) und Zeilen (filter) ausgewählt haben, wollen wir die Daten eventuell noch sortieren. Dies kann zum Beispiel bei Paneldaten sinnvoll sein. Sortieren kann auch für die Darstellung in Tabellen hilfreich sein. Wir können Daten nach den Werten in bestimmten Spalten mit arrange sortieren:\n\n# Anordnen der Tabelle \n# zuerst nach Region in alphabetischer Reihenfolge\n# dann nach \"product\" in umgekehrter alphabetischer Reihenfolge (mit der Hilfsfunktion `desc`)\nbudget %&gt;%\n  arrange(region, desc(product))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nexpenses_2019\nexpenses_2020\nsatisfaction_2019\nsatisfaction_2020\n\n\n\nNorth\ngadgets\n723\n77\n1037\n1115\nvery high\nvery high\n\n\nNorth\nwidgets\n2129\n-517\n822\n-897\nhigh\nvery high\n\n\nSouth\ngadgets\n2022\n-945\n-610\n200\nlow\nlow\n\n\nSouth\nwidgets\n1123\n-1450\n1004\n672\nhigh\nneutral\n\n\nEast\ngadgets\n-423\n-354\n94\n2036\nneutral\nhigh\n\n\nEast\nwidgets\n-728\n-51\n-801\n-342\nvery low\nvery low\n\n\nWest\ngadgets\n1204\n426\n433\n-136\nlow\nlow\n\n\nWest\nwidgets\n633\n790\n783\n-315\nneutral\nneutral\n\n\n\n\n\n\n\n6.2.5 Mutieren\nDie Funktion mutate() ermöglicht es, neue Spalten hinzuzufügen oder bestehende zu ändern. Dies geschieht mit folgender Syntax: mutate(neue_Spalte = Berechnung). Es können auch mehrere neue Spalten in einem einzigen mutate Call generiert werden.Sobald eine neue Spalte erstellt wurde, kann diese in weiteren berechnungen innerhalb des selben mutate Calls verwendet werden. Zum Beispiel verwendet die Erstellung von profit unten die Spalte expenses, die darüber erstellt wird.\n\nbudget2 &lt;- budget %&gt;%\n  mutate(\n    sales = sales_2019 + sales_2020,\n    expenses = expenses_2019 + expenses_2020,\n    profit = sales - expenses,\n    region = paste(region, \"Office\")\n  )\n\nbudget2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nregion\nproduct\nsales_2019\nsales_2020\nexpenses_2019\nexpenses_2020\nsatisfaction_2019\nsatisfaction_2020\nsales\nexpenses\nprofit\n\n\n\nNorth Office\nwidgets\n2129\n-517\n822\n-897\nhigh\nvery high\n1612\n-75\n1687\n\n\nNorth Office\ngadgets\n723\n77\n1037\n1115\nvery high\nvery high\n800\n2152\n-1352\n\n\nSouth Office\nwidgets\n1123\n-1450\n1004\n672\nhigh\nneutral\n-327\n1676\n-2003\n\n\nSouth Office\ngadgets\n2022\n-945\n-610\n200\nlow\nlow\n1077\n-410\n1487\n\n\nEast Office\nwidgets\n-728\n-51\n-801\n-342\nvery low\nvery low\n-779\n-1143\n364\n\n\nEast Office\ngadgets\n-423\n-354\n94\n2036\nneutral\nhigh\n-777\n2130\n-2907\n\n\nWest Office\nwidgets\n633\n790\n783\n-315\nneutral\nneutral\n1423\n468\n955\n\n\nWest Office\ngadgets\n1204\n426\n433\n-136\nlow\nlow\n1630\n297\n1333\n\n\n\n\n\n\nmutate() kann auch in Verbindung mit anderen Funktionen und Logischen Operatoren verwendet werden. Zum Beispiel können wir eine weitere Spalte zu budget2 hinzufügen, die angibt, ob in diesem Jahr ein Gewinn erzielt wurde, oder unsere product-Variable als Faktor überschreiben. Genau wie bei der Verwendung von Logischen Operatoren mit filter() wird die Gleichung ausgewertet und gibt TRUE oder FALSE zurück, je nachdem, ob die Beobachtung das Kriterium erfüllt.\n\nbudget2 &lt;- budget2 %&gt;%\n  mutate(profit_category = profit &gt; 0,\n         product = as.factor(product))\n\nIst der neue Variablenname gleich wie der alte, wird die bestehende Variable überschrieben.\nIm Zusammenhang mit mutate ist case_when eine sehr nützliche Funktion, um basierend auf einer Reihe von Bedingungen (logischen Statmements) eine neue Variable zu generieren. So können wir zum Beispiel den Gewinn in mehrere Kategorien einteilen:\n\nbudget2 %&gt;%\n  mutate(profit_category = case_when(profit &lt; 0 ~ \"kein Gewinn\",\n                                     profit &gt; 100 ~ \"kleiner Gewinn\",\n                                     profit &gt; 200 ~ \"hoher Gewinn\")) %&gt;% \n  select(profit, profit_category)\n\n\n\n\nprofit\nprofit_category\n\n\n\n1687\nkleiner Gewinn\n\n\n-1352\nkein Gewinn\n\n\n-2003\nkein Gewinn\n\n\n1487\nkleiner Gewinn\n\n\n364\nkleiner Gewinn\n\n\n-2907\nkein Gewinn\n\n\n955\nkleiner Gewinn\n\n\n1333\nkleiner Gewinn\n\n\n\n\n\n\nFalls für eine Beobachtung keine der Bedingungen zutrifft, generiert die Funktion den Wert NA. Dem müssen wir uns bewusst sein und wenn möglich Bedingugen generieren, die allen Werten einen neuen Wert zuweisen. Diese Bedingungen wären in diesem Fall sinnvoller:\n\nbudget2 %&gt;%\n  mutate(profit_category = case_when(profit &lt;= 0 ~ \"kein Gewinn\",\n                                     profit &gt; 0 ~ \"kleiner Gewinn\",\n                                     profit &gt; 100 ~ \"mittlerer Gewinn\",\n                                     profit &gt; 200 ~ \"hoher Gewinn\")) %&gt;% \n  select(profit, profit_category)\n\n\n\n\nprofit\nprofit_category\n\n\n\n1687\nkleiner Gewinn\n\n\n-1352\nkein Gewinn\n\n\n-2003\nkein Gewinn\n\n\n1487\nkleiner Gewinn\n\n\n364\nkleiner Gewinn\n\n\n-2907\nkein Gewinn\n\n\n955\nkleiner Gewinn\n\n\n1333\nkleiner Gewinn\n\n\n\n\n\n\nMann kann auch einen “default” Wert spezifizieren, den die Zeilen der neuen Spalte annehmen, falls keine andere Bedingung zutrifft:\n\nbudget2 %&gt;%\n  mutate(profit_category = case_when(profit &lt;= 0 ~ \"kein Gewinn\",\n                                     .default = \"Gewinn\")) %&gt;% \n  select(profit, profit_category)\n\n\n\n\nprofit\nprofit_category\n\n\n\n1687\nGewinn\n\n\n-1352\nkein Gewinn\n\n\n-2003\nkein Gewinn\n\n\n1487\nGewinn\n\n\n364\nGewinn\n\n\n-2907\nkein Gewinn\n\n\n955\nGewinn\n\n\n1333\nGewinn\n\n\n\n\n\n\n\n6.2.6 Zusammenfassen\nDie Funktion mutate generiert für jede bestehende Beobachtung einen neuen Wert. Oft wollen wir aber Berechnungen anstellen, die bestehende Werte zusammenfast. Dafür verwenden wir die Funktion summarise. Bevor wir Beispiele von summarise anschauen, bringen wir die Daten in ein tidy Format:\n\nbudget4 &lt;- budget %&gt;%\n  select(-satisfaction_2019, -satisfaction_2020) %&gt;%\n  pivot_longer(cols = sales_2019:expenses_2020,\n               names_to = c(\"type\", \"year\"),\n               names_sep = \"_\",\n               values_to = \"value\") %&gt;%\n  pivot_wider(names_from = type,\n              values_from = value)\n\nhead(budget4) # Überprüfen Sie das Format\n\n\n\n\nregion\nproduct\nyear\nsales\nexpenses\n\n\n\nNorth\nwidgets\n2019\n2129\n822\n\n\nNorth\nwidgets\n2020\n-517\n-897\n\n\nNorth\ngadgets\n2019\n723\n1037\n\n\nNorth\ngadgets\n2020\n77\n1115\n\n\nSouth\nwidgets\n2019\n1123\n1004\n\n\nSouth\nwidgets\n2020\n-1450\n672\n\n\n\n\n\n\nJetzt können wir zum Beispiel Kennzahlen wie die durchschnittlichen Verkäufe und Ausgaben, sowie das Minimum und Maximum des Gewinnes berechnen:\n\nbudget4 %&gt;%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  )\n\n\n\n\nmean_sales\nmean_expenses\nmin_profit\nmax_profit\n\n\n291.1875\n318.4375\n-2632\n2390\n\n\n\n\n\nWir sehen, dass summarise wie mutate funktioniert, jedoch mehrere Beobachtungen zu einer neuen, aggregierten, Beobachtung zusammenfasst.\nOft interessieren wir uns aber für solche Kennzahlen getrennt nach Gruppen. Zum Beispiel wäre es gut zu wissen, inwiefern sich die durchschnittlichen Verkäufe und Ausgaben nach Region unterscheiden. Dies können wir mit der group_by Funktion tun.\n\n6.2.7 Gruppieren\nDie Funktion group_by() nimmt bestehende Daten und wandelt sie in eine gruppierte Tabelle um, in der alle Berechnungen, die anschließend darauf ausgeführt werden, “nach Gruppe” durchgeführt werden. Schauen wir uns als erste an was passiert, wenn wir die group_by Funktion anwenden:\n\nbudget4 %&gt;%\n  group_by(year, product)\n\n\n\n\nregion\nproduct\nyear\nsales\nexpenses\n\n\n\nNorth\nwidgets\n2019\n2129\n822\n\n\nNorth\nwidgets\n2020\n-517\n-897\n\n\nNorth\ngadgets\n2019\n723\n1037\n\n\nNorth\ngadgets\n2020\n77\n1115\n\n\nSouth\nwidgets\n2019\n1123\n1004\n\n\nSouth\nwidgets\n2020\n-1450\n672\n\n\nSouth\ngadgets\n2019\n2022\n-610\n\n\nSouth\ngadgets\n2020\n-945\n200\n\n\nEast\nwidgets\n2019\n-728\n-801\n\n\nEast\nwidgets\n2020\n-51\n-342\n\n\nEast\ngadgets\n2019\n-423\n94\n\n\nEast\ngadgets\n2020\n-354\n2036\n\n\nWest\nwidgets\n2019\n633\n783\n\n\nWest\nwidgets\n2020\n790\n-315\n\n\nWest\ngadgets\n2019\n1204\n433\n\n\nWest\ngadgets\n2020\n426\n-136\n\n\n\n\n\n\nWir sehen, dass der Datensatz nun nach den Variablen year und product gruppiert ist. Zudem sehen wir, dass es vier solcher Gruppen gibt. Alle nachfolgenden Berechnungen (z.B. mit summarise) werden nun separat nach diesen Gruppen durchgeführt. So werden zum Beispile die Mittelwerte getrennt nach diesen vier Gruppen berechnet:\n\nyear_prod &lt;- budget4 %&gt;%\n  group_by(year, product) %&gt;%\n  summarise(\n    mean_sales = mean(sales\n\n),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  ) %&gt;% \n  ungroup()\n\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n\nyear_prod\n\n\n\n\nyear\nproduct\nmean_sales\nmean_expenses\nmin_profit\nmax_profit\n\n\n\n2019\nwidgets\n789.25\n452.00\n-1307\n150\n\n\n2019\ngadgets\n881.50\n238.50\n-2632\n517\n\n\n2020\nwidgets\n-307.00\n-220.50\n-1105\n2122\n\n\n2020\ngadgets\n-199.00\n803.75\n-562\n2390\n\n\n\n\n\n\nDamit die Daten nicht gruppiert bleiben, wenden wir zum Schluss noch d ie Funktion ungroup an die wie der Name sagt, die Gruppierung aufhebt.\nWir können die group_by Funktion auch mit anderen Funktionen, die wir bereits kennengelernt haben, verwenden. So können wir zum Beispiel pro Gruppe die Beobachtung mit dem grössten Verkaufsvolumen herausfiltern:\n\nbudget4 %&gt;% \n  group_by(year, product) %&gt;% \n  filter(sales == max(sales))\n\n\n\n\nregion\nproduct\nyear\nsales\nexpenses\n\n\n\nNorth\nwidgets\n2019\n2129\n822\n\n\nSouth\ngadgets\n2019\n2022\n-610\n\n\nWest\nwidgets\n2020\n790\n-315\n\n\nWest\ngadgets\n2020\n426\n-136",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Datenbereinigung</span>"
    ]
  },
  {
    "objectID": "07-joins.html",
    "href": "07-joins.html",
    "title": "7  Datenbeziehungen",
    "section": "",
    "text": "7.1 Daten laden\nWieder generieren wir zu Übungszwecken einen kleinen übersichtlichen Datensatz. Dies erleichtert es die Berechnungen/Datenmanipulationen nachzuvollziehen. Die Prinzipien sind jedoch, auch für riesige Datensätze, identisch.\nAls erstes generieren wir den Datensatz customers\nDieser hat folgende Spalten/Variablen: id, Stadt und Postleitzahl für fünf Kunden 1-5.\ncustomers &lt;- tibble(\n  id = 1:5,\n  city = c(\"Port Ellen\", \"Dufftown\", NA, \"Aberlour\", \"Tobermory\"),\n  postcode = c(\"PA42 7DU\", \"AB55 4DH\", NA, \"AB38 7RY\", \"PA75 6NR\")\n)\nNehmen wir an, dass wir neben der Datenbank der Kunden auch eine Datenbank der Bestellungen haben, die diese Kunden getätigt haben. Solche Daten werden in der Praxis tatsächlich so (also getrennt) in Datenbanken gespeichert. Wir generieren also einen zweiten Datensatz den wir orders nennen. Dieser Datensatz enthält eine Spalte mit den Kunden-IDs und eine Spalte mit der Anzahl der bestellten Artikel. Einige Kunden aus der vorherigen Tabelle haben keine Bestellungen, manche haben mehr als eine Bestellung und manche sind nicht in der Kundentabelle.\norders &lt;- tibble(\n  id = c(2, 3, 4, 4, 5, 5, 6, 6, 7),\n  items = c(10, 18, 21, 23, 9, 11, 11, 12, 3)\n)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#sec-joins-data",
    "href": "07-joins.html#sec-joins-data",
    "title": "7  Datenbeziehungen",
    "section": "",
    "text": "1:5 wird die Variable id mit allen ganzen Zahlen zwischen 1 und 5 füllen.\n\ncity und code verwenden beide die Funktion c(), um mehrere Zeichenketten einzugeben. Beachten Sie, dass jeder Eintrag in eigenen Anführungszeichen steht, abgesehen von fehlenden Daten, die als NA aufgezeichnet werden.\nBei der Eingabe von Daten auf diese Weise ist es wichtig, dass die Reihenfolge jeder Variable übereinstimmt. Also entspricht die Nummer 1 “Port Ellen” und “PA42 7DU”.\n\n\n\nDemo-Kundentabelle.\n\nid\ncity\npostcode\n\n\n\n1\nPort Ellen\nPA42 7DU\n\n\n2\nDufftown\nAB55 4DH\n\n\n3\nNA\nNA\n\n\n4\nAberlour\nAB38 7RY\n\n\n5\nTobermory\nPA75 6NR\n\n\n\n\n\n\nDemo-Bestelltabelle.\n\nid\nitems\n\n\n\n2\n10\n\n\n3\n18\n\n\n4\n21\n\n\n4\n23\n\n\n5\n9\n\n\n5\n11\n\n\n6\n11\n\n\n6\n12\n\n\n7\n3",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#mutierende-joins-verknüpfungen",
    "href": "07-joins.html#mutierende-joins-verknüpfungen",
    "title": "7  Datenbeziehungen",
    "section": "\n7.2 Mutierende Joins (Verknüpfungen)",
    "text": "7.2 Mutierende Joins (Verknüpfungen)\nMutierende Joins verhalten sich wie die dplyr::mutate()-Funktion, indem sie neue Spalten zu einer Tabelle auf Basis der Werte in einer anderen Tabelle hinzufügen.\nAlle mutierenden Joins haben diese grundlegende Syntax:\n****_join(x, y, by = NULL, suffix = c(\".x\", \".y\"))\n\n\nx = die erste (linke) Tabelle\n\ny = die zweite (rechte) Tabelle\n\nby = welche Spalten abgeglichen werden sollen. Wenn Sie dies leer lassen, wird es auf allen Spalten mit denselben Namen in den beiden Tabellen abgeglichen. Beobachtungen, die in diesen Spalten die selben Werte haben (z.B. die selbe ID), werden miteinander verknüpft\n\nsuffix = wenn Spalten denselben Namen in beiden Tabellen haben, aber Sie nicht nach ihnen verbinden, erhalten sie ein Suffix, um sie eindeutig zu machen. Dies ist standardmäßig “.x” und “.y”, aber Sie können es in etwas Sinnvolleres ändern.\n\n\n\n\n\n\n\nNote\n\n\n\nSie können das Argument by weglassen, wenn Sie auf allen Spalten mit demselben Namen abgleichen, aber es ist gute Praxis, es immer anzugeben, damit Ihr Code robust gegenüber Änderungen in den geladenen Daten bleibt.\n\n\n\n7.2.1 left_join()\n\n\n\nEin left_join behält alle Daten der ersten (linken) Tabelle bei und fügt alles hinzu, was mit der zweiten (rechten) Tabelle übereinstimmt. Die folgende Animation veranschaulicht einen left_join():\n\n\n\n\nWenn die rechte Tabelle mehr als eine Übereinstimmung für eine Zeile in der linken Tabelle hat, gibt es mehr als eine Zeile in der verbundenen Tabelle (siehe IDs 4 und 5).\n\nleft_data &lt;- left_join(customers, orders, by = \"id\")\nleft_data\n\n\n\n\nid\ncity\npostcode\nitems\n\n\n\n1\nPort Ellen\nPA42 7DU\nNA\n\n\n2\nDufftown\nAB55 4DH\n10\n\n\n3\nNA\nNA\n18\n\n\n4\nAberlour\nAB38 7RY\n21\n\n\n4\nAberlour\nAB38 7RY\n23\n\n\n5\nTobermory\nPA75 6NR\n9\n\n\n5\nTobermory\nPA75 6NR\n11\n\n\n\n\n\n\n\n\n\nDie Reihenfolge, in der Sie die Tabellen angeben, ist wichtig. Im folgenden Code haben wir die Reihenfolge umgekehrt, sodass das Ergebnis alle Zeilen aus der orders-Tabelle enthält, die mit den passenden Zeilen aus der customers-Tabelle verbunden sind.\n\nleft2_data &lt;- left_join(orders, customers, by = \"id\")\nleft2_data\n\n\n\n\nid\nitems\ncity\npostcode\n\n\n\n2\n10\nDufftown\nAB55 4DH\n\n\n3\n18\nNA\nNA\n\n\n4\n21\nAberlour\nAB38 7RY\n\n\n4\n23\nAberlour\nAB38 7RY\n\n\n5\n9\nTobermory\nPA75 6NR\n\n\n5\n11\nTobermory\nPA75 6NR\n\n\n6\n11\nNA\nNA\n\n\n6\n12\nNA\nNA\n\n\n7\n3\nNA\nNA\n\n\n\n\n\n\n\n7.2.2 right_join()\n\n\n\nEin right_join behält alle Daten der zweiten (rechten) Tabelle bei und fügt alles hinzu, was mit der ersten (linken) Tabelle übereinstimmt. Die folgende Animation veranschaulicht einen right_join:\n\n\n\n\n\nright_data &lt;- right_join(customers, orders, by = \"id\")\nright_data\n\n\n\n\nid\ncity\npostcode\nitems\n\n\n\n2\nDufftown\nAB55 4DH\n10\n\n\n3\nNA\nNA\n18\n\n\n4\nAberlour\nAB38 7RY\n21\n\n\n4\nAberlour\nAB38 7RY\n23\n\n\n5\nTobermory\nPA75 6NR\n9\n\n\n5\nTobermory\nPA75 6NR\n11\n\n\n6\nNA\nNA\n11\n\n\n6\nNA\nNA\n12\n\n\n7\nNA\nNA\n3\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDiese Tabelle enthält dieselben Informationen wie left_join(orders, customers, by = \"id\"), aber die Spalten sind in einer anderen Reihenfolge (zuerst linke Tabelle, dann rechte Tabelle).\n\n\n\n7.2.3 inner_join()\n\n\n\nEin inner_join gibt alle Zeilen zurück, die in beiden Tabellen eine Übereinstimmung haben. Das Ändern der Reihenfolge der Tabellen ändert die Reihenfolge der Spalten, aber nicht, welche Zeilen erhalten bleiben.\nDie folgende Animation veranschaulicht einen inner_join:\n\n\n\n\n\ninner_data &lt;- inner_join(customers, orders, by = \"id\")\ninner_data\n\n\n\n\nid\ncity\npostcode\nitems\n\n\n\n2\nDufftown\nAB55 4DH\n10\n\n\n3\nNA\nNA\n18\n\n\n4\nAberlour\nAB38 7RY\n21\n\n\n4\nAberlour\nAB38 7RY\n23\n\n\n5\nTobermory\nPA75 6NR\n9\n\n\n5\nTobermory\nPA75 6NR\n11\n\n\n\n\n\n\n\n7.2.4 full_join()\n\n\n\nEin full_join ermöglicht es, Zeilen in zwei Tabellen zu verbinden und dabei alle Informationen aus beiden Tabellen zu behalten. Wenn eine Zeile in der anderen Tabelle keine Übereinstimmung hat, werden die Spaltenwerte der anderen Tabelle auf NA gesetzt.\nDie folgende Animation veranschaulicht einen full-join:\n\n\n\n\nfull_data &lt;- full_join(customers, orders, by = \"id\")\nfull_data\n\n\n\n\nid\ncity\npostcode\nitems\n\n\n\n1\nPort Ellen\nPA42 7DU\nNA\n\n\n2\nDufftown\nAB55 4DH\n10\n\n\n3\nNA\nNA\n18\n\n\n4\nAberlour\nAB38 7RY\n21\n\n\n4\nAberlour\nAB38 7RY\n23\n\n\n5\nTobermory\nPA75 6NR\n9\n\n\n5\nTobermory\nPA75 6NR\n11\n\n\n6\nNA\nNA\n11\n\n\n6\nNA\nNA\n12\n\n\n7\nNA\nNA\n3",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#filternde-joins",
    "href": "07-joins.html#filternde-joins",
    "title": "7  Datenbeziehungen",
    "section": "\n7.3 Filternde Joins",
    "text": "7.3 Filternde Joins\nFilternde Joins verhalten sich wie die dplyr::filter()-Funktion, indem sie Zeilen aus den Daten in einer Tabelle auf Basis der Werte in einer anderen Tabelle behalten oder entfernen. Das Ergebnis eines filternden Joins enthält nur Zeilen aus der linken Tabelle und hat dieselbe Anzahl oder weniger Zeilen wie die linke Tabelle.\n\n7.3.1 semi_join()\n\n\n\nEin semi_join gibt alle Zeilen aus der linken Tabelle zurück, bei denen es passende Werte in der rechten Tabelle gibt, wobei nur Spalten aus der linken Tabelle beibehalten werden.\nDie Folgende Animation veranschaulicht einen semi_join:\n\n\n\n\nsemi_data &lt;- semi_join(customers, orders, by = \"id\")\nsemi_data\n\n\n\n\nid\ncity\npostcode\n\n\n\n2\nDufftown\nAB55 4DH\n\n\n3\nNA\nNA\n\n\n4\nAberlour\nAB38 7RY\n\n\n5\nTobermory\nPA75 6NR\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIm Gegensatz zu einem inner_join wird ein semi_join niemals die Zeilen in der linken Tabelle duplizieren, wenn es mehr als eine passende Zeile in der rechten Tabelle gibt.\n\n\n\n\n\nDa nur die Spalten der Linken Tabelle erhalten bleiben, ist die Reihenfolge bei einem semi_join wichtig.\n\nsemi2_data &lt;- semi_join(orders, customers, by = \"id\")\nsemi2_data\n\n\n\n\nid\nitems\n\n\n\n2\n10\n\n\n3\n18\n\n\n4\n21\n\n\n4\n23\n\n\n5\n9\n\n\n5\n11\n\n\n\n\n\n\n\n7.3.2 anti_join()\n\n\n\nEin anti_join gibt alle Zeilen aus der linken Tabelle zurück, bei denen es keine passenden Werte in der rechten Tabelle gibt, wobei nur Spalten aus der linken Tabelle beibehalten werden.\nDie folgende Animation veranschaulicht einen anti-join:\n\n\n\n\nanti_data &lt;- anti_join(customers, orders, by = \"id\")\nanti_data\n\n\n\n\nid\ncity\npostcode\n\n\n1\nPort Ellen\nPA42 7DU\n\n\n\n\n\nDie Reihenfolge ist wichtig bei einem anti join.\n\n\n\n\nanti2_data &lt;- anti_join(orders, customers, by = \"id\")\nanti2_data\n\n\n\n\nid\nitems\n\n\n\n6\n11\n\n\n6\n12\n\n\n7\n3",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#verknüpfung-von-mehr-als-zwei-tabellen",
    "href": "07-joins.html#verknüpfung-von-mehr-als-zwei-tabellen",
    "title": "7  Datenbeziehungen",
    "section": "\n7.4 Verknüpfung von mehr als zwei Tabellen",
    "text": "7.4 Verknüpfung von mehr als zwei Tabellen\nDie ****_join()-Funktionen sind alles Zwei-Tabellen-Verben, das heißt, Sie können jeweils nur zwei Tabellen miteinander verbinden. Wenn man jedoch mehrere Tabellen verbinden musst, kann man einfach weitere Joins hinzufügen. Dies kann man tun, indem man ein Zwischenobjekt erstellt oder effizienter durch die Verwendung einer Pipe:\n\n# erstelle eine Tabelle mit Gesamtkundenzufriedenheitswerten\nsatisfaction &lt;- tibble(\n  id = 1:5,\n  satisfaction = c(4, 3, 2, 3, 1)\n)\n\n# führe den ersten Join durch\njoin_1 &lt;- left_join(customers, orders, by = \"id\")\n\n# führe den zweiten Join am neuen Objekt durch\njoin_2 &lt;- left_join(join_1, satisfaction, \n                    by = \"id\")\n\n\n# effizientere Methode unter Verwendung der Pipe\npipe_join &lt;- customers %&gt;%\n  left_join(orders, by = \"id\") %&gt;%\n  left_join(satisfaction, by = \"id\")\n\n\n\n\n\n\n\nWarning\n\n\n\nAuf jeder Stufe einer Analyse sollte man die Ausgabe überprüfen, um sicherzustellen, dass das, was man erstellt hat, auch das ist, was man beabsichtigt hat. Dies gilt insbesondere für Joins. Man sollte die Zwischenschritte durch routinemäßige Überprüfungen mit Funktionen wie glimpse(), str(), und summary() anschauen, um eine grobe Vorstellung davon zu haben, was der Join ergeben sollte. Mindestens sollte man wissen, ob das verbundene Objekt zu mehr oder weniger Variablen und Beobachtungen führen sollten.\nWenn Sie einen mehrzeiligen Join wie im obigen piped Beispiel haben, bauen Sie den Code schrittweise auf und überprüfen Sie die Ausgabe auf jeder Stufe.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#bindende-joins",
    "href": "07-joins.html#bindende-joins",
    "title": "7  Datenbeziehungen",
    "section": "\n7.5 Bindende Joins",
    "text": "7.5 Bindende Joins\nBindende Joins binden eine Tabelle an eine andere, indem sie ihre Zeilen oder Spalten zusammenfügen.\n\n7.5.1 bind_rows()\nMit der Funktion bind_rows kann man die Zeilen von zwei Tabellen mit zusammenfügen. Hier fügen wir Kundendaten für die Kunden 6-9 hinzu und verbinden diese mit der ursprünglichen Kundentabelle.\n\nnew_customers &lt;- tibble(\n  id = 6:9,\n  city = c(\"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\"),\n  postcode = c(\"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\")\n)\n\nbindr_data &lt;- bind_rows(customers, new_customers)\nbindr_data\n\n\n\n\nid\ncity\npostcode\n\n\n\n1\nPort Ellen\nPA42 7DU\n\n\n2\nDufftown\nAB55 4DH\n\n\n3\nNA\nNA\n\n\n4\nAberlour\nAB38 7RY\n\n\n5\nTobermory\nPA75 6NR\n\n\n6\nFalkirk\nFK1 4RS\n\n\n7\nArdbeg\nPA42 7EA\n\n\n8\nDoogal\nG81 4SJ\n\n\n9\nKirkwall\nKW15 1SE\n\n\n\n\n\n\nDie Spalten müssen nur dieselben Namen haben, sie müssen nicht in der gleichen Reihenfolge sein. Alle Spalten, die nicht in beiden Tabellen enthalten sind, haben einfach NA-Werte für Einträge aus der anderen Tabelle.\nWenn eine Zeile in beiden Tabellen vorkommt, wird die Zeile in der resultierenden Tabelle doppelt vorkommen. Wenn Ihre Tabellen genau dieselben Spalten haben, können Sie union() verwenden, um Duplikate zu vermeiden (werden wir gleich sehen).\n\nnew_customers &lt;- tibble(\n  id = 5:9,\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\"),\n  new = c(1,2,3,4,5)\n)\n\nbindr2_data &lt;- bind_rows(customers, new_customers)\nbindr2_data\n\n\n\n\nid\ncity\npostcode\nnew\n\n\n\n1\nPort Ellen\nPA42 7DU\nNA\n\n\n2\nDufftown\nAB55 4DH\nNA\n\n\n3\nNA\nNA\nNA\n\n\n4\nAberlour\nAB38 7RY\nNA\n\n\n5\nTobermory\nPA75 6NR\nNA\n\n\n5\nTobermory\nPA75 6NR\n1\n\n\n6\nFalkirk\nFK1 4RS\n2\n\n\n7\nArdbeg\nPA42 7EA\n3\n\n\n8\nDoogal\nG81 4SJ\n4\n\n\n9\nKirkwall\nKW15 1SE\n5\n\n\n\n\n\n\n\n7.5.2 bind_cols()\nMan kann Tabellen auch mit der Funktion bind_cols zusammenführen. Dies sollte man jedoch nur tun, wenn beide Tabllen die gleiche Anzahl Zeilen haben und diese genau die selbe Reihenfolge haben. Diese Funktion ist also mit Vorsicht zu geniessen und im Zweifelsfall sollte für solche Operationen eine Funktion wie left_join verwendet werden.\n\nnew_info &lt;- tibble(\n  colour = c(\"red\", \"orange\", \"yellow\", \"green\", \"blue\")\n)\n\nbindc_data &lt;- bind_cols(customers, new_info)\nbindc_data \n\n\n\n\nid\ncity\npostcode\ncolour\n\n\n\n1\nPort Ellen\nPA42 7DU\nred\n\n\n2\nDufftown\nAB55 4DH\norange\n\n\n3\nNA\nNA\nyellow\n\n\n4\nAberlour\nAB38 7RY\ngreen\n\n\n5\nTobermory\nPA75 6NR\nblue\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDer einzige Vorteil von bind_cols() gegenüber einem mutierenden Join besteht darin, wenn die Tabellen keine IDs zum Verbinden haben und Sie sich ausschließlich auf ihre Reihenfolge verlassen müssen. Ansonsten sollten Sie einen mutierenden Join verwenden (alle vier mutierenden Joins ergeben das gleiche Ergebnis, wenn alle Zeilen in jeder Tabelle genau eine Übereinstimmung in der anderen Tabelle haben).",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#mengenoperationen",
    "href": "07-joins.html#mengenoperationen",
    "title": "7  Datenbeziehungen",
    "section": "\n7.6 Mengenoperationen",
    "text": "7.6 Mengenoperationen\nMengenoperationen vergleichen zwei Tabellen und geben Zeilen zurück, die übereinstimmen (intersect), in einer der beiden Tabellen sind (union) oder in einer Tabelle, aber nicht in der anderen sind (setdiff).\n\n7.6.1 intersect()\ndplyr::intersect() gibt alle Zeilen in zwei Tabellen zurück, die genau übereinstimmen. Die Spalten müssen nicht in derselben Reihenfolge sein, müssen aber dieselben Namen haben.\n\nnew_customers &lt;- tibble(\n  id = 5:9,\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\")\n)\n\nintersect_data &lt;- intersect(customers, new_customers)\nintersect_data\n\n\n\n\nid\ncity\npostcode\n\n\n5\nTobermory\nPA75 6NR\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWenn Sie vergessen haben, dplyr oder das tidyverse zu laden, hat base R auch eine base::intersect()-Funktion, die nicht wie dplyr::intersect() funktioniert. Die Fehlermeldung kann verwirrend sein und sieht ungefähr so aus:\n\nbase::intersect(customers, new_customers)\n\nlist()\n\n\n\n\n\n7.6.2 union()\ndplyr::union() gibt alle Zeilen aus beiden Tabellen zurück und entfernt dabei, im Gegensatz zu bind_rows(), doppelte Zeilen.\n\nunion_data &lt;- union(customers, new_customers)\nunion_data\n\n\n\n\nid\ncity\npostcode\n\n\n\n1\nPort Ellen\nPA42 7DU\n\n\n2\nDufftown\nAB55 4DH\n\n\n3\nNA\nNA\n\n\n4\nAberlour\nAB38 7RY\n\n\n5\nTobermory\nPA75 6NR\n\n\n6\nFalkirk\nFK1 4RS\n\n\n7\nArdbeg\nPA42 7EA\n\n\n8\nDoogal\nG81 4SJ\n\n\n9\nKirkwall\nKW15 1SE\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWenn Sie vergessen haben, dplyr oder das tidyverse zu laden, hat base R auch eine base::union()-Funktion. Sie erhalten normalerweise keine Fehlermeldung, aber das Ergebnis wird nicht das sein, was Sie erwarten.\n\nbase::union(customers, new_customers)\n\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"Port Ellen\" \"Dufftown\"   NA           \"Aberlour\"   \"Tobermory\" \n\n[[3]]\n[1] \"PA42 7DU\" \"AB55 4DH\" NA         \"AB38 7RY\" \"PA75 6NR\"\n\n[[4]]\n[1] 5 6 7 8 9\n\n[[5]]\n[1] \"PA75 6NR\" \"FK1 4RS\"  \"PA42 7EA\" \"G81 4SJ\"  \"KW15 1SE\"\n\n[[6]]\n[1] \"Tobermory\" \"Falkirk\"   \"Ardbeg\"    \"Doogal\"    \"Kirkwall\" \n\n\n\n\n\n7.6.3 setdiff()\ndplyr::setdiff gibt Zeilen zurück, die in der ersten Tabelle, aber nicht in der zweiten Tabelle sind.\n\nsetdiff_data &lt;- setdiff(customers, new_customers)\nsetdiff_data\n\n\n\n\nid\ncity\npostcode\n\n\n\n1\nPort Ellen\nPA42 7DU\n\n\n2\nDufftown\nAB55 4DH\n\n\n3\nNA\nNA\n\n\n4\nAberlour\nAB38 7RY\n\n\n\n\n\n\nDie Reihenfolge ist wichtig für setdiff.\n\nsetdiff2_data &lt;- setdiff(new_customers, customers)\nsetdiff2_data\n\n\n\n\nid\npostcode\ncity\n\n\n\n6\nFK1 4RS\nFalkirk\n\n\n7\nPA42 7EA\nArdbeg\n\n\n8\nG81 4SJ\nDoogal\n\n\n9\nKW15 1SE\nKirkwall\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWenn Sie vergessen haben, dplyr oder das tidyverse zu laden, hat base R auch eine base::setdiff()-Funktion. Sie erhalten normalerweise keine Fehlermeldung, aber das Ergebnis ist möglicherweise nicht das, was Sie erwarten, weil base::setdiff() erwartet, dass die Spalten in derselben Reihenfolge sind, sodass die ID 5 hier als unterschiedlich zwischen den beiden Tabellen registriert wird.\n\nbase::setdiff(customers, new_customers)\n\n$id\n[1] 1 2 3 4 5\n\n$city\n[1] \"Port Ellen\" \"Dufftown\"   NA           \"Aberlour\"   \"Tobermory\" \n\n$postcode\n[1] \"PA42 7DU\" \"AB55 4DH\" NA         \"AB38 7RY\" \"PA75 6NR\"",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#konflikte-bei-variablentypen",
    "href": "07-joins.html#konflikte-bei-variablentypen",
    "title": "7  Datenbeziehungen",
    "section": "\n7.7 Konflikte bei Variablentypen",
    "text": "7.7 Konflikte bei Variablentypen\nBeim Verbinden von Datensätzen anhand gemeinsamer Spalten ist es wichtig, dass nicht nur die Variablennamen identisch sind, sondern auch der Datentyp dieser Variablen identisch ist.\nUm das zu veranschaulichen, erstellen wir unseren new_customers-Datenset erneut, aber diesmal spezifizieren wir, dass id eine character-Variable ist.\n\nnew_customers2 &lt;- tibble(\n  id = as.character(5:9),\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\")\n)\nstr(new_customers2)\n\ntibble [5 × 3] (S3: tbl_df/tbl/data.frame)\n $ id      : chr [1:5] \"5\" \"6\" \"7\" \"8\" ...\n $ postcode: chr [1:5] \"PA75 6NR\" \"FK1 4RS\" \"PA42 7EA\" \"G81 4SJ\" ...\n $ city    : chr [1:5] \"Tobermory\" \"Falkirk\" \"Ardbeg\" \"Doogal\" ...\n\n\nWenn wir versuchen, diesen Datensatz mit einem der anderen Datensätze zu verbinden, in denen id als numeric-Variable gespeichert ist, wird ein Fehler erzeugt.\n\n#inner_join(customers, new_customers2)\n\nDasselbe gilt für bind_rows():\n\n#bind_rows(customers, new_customers2)\n\nUm dies zu vermeiden, müssen wir den Datentyp einer der beiden Variablen ändern. Dies kann man unter anderem mit den folgenden Funktionen tun:\n\n\nas.numeric() - konvertiert eine Variable zu numeric. Nützlich, wenn Sie eine Variable aus Zahlen haben, die als Zeichen codiert wurden. Alle Werte, die nicht in Zahlen umgewandelt werden können (z. B. wenn Sie das Wort “missing” in Zellen haben, für die Sie keine Daten haben), werden als NA zurückgegeben.\n\nas.factor() - konvertiert eine Variable zu einem factor. Sie können die Faktorstufen und -labels manuell festlegen oder die Standardreihenfolge (alphabetisch) verwenden.\n\nas.character() - konvertiert eine Variable zu character-Daten.\n\nUm diese Funktionen auf eine Variable anzuwenden, können wir mutate() verwenden, um die Variable mit dieser Variablen als dem neuen Datentyp zu überschreiben:\n\nnew_customers2 &lt;- new_customers2 %&gt;%\n  mutate(id = as.numeric(id))\n\nSobald wir dies getan haben, funktionieren die Joins nun:\n\ninner_join(orders, new_customers2)\n\nJoining with `by = join_by(id)`\n\n\n\n\n\nid\nitems\npostcode\ncity\n\n\n\n5\n9\nPA75 6NR\nTobermory\n\n\n5\n11\nPA75 6NR\nTobermory\n\n\n6\n11\nFK1 4RS\nFalkirk\n\n\n6\n12\nFK1 4RS\nFalkirk\n\n\n7\n3\nPA42 7EA\nArdbeg",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#übungen",
    "href": "07-joins.html#übungen",
    "title": "7  Datenbeziehungen",
    "section": "\n7.8 Übungen",
    "text": "7.8 Übungen\nEs gibt viele verschiedene Anwendungsfälle für die ****_join()-Funktionen. Diese Übungen ermöglichen es Ihnen, verschiedene Joins zu üben. Wenn Sie Beispiele haben, wo Joins in Ihrer eigenen Arbeit hilfreich sein könnten, teilen Sie diese bitte im Teams im Kanal der Woche 6 mit, da viele konkrete Beispiele dabei helfen können, zwischen den verschiedenen Joins zu unterscheiden.\n\n7.8.1 Notendaten\nDas Bewertungsschema Schedule A der Universität Glasgow verwendet eine 22-stufige alphanumerische Skala (weitere Informationen finden Sie in Ihrem zusammenfassenden Bericht Bewertungsinformationsblatt). Jede alphanumerische Note (z. B. B2) hat einen zugrunde liegenden numerischen Notenpunkt (z. B. 16).\nOft, wenn wir mit Studentennoten arbeiten, werden sie uns nur in einer dieser Formen zur Verfügung gestellt, aber wir müssen in der Lage sein, zwischen den beiden zu wechseln. Zum Beispiel benötigen wir die numerische Form, um deskriptive Statistiken über die Durchschnittsnote berechnen zu können, aber wir benötigen die alphanumerische Form, um sie den Studentenakten freizugeben.\n\nLaden Sie grade_data.csv, grade_data2.csv und scheduleA.csv in Ihren Datenordner.\nLesen Sie scheduleA.csv ein und speichern Sie es in einem Objekt namens schedule.\nLesen Sie grade_data1.csv ein und speichern Sie es in einem Objekt namens grades1.\nLesen Sie grade_data2.csv ein und speichern Sie es in einem Objekt namens grades2.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nschedule &lt;- read_csv(\"data/scheduleA.csv\")\ngrades1 &lt;- read_csv(\"data/grade_data1.csv\") \ngrades2 &lt;- read_csv(\"data/grade_data2.csv\")\n\n\n\n\n\n7.8.2 Übereinstimmung der Variablentypen\nAn der UofG erhält jeder Student eine GUID, eine numerische ID-Nummer. Diese ID-Nummer wird jedoch auch mit dem ersten Buchstaben Ihres Nachnamens kombiniert, um Ihren Benutzernamen zu erstellen, der zusammen mit Ihrer E-Mail-Adresse verwendet wird. Wenn beispielsweise Ihre ID 1234567 lautet und Ihr Nachname Nordmann ist, lautet Ihr Benutzername 1234567n. Aus Sicht der Datenbereinigung ist dies sehr ärgerlich, da die numerische ID als numerische Daten gespeichert wird, der Benutzername jedoch als Zeichen aufgrund des Buchstabens am Ende gespeichert wird. grades1 hat eine numerische ID, während grades2 den zusätzlichen Buchstaben hat. Um diese Datensätze zu verbinden, müssen wir die Variablen standardisieren.\nZuerst entfernen Sie den Buchstaben aus id mit der Funktion stringr::str_replace_all(), die Text ersetzt, der einem Muster entspricht. Hier verwenden wir das Muster \"[a-z]\", das alle Kleinbuchstaben a bis z findet, und ersetzen sie mit \"\". Siehe die Hilfe für ?about_search_regex für weitere Informationen darüber, wie man Muster festlegt (diese können wirklich komplex werden).\n\ngrades1 &lt;- grades1 %&gt;%\n  mutate(id = str_replace_all(\n    id, # die Variable, die Sie durchsuchen möchten\n    pattern = \"[a-z]\", # finde alle Buchstaben a-z\n    replacement = \"\" # ersetzen mit nichts\n  ))  \n\nNun transformieren Sie den Datentyp von id, damit er mit dem Datentyp in grades2 übereinstimmt.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n# überprüfen Sie die Variablentypen\nglimpse(grades1)\nglimpse(grades2) \n\ngrades1 &lt;- grades1 %&gt;%\n  mutate(id = as.numeric(id))\n\n\n\n\n\n7.8.3 Vollständige Datensätze\nIn diesem Beispiel möchten wir die Notendaten mit Schedule A verbinden, sodass jeder Student mit einer Note sowohl die Note als auch den Notenpunkt hat. Wir möchten aber auch einen vollständigen Datensatz aller Kursteilnehmer haben, also sollten Studenten mit fehlenden Noten trotzdem in den Daten enthalten sein.\n\nVerbinden Sie grades1 und scheduleA und speichern Sie diese Tabelle in einem Objekt namens exam_all.\nMachen Sie dasselbe für grades2 und speichern Sie es in essay_all.\nSowohl exam_all als auch essay_all sollten 100 Beobachtungen von 4 Variablen haben.\n\nHinweis: Sie möchten alle Daten aus grade_data1 und grade_data2 behalten, aber Sie möchten nur die alphanumerischen Noten aus schedule für die Notenpunktwerte, die in grades vorhanden sind. Z. B., wenn niemand ein F1 verliehen wurde, sollten Ihre endgültigen Datensätze das nicht enthalten.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nexam_all &lt;- left_join(grades1, schedule, by = \"Points\")\nessay_all &lt;- left_join(grades2, schedule, by = \"Points\")\n\n\n\n\n\n7.8.4 Fehlende Daten\nAlternativ möchten Sie möglicherweise einen Datensatz haben, der nur Daten für Studenten enthält, die jede Bewertung eingereicht haben und eine Note haben. Zuerst führen Sie summary() sowohl auf exam_all als auch auf essay_all aus.\n\nWie viele Prüfungsnoten fehlen?\nWie viele Aufsatznoten fehlen?\n\nNun erstellen Sie ein Objekt exam_grades, das grades1 und schedule zusammenführt, aber diesmal sollte das resultierende Objekt nur Daten von Studenten enthalten, die eine Note haben. Machen Sie dasselbe für grades2 und speichern Sie es in essay_grades.\nBevor Sie dies tun, angesichts dessen, was Sie über die Anzahl der fehlenden Datenpunkte in jedem Datensatz wissen:\n\nWie viele Beobachtungen sollte exam_grades haben?\nWie viele Beobachtungen sollte essay_grades haben?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nexam_grades &lt;- inner_join(grades1, schedule, by = \"Points\")\nessay_grades &lt;- inner_join(grades2, schedule, by = \"Points\")\n\n\n\n\nHide: Es ist erwähnenswert, dass Sie in der Realität nicht tatsächlich zu den Rohdaten zurückkehren und einen weiteren Join durchführen würden, um diesen Datensatz zu erhalten, sondern Sie könnten einfach alle fehlenden Antworten entfernen, indem Sie %&gt;% drop_na() zu exam_all und essay_all hinzufügen. Wir werden dies jedoch aus didaktischen Gründen auf diese etwas künstliche Weise tun.\nNun erstellen Sie einen Datensatz completes, der die Noten für Studenten verbindet, die sowohl für den Aufsatz als auch für die Prüfung eine Note haben.\n\nDa sowohl exam_grades als auch essay_grades die Variablen Assessment, Points und Grades haben, die gleich benannt sind, aber unterschiedliche Daten haben, sollten Sie das Suffix ändern, damit die resultierenden Variablen Points_exam und Points_essay usw. benannt sind. Sie müssen möglicherweise die Hilfedokumentation konsultieren, um ein Beispiel zu sehen, um dies herauszufinden.\nBereinigen Sie die Datei mit select() und behalten Sie nur die Variablen id, Grade_exam und Grade_essay\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\ncompletes &lt;- inner_join(exam_grades, essay_grades, \n                        by = \"id\", \n                        suffix = c(\"_exam\", \"_essay\")) %&gt;%\n  select(id, Grade_exam, Grade_essay)\n\n\n\n\n\nWie viele Studenten haben eine Note für sowohl die Prüfung als auch den Aufsatz?\n\nN\nun erstellen Sie einen Datensatz no_essay, der Studenten enthält, die eine Note für die Prüfung haben, aber nicht für den Aufsatz.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nno_essay &lt;- anti_join(exam_grades, essay_grades, by = \"id\")\n\n\n\n\n\nWie viele Studenten haben eine Note für die Prüfung, aber nicht für den Aufsatz?\n\nSchließlich erstellen Sie nun einen Datensatz no_exam, der Studenten enthält, die eine Note für den Aufsatz haben, aber nicht für die Prüfung\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nno_exam &lt;- anti_join(essay_grades, exam_grades, by = \"id\")\n\n\n\n\n\nWie viele Studenten haben eine Note für den Aufsatz, aber nicht für die Prüfung?\n\n7.8.5 Teilen auf Teams\nWenn Sie fertig sind, teilen Sie Ihre gestrickte HTML-Datei und die Rmd-Datei für die Übungen auf Teams im Kanal der Woche 07.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "07-joins.html#sec-resources-joins",
    "href": "07-joins.html#sec-resources-joins",
    "title": "7  Datenbeziehungen",
    "section": "\n7.9 Weiterführende Ressourcen",
    "text": "7.9 Weiterführende Ressourcen\n\nData transformation cheatsheet\n\nKapitel 19: Joins in R für Datenwissenschaft\n\n\nKapitel 26: Iteration in R für Datenwissenschaft.\npurrr cheatsheet",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Datenbeziehungen</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html",
    "href": "08-data-viz.html",
    "title": "8  Datenvisualisierung",
    "section": "",
    "text": "8.1 link for tables: https://blog.djnavarro.net/posts/2024-06-21_table1/",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#sec-ilo-viz",
    "href": "08-data-viz.html#sec-ilo-viz",
    "title": "8  Datenvisualisierung",
    "section": "Beabsichtigte Lernergebnisse",
    "text": "Beabsichtigte Lernergebnisse\n\nKategorische und kontinuierliche Daten identifizieren können\nPlots schichtweise mit ggplot erstellen können\nGeeignete Plots für Daten auswählen können",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#functions-viz",
    "href": "08-data-viz.html#functions-viz",
    "title": "8  Datenvisualisierung",
    "section": "\n8.2 Verwendete Funktionen",
    "text": "8.2 Verwendete Funktionen\n\nintegriert (diese können immer verwendet werden, ohne Pakete zu laden)\n\nbase:: , as.numeric(), c(), factor(), mean(), seq(),\ngrDevices:: rgb()\n\n\n\ntidyverse (alle diese können mit library(tidyverse) verwendet werden)\n\nreadr:: col_character(), col_datetime(), col_double(), col_factor(), col_integer(), cols(), read_csv()\n\nlubridate:: now(), today()\n\ndplyr:: count(), glimpse(),\nggplot2:: aes(), coord_cartesian(), element_blank(), facet_wrap(), geom_bar(), geom_boxplot(), geom_col(), geom_histogram(), geom_jitter(), geom_point(), geom_smooth(), ggplot(), ggtitle(), guides(), scale_fill_manual(), scale_x_continuous(), scale_x_date(), scale_x_discrete(), scale_y_continuous(), spec(), stat_summary(), theme(), theme_bw(), theme_minimal(), theme_set()\n\n\n\nandere (jedes Paket muss geladen werden, um diese zu verwenden)\n\nggthemes:: theme_gdocs()\n\npatchwork:: plot_layout()\n\n\n\n\n\n\n```{r setup, include=FALSE}\nlibrary(tidyverse) # enthält ggplot2\nlibrary(patchwork) # für mehrteilige Plots\nlibrary(ggthemes)  # für Plot-Themen\nlibrary(lubridate) # für die Manipulation von Daten\n```\n\n\nIn diesem Kapitel befassen wir uns mit der Datenvisualisierung mit dem Packet ggplot2. Laden Sie zuerst den ggplot2-Spickzettel herunter. Bevor wir uns mit dem Erstellen von Abbildungen beschäftigen, machen wir einen kurzen Rückblick zu den verschiedenen Variablentypen. Denn für die Erstellung von Abbildungen ist es wichtig, dass man weiss, mit welchen Variablentypen man es zu tun hat.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#variablentypen",
    "href": "08-data-viz.html#variablentypen",
    "title": "8  Datenvisualisierung",
    "section": "\n8.3 Variablentypen",
    "text": "8.3 Variablentypen\nWir gehen davon aus, dass unsere Daten bereits im tidy Format sind. Wie bereits besprochen heisst dies, dass jede Zeile eine Beobachtung ist, jede Spalte eine Variable und jede Zelle den Wert einer Beobachtung einer bestimmten Variable (Spalte) enthält. Die unten aufgeführte Tabelle mit Haustieren und ihren BesitzerInnen ist in einem solchen tidy Format. Jede Zeile ist eine Beobachtung eines Haustieres, jede Spalte ist eine Variable, und jede Zelle enthält den Wert der einer Variable eines bestimmten Haustieres. Es gibt 6 Variablen für jedes Haustier, ihren name, owner, species, birthdate, weight (in kg) und rating (auf einer 5-Punkte-Skala von “very evil” bis “very good”).\n\n\n\n\n\nname\nowner\nspecies\nbirthdate\nweight\nrating\n\n\n\nDarwin\nLisa\nferret\n1998-04-02\n1.2\na little evil\n\n\nOy\nLisa\nferret\nNA\n2.9\nvery good\n\n\nKhaleesi\nEmily\ncat\n2014-10-01\n4.5\nvery good\n\n\nBernie\nPhil\ndog\n2017-06-01\n32.0\nvery good\n\n\n\n\n\n\nWie wir bereits besprochen haben, können Variablen entweder kontinuierlich (z.B. weight) oder kategorisch (z.B. species) sein. Beim Erstellen von Abbildungen muss man sich zuerst bewusst sein, mit was für Variablen man es zu tun hat. Denn einige Abbildungen eignen sich nur für bestimmte Variablentypen. Jede Variable hat auch einen data type, wie zum Beispiel numeric (Zahlen), character (Text) oder logical (Wahr/Falsch-Werte). Einige Plots funktionieren nur mit bestimmten Datentypen. Außerdem hat ?sec-data-types mehr Details, da dieses Konzept wiederholt relevant sein wird.\n\n\n\n\nDatentypen sind wie die Kategorien, wenn Sie Zellen in Excel formatieren.\n\n\n\n\n8.3.1 Kontinuierlich\nContinuous Variablen sind Eigenschaften, die man genau messen und in einer natürlichen Reihenfolge ordnen kann, wie zum Beispiel das Gewicht. Sie können kontinuierliche Variablen in mathematischen Operationen verwenden, wie zum Beispiel die Gesamtsumme einer Spalte von Preisen oder die durchschnittliche Anzahl von Likes in sozialen Medien pro Tag berechnen.\nKontinuierliche Variablen haben immer einen numeric Datentyp. Sie sind entweder integers wie 42 oder doubles wie 3.14159.\n\n\n\nBeispiel\n\ninteger_vector &lt;- c(1L, 2L, 4L) #\"integer\"-Vektor (der Buchstabe \"L\" teilt R mit, dass es sich um eine Ganzzahl handelt)\n\ndouble_vector &lt;- c(1, 2, 4)\n\nclass(integer_vector)\n\n\n[1] \"integer\"\n\n\n\n8.3.2 Kategorisch\nCategorical Variablen sind Variablen, die nur eine bestimmte Anzahl an Kategorien haben (zum Beipsiel die Haustierart). Man unterscheidet dabei noch zwischen kategorialen Variablen, die keine natürliche Ordnung haben, sogenannte nominale Variablen &lt;a href=‘https://psyteachr.github.io/glossary/n#nominal’ target=’_blank’ class=‘glossary’ title=‘Categorical variables that don’t have an inherent order, such as types of animal.’&gt;nominal. Die Haustierart gehört zu diesem Typ. Es gibt aber auch kategoriale Variablen, die man ordnen kann. Dies sind dann sogenante ordinale Variablen ordinal. Aber auch hier gibt es nur eine begrenzte Anzahl Kategorien und die Abstände zwischen den verschiedenen Kategorien können oft nicht gleichgesetzt werden. Ein Beispiel dafür sind die Plätze 1 bis 3 an Sportwettkämpfen. Gold ist besser als Silber, was wiederum besser als Bronze ist. Der Abstand zwischen Gold-Silber und Silber-Bronze ist jedoch nicht identisch. Ein weiteres Beispiel für solche Variablen sind die Abstufungen auf Likert Bewertungsskala. Auch wenn eine Skale die Zahlen 1-7 verwendet, um ordinale Variablen darzustellen, sollten Sie sie nicht wie kontinuierliche Variablen behandeln (obwohl dies in der Praxis oft gemacht wird…).\nIn R kann man kategoriale Variablen auf zwei Arten speichern. Man kann sie mit dem Datentyp character oder auch strings genannt, speichern. Solche Variablen werden durch das Platzieren von Text in Anführungszeichen erstellt. Dieser Text kann Buchstaben, Satzzeichen oder sogar Zahlen enthalten. Zum Beispiel ist \"January\" eine Zeichenkette, aber auch \"1\", wenn Sie es in Anführungszeichen setzen. Dieser Datentyp ist am besten für Variablen geeignet, die viele verschiedene Werte haben können, die Sie nicht im Voraus vorhersagen können.\n\n\n\ncharacter/string Variable\n\ncategorical_string &lt;- c(\"Lisa\", \"Emily\", \"Phil\")\n\ncategorical_string\n\n\n[1] \"Lisa\"  \"Emily\" \"Phil\" \n\n\nKategoriale Daten können auch factors sein, eine spezielle Art von Ganzzahl, die es Ihnen ermöglicht, die Kategorienamen und ihre Reihenfolge anzugeben. Dies ist nützlich, um Plots so anzuzeigen, dass die Kategorien in der von Ihnen gewünschten Reihenfolge erscheinen (ansonsten sind sie standardmäßig alphabetisch sortiert). Der Faktordatentyp ist am besten für Kategorien geeignet, die eine bestimmte Anzahl von Ebenen haben (z.B. “Gold”, “Silber”, “Bronze”).\n\n\n\nfactor Variable\n\ncategorical_factor &lt;- factor(levels = c(1, 2, 3), labels = c(\"Gold\", \"Silber\", \"Bronze\"))\n\ncategorical_factor\n\n\nfactor()\nLevels: Gold Silber Bronze\n\n\n\n\nResult\nInteractive\n\n\n\n1 + 1\n\n[1] 2\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n8.3.3 Daten und Zeiten\nDaten und Zeiten sind ein Sonderfall von Variablen. Sie können sich wie kategoriale oder kontinuierliche Variablen verhalten, und es gibt spezielle Möglichkeiten, sie zu plotten. Daten und Zeiten können schwierig zu handhaben sein, aber das [lubridate(https://lubridate.tidyverse.org/) Paket bietet Funktionen, um Ihnen dabei zu helfen.\n\n# das aktuelle Datum\nlubridate::today()\n\n[1] \"2024-08-26\"\n\n\n\n# das aktuelle Datum\nlubridate::today() -  as.Date(\"2024-01-01\")\n\nTime difference of 238 days\n\n\n\n# das aktuelle Datum und die aktuelle Uhrzeit in der GMT-Zeitzone\nlubridate::now(tzone = \"GMT\")\n\n[1] \"2024-08-26 07:14:26 GMT\"\n\n\nWir gehen hier nicht näher auf diesen Datentyp ein.\n\n\n\n\n\n\nTesten Sie Ihr Verständnis\n\n\n\nKehren Sie zum Haustierdatensatz zurück, welcher Variablentyp ist in jeder Spalte? Sie können die Funktion glimpse() verwenden, um eine Liste der Spaltennamen, ihrer Datentypen und der ersten Werte in jeder Spalte anzuzeigen - hier ist die Ausgabe von glimpse() auf dem Haustierdatensatz.\n\nglimpse(pets)\n\nRows: 4\nColumns: 6\n$ name      &lt;chr&gt; \"Darwin\", \"Oy\", \"Khaleesi\", \"Bernie\"\n$ owner     &lt;chr&gt; \"Lisa\", \"Lisa\", \"Emily\", \"Phil\"\n$ species   &lt;fct&gt; ferret, ferret, cat, dog\n$ birthdate &lt;date&gt; 1998-04-02, NA, 2014-10-01, 2017-06-01\n$ weight    &lt;dbl&gt; 1.2, 2.9, 4.5, 32.0\n$ rating    &lt;fct&gt; a little evil, very good, very good, very good\n\n\n\n\n\n\n\n\n\nSpalte\nVariablentyp\nDatentyp\n\n\n\nname\n\ncontinuous\nnominal\nordinal\ndate\n\nnumeric\ncharacter\nfactor\ndate\n\n\nowner\n\ncontinuous\nnominal\nordinal\ndate\n\nnumeric\ncharacter\nfactor\ndate\n\n\nspecies\n\ncontinuous\nnominal\nordinal\ndate\n\nnumeric\ncharacter\nfactor\ndate\n\n\nbirthdate\n\ncontinuous\nnominal\nordinal\ndate\n\ncontinuous\nnominal\nordinal\ndate\n\n\nweight\n\ncontinuous\nnominal\nordinal\ndate\n\nnumeric\ncharacter\nfactor\ndate\n\n\nrating\n\ncontinuous\nnominal\nordinal\ndate\n\nnumeric\ncharacter\nfactor\ndate",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#erstellen-von-plots",
    "href": "08-data-viz.html#erstellen-von-plots",
    "title": "8  Datenvisualisierung",
    "section": "\n8.4 Erstellen von Plots",
    "text": "8.4 Erstellen von Plots\nEs gibt mehrere Ansätze zur Datenvisualisierung in R; in diesem Kurs werden wir das beliebte Paket ggplot2 verwenden, das Teil der größeren tidyverse-Sammlung von Paketen ist. Eine Grammatik der Grafiken (das “gg” in “ggplot”) ist eine standardisierte Art, die Komponenten einer Grafik zu beschreiben. ggplot2 verwendet eine geschichtete Grammatik der Grafiken, bei der Plots in einer Reihe von Schichten (“layers”) aufgebaut werden. Es kann hilfreich sein, sich jeden Plot als mehrere Elemente vorzustellen, die halbtransparent übereinander liegen.\nFigure 8.1 zeigt die Entwicklung eines einfachen Streudiagramms mit diesem geschichteten Ansatz. Zuerst wird der Plot-Raum erstellt (Schicht 1); die Variablen werden angegeben (Schicht 2); die Art der Visualisierung (bekannt als geom), die für diese Variablen gewünscht wird, wird angegeben (Schicht 3) - in diesem Fall wird geom_point() aufgerufen, um einzelne Datenpunkte zu visualisieren; ein zweites Geom wird hinzugefügt, um eine Linie der besten Anpassung einzusch\nließen (Schicht 4), die Achsenbeschriftungen werden für eine bessere Lesbarkeit bearbeitet (Schicht 5), und schließlich wird ein Thema angewendet, um das Gesamterscheinungsbild des Plots zu ändern (Schicht 6).\n\n\n\n\n\n\n\nFigure 8.1: Evolution eines geschichteten Plots\n\n\n\n\nJede Schicht ist unabhängig und individuell anpassbar. Beispielsweise können die Größe, Farbe und Position jeder Komponente angepasst werden, oder man könnte beispielsweise das erste Geom (die Datenpunkte) entfernen, um nur die Linie der besten Anpassung zu visualisieren, indem man einfach die Schicht entfernt, die die Datenpunkte zeichnet (Figure 8.2). Die Verwendung von Schichten erleichtert den schrittweisen Aufbau komplexer Plots und die Anpassung oder Erweiterung von Plots aus vorhandenem Code.\n\n\n\n\n\n\n\nFigure 8.2: Endplot mit entfernter Streudiagramm-Schicht.\n\n\n\n\n\n8.4.1 Plotdaten laden\nUm ein Gefühl für ‘ggplot’ zu bekommen, werden wir den obigen Plot Schritt-für-Schritt zusammen nachbauen. Als erstes laden wir die Daten:\n\nsurvey_data &lt;- read_csv(\"https://psyteachr.github.io/ads-v2/data/survey_data.csv\")\n\nRows: 707 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): caller_id, employee_id, issue_category\ndbl  (3): wait_time, call_time, satisfaction\ndttm (1): call_start\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nread_csv() zeigt uns direkt, wie viele Zeilen uns Spalten die eingelsenen Daten haben und mit welchem Datentyp die Zeilen gespeichert wurden (“Column specification”).\nBei diesen Daten handelt es sich um simulierte Daten einer Kundenzufriedenheitsumfrage eines Callcenters. Bevor wir die Daten plotten, müssen wir uns mit ihnen vertraut machen. Was genau enthalten die Daten? Hier repräsentiert jede Zeile einen Anruf an das Zentrum.\n\n\ncaller_id ist eine einzigartige ID für jeden Anrufer\n\nemployee_id ist eine einzigartige ID für jeden Mitarbeiter, der Anrufe entgegennimmt\n\ncall_start ist das Datum und die Uhrzeit, zu der der Anruf einging\n\nwait_time ist die Anzahl der Sekunden, die der Anrufer warten musste\n\ncall_time ist die Anzahl der Sekunden, die der Anruf dauerte, nachdem der Mitarbeiter abgehoben hatte\n\nissue_category ist, ob das Problem technischer Natur war, Verkauf, Rücksendungen oder anderes\n\nsatisfaction ist die Kundenzufriedenheitsbewertung auf einer Skala von 1 (sehr unzufrieden) bis 5 (sehr zufrieden)\n\nWenn man die Spaltentypen beim Einlesen nicht spezifiziert, werden Datenimportfunktionen einfach raten, um welche Typen es sich handelt, und normalerweise standardmäßig auf Double für Spalten mit Zahlen und Character für Spalten mit Buchstaben setzen. Verwenden Sie die Funktion spec(), um alle Spaltentypen herauszufinden und sie bei Bedarf zu bearbeiten.\n\nspec(survey_data)\n\ncols(\n  caller_id = col_character(),\n  employee_id = col_character(),\n  call_start = col_datetime(format = \"\"),\n  wait_time = col_double(),\n  call_time = col_double(),\n  issue_category = col_character(),\n  satisfaction = col_double()\n)\n\n\nLassen Sie uns issue_category als Faktor festlegen und die Reihenfolge der Kategorien festlegen. Standardmäßig ordnet R die Kategorien eines Faktors alphanumerisch. Oft möchte man die Reihenfolge jedoch selber festlegen. In diesen Daten macht es am meisten Sinn, die Kategorie “other” am Ende der Liste zu haben. Nachdem Sie die Spaltentypen aktualisiert haben, müssen Sie die Daten erneut importieren, indem Sie den read_csv()-Code anpassen, um das Argument col_types auf die neuen Spaltentypen zu setzen.\n\n\n\n\n\n\nDefinieren Sie Objekte, bevor Sie sie verwenden\n\n\n\nDa read_csv() das Objekt survey_col_types verwenden wird, müssen Sie survey_col_types erstellen, bevor Sie den angepassten read_csv()-Code ausführen. Wenn Sie jemals Ihren Code anpassen müssen, versuchen Sie, über die Reihenfolge nachzudenken, in der der Code ausgeführt wird, wenn Sie von vorne beginnen, und stellen Sie sicher, dass er angemessen organisiert ist.\n\n\n\n# aktualisierte Spaltentypen\nsurvey_col_types &lt;- cols(\n  caller_id = col_character(),\n  employee_id = col_character(),\n  call_start = col_datetime(format = \"\"),\n  wait_time = col_double(),\n  call_time = col_double(),\n  issue_category = col_factor(levels = c(\"tech\", \"sales\", \"returns\", \"other\")),\n  satisfaction = col_integer()\n)\n\n# Daten erneut importieren mit korrekten Spaltentypen\nsurvey_data &lt;- read_csv(\"https://psyteachr.github.io/ads-v2/data/survey_data.csv\",\n                        col_types = survey_col_types)\n\n\n8.4.2 Plot-Setup\n\n8.4.2.1 Daten\nJeder Plot beginnt mit der Funktion ggplot() und einem Datensatz. Für Übungszwecke ist es zu Beginn gut, den Plot schrittweise aufzubauen. Wie spezifizieren als ersten Schritt also nur, welche Daten für den Plot verwendet werden sollen. Dies genriert ein weisses Feld, sozusagen ein Platzhalter für den zu erschaffenden Plot.\n\nggplot(data = survey_data)\n\n\n\n\n\n\nFigure 8.3: Ein leerer ggplot.\n\n\n\n\n\n8.4.2.2 Mapping\nDas nächste argument zu ggplot() ist das mapping. Dies teilt dem Plot mit, welche Spalten/Variablen in den Daten durch welche Aspekte des Plots repräsentiert werden sollen. Diese Aspekte oder “Ästhetiken” werden innerhalb der Funktion aes() aufgelistet. Dabei handelt es sich um Sachen wie die x-Achse, y-Achse, Linienfarbe, Objektfüllung oder Linienstil.\nIm Folgenden sagen wir ggplot durch das mapping Argument via die Funktion aes, dass die Variable wait_time auf der x-Achse und die Variable call_time auf der y-Achse abgebildet werden soll.\nLegen Sie die Argumente x und y auf die Namen der Spalten fest, die Sie auf diesen Achsen plotten möchten. Hier möchten wir die Wartezeit auf der x-Achse und die Anrufzeit auf der y-Achse plotten. Dies füllt den Plot nun mit zwei Beschrifteten Achsen. In einem nächsten Schritt werden wir den Plot mit sogenannten geoms füllen.\n\n# den Plot mit Mapping einrichten\nggplot(\n  data = survey_data, \n  mapping = aes(x = wait_time, y = call_time)\n)\n\n\n\n\n\n\nFigure 8.4: Ein leerer Plot mit zugeordneten x- und y-Achsen.\n\n\n\n\n\n\n\n\n\n\nggplot-Argumentnamen\n\n\n\nIm obigen Beispiel haben wir die Namen der arguments data und mapping ausgeschrieben, aber in der Praxis lassen fast alle diese weg. Stellen Sie einfach sicher, dass Sie die Daten und das Mapping in der richtigen Reihenfolge platzieren.\n\nggplot(survey_data,  aes(x = wait_time, y = call_time))\n\n\n\n\n8.4.2.3 Geoms\nNun können wir unsere Plot-Elemente schichtenweise hinzufügen. Diese Elemente werden als geoms bezeichnet und ihre Funktionen beginnen mit geom_. Man fügt Schichten zum Basis-Plot, der von ggplot() erstellt wurde, mit einem Plus (+) hinzu.\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point() # Streudiagramm\n\n\n\n\n\n\nFigure 8.5: Einen Streudiagramm mit geom_point() hinzufügen.\n\n\n\n\n\n\n\n\n\n\nPosition des +\n\n\n\n\n\nEtwas ärgerlicherweise muss das Plus am Ende der vorherigen Zeile stehen, nicht am Anfang der nächsten Zeile. Wenn Sie diesen Fehler machen, wird die erste Zeile des Codes ausgeführt, um die Basisschicht zu produzieren, aber dann erhalten Sie die folgende Fehlermeldung, anstatt geom_point() hinzuzufügen.\n\nggplot(survey_data, aes(x = wait_time, y = call_time))\n\n\n\n\n\n\n+ geom_point() # Streudiagramm\n\nError:\n! Cannot use `+` with a single argument.\nℹ Did you accidentally put `+` on a new line?\n\n\n\n\n\n\n8.4.2.4 Mehrere Geoms\nEin Teil der Stärke von ggplot2 ist, dass man mehr als ein Geom zu einem Plot hinzufügen kann, indem man einfach weitere geom_ Teile spezifiziert. Geoms, die zuerst spezifiziert werden, werden auch zuerst angezeigt. Das kann dazu führen, dass spätere hinzugefügte Geoms früher hinzugefügte Geoms überdecken:\n\n# Punkte zuerst\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point() + # Streudiagramm\n  geom_smooth(method = lm) # Linie der besten Anpassung\n\n# Linie zuerst\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_smooth(method = lm) + # Linie der besten Anpassung\n  geom_point() # Streudiagramm\n\n\n\n\n\n\n\n\nFigure 8.6: Punkte zuerst gegen Linie zuerst.\n\n\n\n\n\n8.4.2.5 Speichern von Plots\nGenau wie man Zahlen und Datentabellen als Objekte speichern kann, kann man auch den durchggplot() erstellten plot speichern. Der untenstehende Code produziert dieselben Plots, die wir oben erstellt haben, speichert sie aber zu Objekten namens point_first und line_first. Wenn wir nur diesen Code ausführen, werden die Plots nicht angezeigt wie zuvor. Stattdessen sehen Sie die Objektnamen im Umgebungsbereich.\n\npoint_first &lt;- \n  ggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point() + # Streudiagramm\n  geom_smooth(method = lm) # Linie der besten Anpassung\n  \nline_first &lt;-\n  ggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_smooth(method = lm) + # Linie der besten Anpassung\n  geom_point() # Streudiagramm\n\nDiese plots sind nun also Objekte, die wir zu einem späteren Zeitpunkt wieder abrufen oder weiterbearbeiten können.\nUm die Plots anzuzeigen, rufen wir die Objekte beim Namen auf. Dies gibt jeden Plot separat aus.\n\npoint_first # ersten Plot anzeigen\nline_first # zweiten Plot anzeigen\n\n\n8.4.2.6 Kombinieren von Plots\nEiner der Gründe, wieso wir Plots in Objekten speichern besteht darin, dass man mehrere Plots mithilfe von Funktionen aus dem patchwork-Paket kombinieren kann. Der untenstehende Code produziert den schon oben gesehenen Plot (Figure 8.6), indem er die beiden Plots mit + kombiniert und dann angibt, dass wir die Plots auf einer einzigen Reihe mit dem nrow-Argument in plot_layout() produzieren möchten.\n\n# fügt Plots zusammen in 1 Reihe\npoint_first + line_first + plot_layout(nrow = 1)\n\n\n\n\n\n\nFigure 8.7: Kombinieren von Plots mit patchwork.\n\n\n\n\n\n\n\n\n\n\nVersuchen Sie, nrow auf 2 zu ändern\n\n\n\n\n\n\n\n8.4.3 Anpassen von Plots\nEs gibt nahezu endlose Möglichkeiten, ggplots anzupassen. Wir werden hier einige der grundlegenden Anpassungen behandeln.\n\n8.4.3.1 Styling von Geoms\nWir sollten definitiv die Linie vor den Punkten platzieren, aber die Punkte sind immer noch etwas dunkel. Wenn man den allgemeinen Stil eines Geoms ändern möchten, kann man die Argumente colour, alpha, shape, size und linetype innerhalb der Geom-Funktion festlegen. Es gibt viele verschiedene Werte, auf die man diese einstellen kann; ?sec-plotstyle gibt Details dazu. Probieren Sie verschiedene Werte unten aus und finden Sie heraus, was die default values für shape und size sind.\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2, # 20 % Transparenz\n             shape = 18,  # solider Diamant\n             size = 2) + \n  geom_smooth(method = lm, \n              formula = y~x, # Formel zum Zeichnen der Linie, \n              # Festlegung von Methode und Formel vermeidet eine ärgerliche Nachricht\n              colour = rgb(0, .5, .8),\n              linetype = 3) \n\n\n\n\n\n\nFigure 8.8: Ändern von Geom-Stilen.\n\n\n\n\n\n\n\n\n\n\nÄsthetik insgesamt versus nach Kategorie festlegen\n\n\n\nDiese Methode dient nur dazu, den Stil aller Elemente zu ändern, die mit diesem Geom erstellt wurden. Wenn Sie möchten, dass zum Beispiel Punkte je nach Ausgabekategorie unterschiedliche Farben haben, legen Sie das Argument colour = issue_category innerhalb der Funktion aes() für das Mapping fest. Sie können die verwendeten Farben mit scale_-Funktionen anpassen, die Sie unten und in ?sec-plotstyle lernen werden).\n\n\n\n8.4.3.2 Achsen formatieren\nNun müssen wir die Achsen ordentlicher beschriften Es gibt mehrere Funktionen, mit denen man die Achsenbeschriftungen ändern kann, aber die leistungsfähigsten sind die scale_-Funktionen. Sie müssen eine Skalenfunktion verwenden, die zu den Daten passt, die Sie auf dieser Achse plotten, und hier wird es besonders wichtig zu wissen, mit welchem Datentyp man arbeitet. Beide Achsen hier sind continuous, daher verwenden wir scale_x_continuous() und scale_y_continuous().\nDas Argument name ändert die Achsenbeschriftung. Das Argument breaks legt die Haupteinheiten fest und benötigt einen vector möglicher Werte, der auch über den Bereich der Daten hinausgehen kann. Die Funktion seq() erstellt eine Folge von Zahlen from einer to einer anderen by festgelegten Schritten:\n\n\n\nBeispiel von seq()\n\nseq(from = 0, to = 600, by = 60)\n\n\n [1]   0  60 120 180 240 300 360 420 480 540 600\n\n\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2) + \n  geom_smooth(method = lm, \n              formula = y~x, \n              colour = rgb(0, .5, .8)) +\n  # Achsenbeschriftungen und Unterbrechungen anpassen\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\", \n                     breaks = seq(from = 0, to = 600, by = 60)) +\n  scale_y_continuous(name = \"Anrufzeit (Sekunden)\",\n                     breaks = seq(from = 0, to = 600, by = 30))\n\n\n\n\n\n\nFigure 8.9: Formatierung von Plotachsen mit scale_-Funktionen.\n\n\n\n\n\n\n\n\n\n\nKleinere Unterbrechungen\n\n\n\nÜberprüfen Sie die Hilfe zu ?scale_x_continuous, um zu sehen, wie Sie die kleineren Einheiten festlegen oder angeben würden, wie viele Unterbrechungen Sie möchten.\n\n\n\n\n\n\n\n\nDie labs Funktion\n\n\n\nMan kann die Achsen auch über die labs Funktion beschriften. Dies kann dann nützlich sein, wenn man an den Achsen sonst nichts anpassen muss:\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2) + \n  geom_smooth(method = lm, \n              formula = y~x, \n              colour = rgb(0, .5, .8)) +\n  labs(x = \"Wartezeit (Sekunden)\",\n       y = \"Anrufzeit (Sekunden)\")\n\n\n\n\n\n\n\n\n\n\n8.4.3.3 Achsengrenzen\nWenn man die minimalen und maximalen Werte auf einer Achse ändern möchte, verwendet man die Funktion coord_cartesian(). Viele Plots sind sinnvoller, wenn die minimalen und maximalen Werte den Bereich möglicher Werte darstellen, auch wenn diese Werte nicht in den Daten vorhanden sind. Hier können Warte- und Anrufzeiten nicht weniger als 0 Sekunden betragen, also legen wir die Minimalwerte auf 0 und die Maximalwerte auf die erste Unterbrechung über dem höchsten Wert fest.\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2) + \n  geom_smooth(method = lm, \n              formula = y~x, \n              colour = rgb(0, .5, .8)) +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\", \n                     breaks = seq(from = 0, to = 600, by = 60)) +\n  scale_y_continuous(name = \"Anrufzeit (Sekunden)\",\n                     breaks = seq(from = 0, to = 600, by = 30)) +\n  # Achsengrenzen festlegen\n  coord_cartesian(xlim = c(0, 360), \n                  ylim = c(0, 180))\n\n\n\n\n\n\nFigure 8.10: Ändern der Achsengrenzen.\n\n\n\n\n\n\n\n\n\n\nGrenzen mit der scale_-Funktion festlegen\n\n\n\nSie können auch das Argument limits innerhalb der scale_-Funktionen festlegen, aber dies entfernt tatsächlich alle Daten, die außerhalb dieser Grenzen liegen, anstatt Ihren Plot zu beschneiden, und dies kann das Erscheinungsbild bestimmter Plot-Typen wie Violin-Plots und Dichtegraphen ändern. Deshalb sollte die scale_ Funktion dafür nicht verwendet werden.\n\n\n\n8.4.3.4 Themes\nDamit man für das ästhetische “Finetuning” des Plots nicht immer alle Werte selber spezifizieren muss, gibt es eine Reihe von sogenannten Themes die Plots in einem besetimmten Design erscheinen lassen. ggplot2 kommt mit mehreren integrierten Themen, wie theme_minimal() und theme_bw(), aber das ggthemes Paket bietet noch mehr Themen, die verschiedenen Softwareprogrammen entsprechen, wie GoogleDocs, Excel oder Stata. Im folgenden wenden wir das Excel theme an und ändern die Schriftgrösse mit dem Argument base_size.\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2) + \n  geom_smooth(method = lm, \n              formula = y~x, \n              colour = rgb(0, .5, .8)) +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\", \n                     breaks = seq(from = 0, to = 600, by = 60)) +\n  scale_y_continuous(name = \"Anrufzeit (Sekunden)\",\n                     breaks = seq(from = 0, to = 600, by = 30)) +\n  coord_cartesian(xlim = c(0, 360), \n                  ylim = c(0, 180)) +\n  # das Theme ändern\n  ggthemes::theme_excel(base_size = 20)\n\n\n\n\n\n\nFigure 8.11: Ändern des Themes zum Google Docs-Stil.\n\n\n\n\nDas Resultat ist nicht gerade ansprechend. Das steht auch ausdrücklich in der Dokumentation der Funktion ggthemes::theme_excel: “Theme to replicate the ugly monstrosity that was the old gray-background Excel chart. Please never use this.”\nVersuchen wir es also mit einem anderen theme:\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2) + \n  geom_smooth(method = lm, \n              formula = y~x, \n              colour = rgb(0, .5, .8)) +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\", \n                     breaks = seq(from = 0, to = 600, by = 60)) +\n  scale_y_continuous(name = \"Anrufzeit (Sekunden)\",\n                     breaks = seq(from = 0, to = 600, by = 30)) +\n  coord_cartesian(xlim = c(0, 360), \n                  ylim = c(0, 180)) +\n  # das Theme ändern\n  ggthemes::theme_economist(base_size = 20)\n\n\n\n\n\n\nFigure 8.12: Ändern des Themes zum Google Docs-Stil.\n\n\n\n\nDer Plot sieht mit dem Theme der Zeitschrift Economist schon deutlich besser aus.\n\n8.4.3.5 Theme-Anpassungen\nWenn wir mit einem Theme immer noch nicht ganz zufrieden sind, können wir es mit der Funktion themes() weiter anpassen. Überprüfen Sie die Hilfe für diese Funktion, um alle möglichen Optionen zu sehen (mit ?themes, die Liste der zu ändernden Elemente ist ziemlich lang). Oft will man, anstatt ein Elment zu ändern, ein Element komplett entfernen. Dies tut man, indem man das relvante Argument auf element_blank() setzt. Unten entfernen wir die x-Achsenlinie und den Plot-Hintergrund:\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2) + \n  geom_smooth(method = lm, \n              formula = y~x, \n              colour = rgb(0, .5, .8)) +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\", \n                     breaks = seq(from = 0, to = 600, by = 60)) +\n  scale_y_continuous(name = \"Anrufzeit (Sekunden)\",\n                     breaks = seq(from = 0, to = 600, by = 30)) +\n  coord_cartesian(xlim = c(0, 360), \n                  ylim = c(0, 180)) +\n  theme_gdocs(base_size = 11) +\n  # Theme-Elemente anpassen\n  theme(axis.line.x = element_blank(),\n        plot.background = element_blank())\n\n\n\n\n\n\nFigure 8.13: Anpassen des Themes, um die x-Achsenlinie und den Hintergrundumriss zu entfernen.\n\n\n\n\n\n8.4.4 Plotbeschriftungen\nOft möchte man Plots auch mit Titel und/oder Untertitel versehen. Dies können wir mit der bereits kennengelernten Funktion labs tun:\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(colour = \"dodgerblue\", \n             alpha = 0.2) + \n  geom_smooth(method = lm, \n              formula = y~x, \n              colour = rgb(0, .5, .8)) +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\", \n                     breaks = seq(from = 0, to = 600, by = 60)) +\n  scale_y_continuous(name = \"Anrufzeit (Sekunden)\",\n                     breaks = seq(from = 0, to\n\n = 600, by = 30)) +\n  coord_cartesian(xlim = c(0, 360), \n                  ylim = c(0, 180)) +\n  theme_gdocs(base_size = 11) +\n  theme(axis.line.x = element_blank(),\n        plot.background = element_blank()) +\n  labs(title = \"Die Beziehung zwischen Wartezeit und Anrufzeit\",\n       subtitle = \"Anrufdaten 2020\",\n       caption = \"Abbildung 1. Mit zunehmender Wartezeit steigt die Anrufzeit.\")\n\n\n\n\n\n\nFigure 8.14: Hinzufügen eines Titels, Untertitels und einer Bildunterschrift.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#geeignete-plots",
    "href": "08-data-viz.html#geeignete-plots",
    "title": "8  Datenvisualisierung",
    "section": "\n8.5 Geeignete Plots",
    "text": "8.5 Geeignete Plots\nDer Aufbau von Plots, wie wir ihn gerade gelernt haben, ist immer gleich. Man muss jedoch die Art des Plots den Daten(typen) anpassen, die man plotten will. Entsprechend ist dieser Abschnitt nach Datentypen strukturiert.\nDer ggplot2-Spickzettel ist eine großartige Ressource die dabei hilft, Plots zu finden, die zu den Daten passen.\nDie untenstehenden Beispiele verwenden alle dieselben Kundenzufriedenheitsdaten, aber jeder Plot kommuniziert etwas anderes.\nEs wird nicht erwartet, dass Sie sich alle Plot-Typen oder die Methoden zur Anpassung merken, aber es wird hilfreich sein, den Code in den folgenden Beispielen selbst auszuprobieren, indem Sie Werte ändern, um Ihr Verständnis zu testen.\n\n8.5.1 Kategorien zählen\n\n8.5.1.1 Balkendiagramm\nWenn Sie die Anzahl Beobachtungen pro Kategorie zählen möchten, können Sie geom_bar() verwenden. Sie müssen nur eine x-Zuordnung zu geom_bar() bereitstellen, denn standardmäßig verwendet geom_bar() die Anzahl der Beobachtungen in jeder Gruppe von x als Wert für y, sodass Sie ggplot nicht mitteilen müssen, was auf der y-Achse stehen soll.\n\nggplot(survey_data, aes(x = issue_category)) +\n  geom_bar()\n\n\n\n\n\n\nFigure 8.15: Ein einfaches Balkendiagramm.\n\n\n\n\n\n\n\n\n\n\nAnpassen des Aussehens von Balkendiagrammen\n\n\n\nSie möchten wahrscheinlich einige Dinge anpassen, wie die Farben, die Reihenfolge der Spalten und ihre Beschriftungen. Untersuchen Sie den untenstehenden Code und versuchen Sie, ihn Schicht für Schicht auszuführen, um herauszufinden, wo sich diese Dinge ändern. Die Funktionen scale_fill_manual() und scale_x_discrete() sind neu, funktionieren aber auf die gleiche Weise wie die anderen scale_-Funktionen. Sie lernen mehr darüber in ?sec-custom-viz.\n\n\n\n\n\n\n\nCode\n\n\n\n\n\nggplot(survey_data, aes(x = issue_category, \n                        fill = issue_category)) +\n  geom_bar() +\n  scale_x_discrete(\n    # Achsentitel ändern\n    name = \"Issue-Kategorie\", \n    # Reihenfolge ändern\n    limits = c(\"tech\", \"returns\", \"sales\", \"other\"), \n    # Beschriftungen ändern\n    labels = c(\"Technisch\", \"Rückgaben\", \"Verkäufe\", \"Andere\") \n  ) +\n  scale_fill_manual(\n    # Farben ändern\n    values = c(tech = \"goldenrod\", \n                returns = \"darkgreen\", \n                sales = \"dodgerblue3\", \n                other = \"purple3\"),\n    # die Legende entfernen\n    guide = \"none\" \n  ) +\n  scale_y_continuous(\n    name = \"\", # Achsentitel entfernen\n    # den Raum oberhalb und unterhalb der y-Achse entfernen\n    expand = expansion(add = 0)\n  ) +\n  # Minimum = 0, Maximum = 350\n  coord_cartesian(ylim = c(0, 350)) + \n  ggtitle(\"Anzahl der Probleme pro Kategorie\") # einen Titel hinzufügen\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.5.1.2 Säulendiagramm\nWenn Ihre Daten bereits eine Spalte mit der Anzahl enthalten, die Sie plotten möchten, können Sie geom_col() verwenden, um sie zu plotten. Wir können die Funktion count() verwenden, um eine Tabelle mit einer Zeile für jede issue_category und einer Spalte namens n mit der Anzahl der Beobachtungen in dieser Kategorie zu erstellen.\n\ncount_data &lt;- count(survey_data, issue_category)\n\n\n\nissue_category\nn\n\n\n\ntech\n311\n\n\nsales\n88\n\n\nreturns\n232\n\n\nother\n76\n\n\n\nDas Mapping für geom_col() erfordert, dass Sie sowohl die x- als auch die y-Ästhetik festlegen. Setzen Sie y = n, weil wir die Anzahl der Probleme in jeder Kategorie plotten möchten, und diese Information befindet sich in der Spalte namens n.\n\nggplot(count_data, aes(x = issue_category, y = n)) +\n  geom_col()\n\n\n\n\n\n\nFigure 8.16: Ein einfaches Säulendiagramm.\n\n\n\n\n\n8.5.1.3 Tortendiagramm\nTortendiagramme sind eine irreführende Form der Datenvisualisierung, daher werden wir sie nicht behandeln. Wir werden andere Methoden behandeln, die sich besser für die Visualisierung von Anteilen handeln.\n\n\n\n\n\n\nTesten Sie Ihr Verständnis\n\n\n\nHier ist eine kleine Datentabelle.\n\n\ncountry\npopulation\nisland\n\n\n\nNordirland\n1,895,510\nIrland\n\n\nWales\n3,169,586\nGroßbritannien\n\n\nRepublik Irland\n4,937,786\nIrland\n\n\nSchottland\n5,466,000\nGroßbritannien\n\n\nEngland\n56,550,138\nGroßbritannien\n\n\n\n\nWelches Geom würden Sie verwenden, um die Bevölkerung für jedes der 5 Länder zu plotten? \ngeom_bar\ngeom_col\n\n\n\n\nWelches Mapping würden Sie verwenden?\n\naes(x = country, y = population)aes(x = population, y = country)aes(x = country)aes(x = island)aes(y = population)\n\n\n\n\n\nWelches Geom würden Sie verwenden, um die Anzahl der Länder auf jeder Insel zu plotten? \ngeom_bar\ngeom_col\n\n\n\n\nWelches Mapping würden Sie verwenden?\n\naes(x = country, y = population)aes(x = population, y = country)aes(x = country)aes(x = island)aes(y = population)\n\n\n\n\n\n\n\n8.5.2 Plots mit einer kontinuierlichen Variable\nWenn Sie eine kontinuierliche Variable haben, wie die Anzahl der Sekunden, die Anrufer warten mussten, können Sie geom_histogram() verwenden, um die Verteilung der Variable zu visualisieren. Genau wie bei geom_bar() muss man dabei nur die x-Variable angeben.\nEin Histogramm teilt die Daten in “Bins” entlang der x-Achse auf und zeigt die Anzahl der Beobachtungen in jedem Bin entlang der y-Achse.\n\nggplot(survey_data, aes(x = wait_time)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nFigure 8.17: Histogramm der Wartezeiten.\n\n\n\n\nSie sollten immer die binwidth oder die Anzahl der bins auf etwas Sinnvolles für Ihre Daten festlegen (wie per Mitteilung angegeben ist der Default 30 bins, was mehr oder meist weniger sinnvoll sein kann). Sie müssen möglicherweise einige Optionen ausprobieren, bevor Sie etwas finden, das gut aussieht und die Verteilung der Variable gut darstellt – versuchen Sie, die Werte von binwidth und bins unten zu ändern, um zu sehen, was am besten funktioniert.\n\n# Breite jeder Leiste anpassen\nggplot(survey_data, aes(x = wait_time)) +\n  geom_histogram(binwidth = 30)\n\n# Anzahl der Leisten anpassen\nggplot(survey_data, aes(x = wait_time)) +\n  geom_histogram(bins = 5)\n\nStandardmäßig beginnen die Balken zentriert auf 0, also wenn binwidth auf 30 eingestellt ist, würde der erste Balken -15 bis 15 Sekunden umfassen, was keinen Sinn macht. Wir können boundary = 0 setzen, damit jeder Balken 30-Sekunden-Inkremente ab 0 darstellt.\n\nggplot(survey_data, aes(x = wait_time)) +\n  geom_histogram(binwidth = 30, boundary = 0)\n\n\n\n\n\n\nFigure 8.18: Ein Histogramm mit der Grenze auf 0 gesetzt.\n\n\n\n\nSchließlich ist der Standardstil von grauen Balken hässlich, also können Sie das ändern, indem Sie fill und colour festlegen, sowie scale_x_continuous() verwenden, um die Achsenbeschriftungen zu aktualisieren.\n\nggplot(survey_data, aes(x = wait_time)) +\n  geom_histogram(binwidth = 15, \n                 boundary = 0, \n                 fill = \"white\", \n                 color = \"black\") +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\",\n                     breaks = seq(0, 600, 60))\n\n\n\n\n\n\nFigure 8.19: Histogramm mit benutzerdefinierten Stilen.\n\n\n\n\n\n\n\n\n\n\nTesten Sie Ihr Verständnis\n\n\n\nStellen Sie sich vor, Sie haben eine Tabelle mit der Bevölkerung für jedes Land der Welt mit den Spalten country und population. Wir werden uns nur die 76 Länder mit Bevölkerungen unter einer Million ansehen.\n\n\n\n\n\n\n\n\n\n\nWie würden Sie das Mapping für diesen Plot festlegen?\n\naes(x = country, y = population)aes(x = population, y = country)aes(x = population)aes(x = population, y = count)\n\n\n\n\n\nWas ist die binwidth des Histogramms? \n1\n100\n100K\n1M\n\n\n\n\n\n\n\n\n\n\nAnpassung der Achsenbeschriftung\n\n\n\n\n\nWenn Sie neugierig sind, wie wir die x-Achsenbeschriftungen auf “100K” anstelle von “100000” eingestellt haben, müssen Sie nur einen Vektor von labels derselben Länge wie breaks hinzufügen.\n\n  scale_x_continuous(breaks = seq(0, 1e6, 1e5),\n                     labels = c(paste0(0:9*100, \"K\"), \"1M\"))\n\n\n\n\n\n8.5.3 Gruppierte kontinuierliche Variablen\nEs gibt mehrere Möglichkeiten, kontinuierliche Daten über Gruppen hinweg zu vergleichen. Welche Sie wählen, hängt davon ab, was sie mit dem Plot zeigen möchten.\n\n8.5.3.1 Gestapeltes Histogramm\nIn vorherigen Plots haben wir fill rein aus optischen Gründen verwendet, z. B. haben wir die Farbe der Histogrammbalken geändert, um sie schöner zu machen. Sie können jedoch auch fill verwenden, um eine andere Variable darzustellen, so dass die Farben bedeutungsvoll werden.\nDas Festlegen der fill-Ästhetik im Mapping erzeugt unterschiedlich gefärbte Balken für jede Kategorie der fill-Variablen, in diesem Fall issue_category. Somit sehen wir die Verteilung der Wartezeit für jede issue_category. Dadurch lassen sich gut Unterschiede in den Wartezeiten zwischen den issue_category Kategorien erkennen.\n\nggplot(survey_data, aes(x = wait_time, fill = issue_category)) +\n  geom_histogram(boundary = 0, \n                 binwidth = 15,\n                 color = \"black\")\n\n\n\nHistogramm mit Kategorien, die durch Füllung dargestellt werden.\n\n\n\n\n\n\n\n\n\nArgumente innerhalb von aes()\n\n\n\nWenn Sie einen Aspekt festlegen, um die Daten darzustellen, tun Sie dies innerhalb der Funktion aes() für das Mapping, nicht als Argument zum Geom. Wenn Sie versuchen, dies in einem Geom zu setzen, erhalten Sie die folgende Fehlermeldung (es sei denn, Sie haben zufällig ein Objekt namens issue_category, das ein Farbwort ist).\n\nggplot(survey_data, aes(x = wait_time)) +\n  geom_histogram(boundary = 0, \n                 binwidth = 15, \n                 color = \"black\",\n                 fill = issue_category)\n\nError in eval(expr, envir, enclos): object 'issue_category' not found\n\n\n\n\n\n\n\n\n\n\nAlternative zum Histogramm\n\n\n\n\n\nDie Funktion geom_area() gibt einen ähnlichen Effekt, wenn stat = \"bin\".\n\n# Flächendiagramm\nggplot(survey_data, mapping = aes(x = wait_time, fill = issue_category)) +\n  geom_area(stat = \"bin\", \n            boundary = 0, \n            binwidth = 15, \n            color = \"black\")\n\n\n\nGestapeltes Flächendiagramm.\n\n\n\n\n\n\n\n8.5.3.2 Ausgewürfeltes Histogramm\nStandardmäßig werden die Kategorien übereinander gestapelt positioniert. Wenn Sie mehr als eine Verteilung vergleichen möchten, können Sie das Argument position von geom_histogram() auf “dodge” setzen, um die Balken für jede Gruppe nebeneinander statt übereinander zu platzieren. Dies kann jedoch mit mehreren Kategorien verwirrend aussehen.\n\n# ausgewürfeltes Histogramm\nggplot(survey_data, aes(x = wait_time, \n                        fill = issue_category,\n                        colour = issue_category))+\n  geom_histogram(boundary = 0, \n                 binwidth = 15, \n                 position = \"dodge\") +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\",\n                     breaks = seq(0, 600, 60))\n\n\n\n\n\n\nFigure 8.20: Ein Histogramm mit mehreren Gruppen.\n\n\n\n\n\n\n\n\n\n\nAlternative zum Häufigkeitsplot\n\n\n\n\n\nAlternativ können Sie geom_freqpoly() verwenden, um eine Linie zu zeichnen, die die Oberseite jedes Bins verbindet (siehe ?sec-freqpoly).\n\n# Häufigkeitsplot\nggplot(survey_data, aes(x = wait_time,\n                        colour = issue_category)) +\n  geom_freqpoly(binwidth = 15, \n                boundary = 0,\n                size = 1) +\n  scale_x_continuous(name = \"Wartezeit (Sekunden)\",\n                     breaks = seq(0, 600, 60))\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\nFigure 8.21: Ein Häufigkeitsplot mit mehreren Gruppen.\n\n\n\n\n\n\n\n\n8.5.3.3 Boxplot\nEine weitere Möglichkeit, Gruppen von kontinuierlichen Variablen zu vergleichen, sind Boxplots. Sie zeigen nicht die Form der Verteilung, sondern visualisieren einige aussagekräftige Statistiken darüber. Die mittlere Linie stellt den median dar; die Hälfte der Daten/Beobachtungen liegt über dieser Linie und die Hälfte darunter. Die Box umschließt das 25. bis 75. Perzentil der Daten, also fallen 50% der Daten in die Box. Die “Whisker”, die ober- und unterhalb der Box herausragen, erstrecken sich 1,5-mal so hoch wie die Box, obwohl Sie dies mit dem Argument coef ändern können. Die Punkte zeigen outliers – einzelne Datenpunkte, die außerhalb dieses Bereichs liegen.\nBoxplots können horizontal sein, wenn Sie die x- und y-Spalten tauschen, und es gibt viele andere Anpassungen, die Sie anwenden können.\n\nboxplot &lt;- ggplot(survey_data, aes(x = issue_category, y = wait_time)) +\n geom_boxplot() +\n  ggtitle(\"Standard-Vertikal-Boxplot\")\n\ncustom &lt;- ggplot(survey_data, aes(y = issue_category,x = wait_time)) +\n geom_boxplot(fill = \"grey80\", \n              outlier.colour = \"red\",\n              outlier.shape = 8,\n              coef = 1,   # Länge der Whisker relativ zur Box\n              varwidth = TRUE, # Breite proportional zur Stichprobengröße setzen\n              notch = TRUE) +\n  ggtitle(\"Angepasster Horizontal-Boxplot\")\n\nboxplot + custom\n\n\n\n\n\n\nFigure 8.22: Boxplots.\n\n\n\n\n\n\n\n\n\n\nIrreführende Balkendiagramme\n\n\n\n\n\nHäufig werden anstatt Verteilungen, wie zum Beispiel mit dem Boxplot, nur einzelne Statistiken, zum Beispiel der Mittelwert, geplottet. Dies kann sehr irreführend sein, da es die Verteilung der Rohwerte nicht veranschaulicht und die Unterschiede deshalb grösser aussehen können, als sie tatsächlich sind. So sehen die Unterschiede in den Mittelwerten im Plot unten links deutlich dramatischer aus, als dies aus den Daten eigentlich hervorgeht (vgl. Boxplot oben).\nDer Effekt sieht aber nur so dramatisch aus, weil die x-Achse nicht bei 0 beginnt. Plotten wir den gesamten Range der Daten (rechter plot) sehen wir, dass es fast keine Unterschiede gibt. Achten sie immer darauf, was sie mit einer Abbildung aussagen möchten. Und wie man sieht, kann man den plot entsprechend der gewünschten Aussage wählen. Später werden wir sehen, wie mann solche Plots mit Massen wie Konfidenzintervallen ergänzen kann, um dem etwas entgegenzuwirken.\n\n\n\n\n\n\n\nFigure 8.23: Plotten Sie kontinuierliche Daten nicht mit Säulendiagrammen. Sie sind nur für Zähldaten geeignet.\n\n\n\n\n\n\n\n\n\n\n\n\n\nTesten Sie Ihr Verständnis\n\n\n\n\n\n\n\n\n\n\n\n\nWie würden Sie den Plot erstellen? \ngeom_box()\ngeom_boxplot()\ngeom_violin()\ngeom_violinplot()\n\nWie sieht das Mapping für den Plot aus?\n\naes(x = employee_id, y = call_time, fill = employee_id)aes(x = employee_id, y = call_time, colour = call_time)aes(x = employee_id, y = call_time, colour = employee_id)aes(x = employee_id, y = call_time, fill = call_time)\n\n\nWelcher Mitarbeiter hat die längste mediane Anrufzeit? \ne01\ne02\ne03\ne04\ne05\ne06\ne07\ne08\ne09\ne10\n\nWelcher Mitarbeiter hat die längste Anrufzeit? \ne01\ne02\ne03\ne04\ne05\ne06\ne07\ne08\ne09\ne10\n\n\n\n\n\n8.5.4 Zwei kontinuierliche Variablen\nWenn Sie sehen möchten, wie zwei kontinuierliche Variablen zusammenhängen, legen Sie eine als x-Achse und die andere als y-Achse fest. Normalerweise, wenn eine Variable die andere verursacht, plotten Sie die Ursache auf der x-Achse und die Wirkung auf der y-Achse. Hier möchten wir sehen, ob längere Wartezeiten dazu führen, dass die Anrufe länger dauern.\n\n8.5.4.1 Streudiagramm\nDie Funktion zur Erstellung eines Streudiagramms heißt geom_point().\n\nggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point()\n\n\n\n\n\n\nFigure 8.24: Streudiagramm mit geom_point().\n\n\n\n\n\n8.5.4.2 Trendlinien\nIn Figure 8.1 haben wir die Beziehung zwischen Wartezeit und Anrufzeit mit einer Trendlinie betont, die durch geom_smooth() mit dem Argument method = lm erstellt wurde (“lm” steht für “lineares Modell”, also die Trendlinie einer linearen Regression). Sie können auch method = loess einstellen, um eine nichtlineare Beziehung zu visualisieren.\n\nlm_plot &lt;- \n  ggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(alpha = 0.2) +\n  geom_smooth(method = lm, formula = y~x) +\n  ggtitle(\"method = lm\")\n\nloess_plot &lt;- \n  ggplot(survey_data, aes(x = wait_time, y = call_time)) +\n  geom_point(alpha = 0.2) +\n  geom_smooth(method = loess, formula = y~x) +\n  ggtitle(\"method = loess\")\n\nlm_plot + loess_plot\n\n\n\n\n\n\nFigure 8.25: Verschiedene Möglichkeiten, die Beziehung zwischen zwei kontinuierlichen Variablen zu zeigen.\n\n\n\n\n\n\n\n\n\n\nFehler-Schattierung\n\n\n\nWenn es nicht viele Daten an den Extremen der x-Achse gibt, kann die Kurve sehr unsicher sein. Dies wird durch den breiteren schattierten Bereich dargestellt, was bedeutet, dass die wahre Beziehung irgendwo innerhalb dieses Bereichs liegen könnte. Fügen Sie das Argument se = FALSE zu geom_smooth() hinzu, um diese “Standardfehler”-Schattierung zu entfernen.\n\n\n\n8.5.4.3 Daten\nDie Spalte call_start enthält sowohl ein Datum als auch eine Uhrzeit, also verwenden wir die Funktion date() aus lubridate, um sie nur in ein Datum zu konvertieren. Wir benötigen es in diesem Format, um die x-Achse unten transformieren zu können.\n\nggplot(survey_data, aes(x = lubridate::date(call_start), \n                        y = satisfaction)) + \n  geom_smooth(method = lm, formula = y~x)\n\n\n\n\n\n\nFigure 8.26: Plotting dates.\n\n\n\n\nWir können scale_x_date() verwenden, um die date_breaks auf “1 Monat” Abstand einzustellen. Das Argument date_labels verwendet einen Code für verschiedene Datumsformate; Sie können die vollständige Liste der Möglichkeiten in der Hilfe für ?strptime sehen. Zum Beispiel bedeutet %b “Abgekürzter Monatsname”, während Sie für ein Format wie “2020/01/31” \"%Y/%m/%d\" ausprobieren könnten.\n\nggplot(survey_data, aes(x = lubridate::date(call_start), \n                        y = satisfaction)) +\n  geom_smooth(method = lm, formula = y~x) +\n  scale_x_date(name = \"\",\n               date_breaks = \"1 month\", \n               date_labels = \"%b\") +\n  scale_y_continuous(name = \"Kundenzufriedenheit\") +\n  ggtitle(\"Kundenzufriedenheit 2020\")\n\n\n\n\n\n\nFigure 8.27: Plotting dates with breaks one month apart.\n\n\n\n\n\n\n\n\n\n\nTesten Sie sich selbst\n\n\n\nEs sieht so aus, als würde die Kundenzufriedenheit im Laufe des Jahres abnehmen, aber ist diese Änderung bedeutend? Sehen Sie, wie der Plot aussieht, wenn die y-Achse den vollen Bereich möglicher Zufriedenheitswerte von 1 bis 5 umfasst. Sie können auch die einzelnen Datenpunkte plotten, um den Bereich der Werte zu betonen.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nggplot(survey_data, aes(x = lubridate::date(call_start), \n                        y = satisfaction)) +\n  # einzelne Daten anzeigen, die Höhe leicht versetzen, um Überlappungen zu vermeiden\n  geom_jitter(width = 0, height = .1, alpha = 0.2) + \n  geom_smooth(method = lm,  formula = y~x) +\n  scale_x_date(name = \"\",\n               date_breaks = \"1 month\", \n               date_labels = \"%b\") +\n  scale_y_continuous(name = \"Kundenzufriedenheit\",\n                     breaks = 1:5) +\n  coord_cartesian(ylim = c(1, 5)) + # Grenzen ändern\n  ggtitle(\"Kundenzufriedenheit 2020\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.5.5 Überlagerung\nWenn Sie einen begrenzten Bereich numerischer Werte haben, wie z.B. eine ordinale Bewertungsskala, könnnen manchmal überlappende Daten das Verständnis eines Punktdiagramms erschweren. Zum Beispiel zeigt der folgende Plot Zufriedenheitsbewertungen nach Anrufzeit, aber weil alle Bewertungen 1, 2, 3, 4 oder 5 sind, ist es schwer zu sehen, wie viele Datenpunkte an jedem Punkt sind.\nIn diesem Abschnitt werden wir einige Optionen zur Bewältigung des Überlagerungsproblems erkunden.\n\nggplot(survey_data, aes(x = call_time, y = satisfaction)) + \n  geom_point()\n\n\n\n\n\n\nFigure 8.28: Überlappende Daten erschweren das Verständnis von Plots.\n\n\n\n\n\n8.5.5.1 Jitter-Diagramm\nSie können geom_jitter() verwenden, um die Punkte etwas zu verschieben, um sie besser sichtbar zu machen. Hier ist die x-Achse kontinuierlich, daher besteht keine Notwendigkeit, die width zu jittern, aber die y-Achse sind ordinale Kategorien, daher wird die height zwischen -0,2 und +0,2 vom wahren y-Wert gejittert. Eine andere oder weitere Möglichkeit ist es, die Punkte etwas transparent zu machen.\n\n\n\n\n\n\nÄndern Sie diese Werte, um zu verstehen, was Jitter tut\n\n\n\n\n\n\n\nggplot(survey_data, aes(x = call_time, y = satisfaction)) +\n  geom_jitter(width = 0, height = .2, alpha = 0.5)\n\n\n\n\n\n\nFigure 8.29: Jitter-Diagramm.\n\n\n\n\n\n8.5.5.2 Facetten\nAlternativ können wir facet_wrap() verwenden, um für jede Zufriedenheitsstufe ein separates Diagramm zu erstellen. facet_wrap() verwendet das Tilde (~) Symbol, das Sie grob als “nach” übersetzen können, z.B. facettiere das Diagramm nach Zufriedenheitsbewertung. Die labeller-Funktion steuert die Beschriftungen über jedem Plot. label_both gibt an, dass wir sowohl den Variablennamen (satisfaction) als auch den Wert (z.B. 1) auf dem Plot abbilden möchten, um es einfacher lesbar zu machen.\n\nggplot(survey_data, aes(x = call_time)) +\n  geom_histogram(binwidth = 10, \n                 boundary = 0, \n                 fill = \"dodgerblue\", \n                 color = \"black\") +\n  facet_wrap(~satisfaction, \n             ncol = 1, # versuchen Sie dies auf 2 zu ändern\n             labeller = label_both) +\n  scale_x_continuous(name = \"Anrufzeit (Sekunden)\",\n                     breaks = seq(0, 600, 30))\n\n\n\n\n\n\nFigure 8.30: Ein Histogramm mit Facetten.\n\n\n\n\n\n\n\n\n\n\nWeitere Plot-Stile\n\n\n\nDies sind nicht alle Plot-Typen, die Sie in R erstellen können. Dieses Kapitel gab Ihnen nur einen grundlegenden Überblick, und wir werden im Detail in ?sec-custom-viz eingehen. Der Abschnitt weitere Ressourcen am Ende dieses Kapitels listet viele Ressourcen auf, aber die R Graph Gallery ist besonders nützlich, um Inspiration für die Arten von schönen Plots zu erhalten, die Sie in R erstellen können.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#übungen",
    "href": "08-data-viz.html#übungen",
    "title": "8  Datenvisualisierung",
    "section": "\n8.6 Übungen",
    "text": "8.6 Übungen\nAls letzten Schritt in diesem Kapitel werden wir einen Bericht über Datenvisualisierungen erstellen. Möglicherweise müssen Sie auf Chapter 2 zurückgreifen, um Ihnen bei der Durchführung dieser Übungen zu helfen, und Sie möchten vielleicht auch eine Pause einlegen, bevor Sie diesen Abschnitt bearbeiten. Wir empfehlen Ihnen auch, bei jedem Schritt knit zu verwenden, damit Sie sehen können, wie sich Ihre Ausgabe ändert.\n\n8.6.1 Neues Markdown\nErstellen und speichern Sie ein neues R Markdown-Dokument mit dem Namen plots_report.Rmd und geben Sie ihm den Titel “Bericht zur Kundenzufriedenheit”. Entfernen Sie den Standardvorlagentext und laden Sie dann die unten stehenden Pakete und Code im Setup-Code-Block:\n\nlibrary(tidyverse) \nlibrary(patchwork) \nlibrary(ggthemes)  \nlibrary(lubridate) \nlibrary(knitr)\nlibrary(kableExtra)\n\nsurvey_data &lt;- read_csv(\"https://psyteachr.github.io/ads-v2/data/survey_data.csv\")\n\n\n8.6.2 Zusammenfassung\nErstellen Sie eine Überschrift der Ebene 1 mit dem Titel “Überblick”. Unter dieser Überschrift schreiben Sie eine kurze Zusammenfassung dessen, was der Datensatz enthält und was jede der Variablen bedeutet (Sie können die Informationen aus Section 8.4.1 verwenden, wenn Sie möchten).\n\n8.6.3 Präsentation von Plots\nWählen Sie Ihre beiden Lieblingsplots aus allen Beispielen, die wir in diesem Kapitel erstellt haben. Für jeden Plot:\n\nErstellen Sie eine Überschrift der Ebene 2 in Ihrem R Markdown-Dokument und geben Sie ihr einen informativen Titel.\nSchreiben Sie eine kurze Zusammenfassung, die die in den Plots dargestellten Daten interpretiert - es reicht nicht aus, nur Visualisierungen zu präsentieren, effektive Berichte werden dem Leser auch helfen, die Schlussfolgerungen zu verstehen, die sie aus den präsentierten Plots ziehen sollten.\nSehen Sie sich die verschiedenen verfügbaren Themen mit ggtheme an und wählen Sie eines aus, um es auf Ihre Plots anzuwenden.\nStellen Sie sicher, dass jeder Plot eine Bildunterschrift hat (entweder indem Sie diese zum ggplot()-Code hinzufügen oder sie zu den Code-Block-Optionen hinzufügen).\nOrganisieren Sie Ihr Markdown so, dass die Plots nach der Textzusammenfassung angezeigt werden.\n\n8.6.4 Kombination von Plots\nWählen Sie nun Ihre beiden am wenigsten bevorzugten Plots aus:\n\nPassen Sie die visuellen Ästhetiken an, um sie so schlecht und so schwer lesbar wie möglich zu machen.\nKombinieren Sie die Plots mit der Originalversion unter Verwendung von Patchwork-Funktionen.\nSchreiben Sie eine kurze Zusammenfassung, die erklärt, warum Sie diese Plots so schlecht finden.\nOrganisieren Sie Ihr Markdown so, dass die Plots nach der Textzusammenfassung angezeigt werden.\n\n8.6.5 Bearbeiten Ihrer Markdown-Anzeige\nPassen Sie das Setup Ihres Markdowns so an, dass Ihr gestrickter Bericht keinen Code, keine Nachrichten oder Warnungen anzeigt und alle Abbildungen 8 x 5 groß sind (siehe Section 2.7.1).\n\n8.6.6 Teilen Sie Ihre Arbeit\nSobald Sie diese Aktivität abgeschlossen haben, posten Sie sie im Kanal Woche 3 auf Teams, damit Sie vergleichen können, welche Plots Sie ausgewählt haben und welchen visuellen Stil mit anderen Lernenden auf dem Kurs.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#sec-glossary-viz",
    "href": "08-data-viz.html#sec-glossary-viz",
    "title": "8  Datenvisualisierung",
    "section": "\n8.7 Glossar",
    "text": "8.7 Glossar\n\n\n\n\nterm\ndefinition\n\n\n\nargument\nA variable that provides input to a function.\n\n\ncategorical\nData that can only take certain values, such as types of pet.\n\n\ncharacter\nA data type representing strings of text.\n\n\ncontinuous\nData that can take on any values between other existing values.\n\n\ncontinuous\nData that can take on any values between other existing values.\n\n\ndata-type\nThe kind of data represented by an object.\n\n\ndefault-value\nA value that a function uses for an argument if it is skipped.\n\n\ndouble\nA data type representing a real decimal number\n\n\nfactor\nA data type where a specific set of values are stored with labels; An explanatory variable manipulated by the experimenter\n\n\ngeom\nThe geometric style in which data are displayed, such as boxplot, density, or histogram.\n\n\ninteger\nA data type representing whole numbers.\n\n\nknit\nTo create an HTML, PDF, or Word document from an R Markdown (Rmd) document\n\n\nlikert\nA rating scale with a small number of discrete points in order\n\n\nlogical\nA data type representing TRUE or FALSE values.\n\n\nmedian\nThe middle number in a distribution where half of the values are larger and half are smaller.\n\n\nnominal\nCategorical variables that don't have an inherent order, such as types of animal.\n\n\nnumeric\nA data type representing a real decimal number or integer.\n\n\nordinal\nDiscrete variables that have an inherent order, such as level of education or dislike/like.\n\n\noutlier\nA data point that is extremely distant from most of the other data points\n\n\nstring\nA piece of text inside of quotes.\n\n\nvector\nA type of data structure that collects values with the same data type, like T/F values, numbers, or strings.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  },
  {
    "objectID": "08-data-viz.html#sec-resources-viz",
    "href": "08-data-viz.html#sec-resources-viz",
    "title": "8  Datenvisualisierung",
    "section": "\n8.8 Weitere Ressourcen",
    "text": "8.8 Weitere Ressourcen\n\nggplot2-Spickzettel\n\nDatenvisualisierung mit R für Forscher, die kein R verwenden (Nordmann et al., 2021)\n\n\nKapitel 1: Datenvisualisierung aus R für Datenwissenschaft\n\nggplot2 FAQs\nggplot2-Dokumentation\n[Hack Your Data Beautiful](https://psyteachr.github\n\n\n\n\n\nNordmann, E., McAleer, P., Toivo, W., Paterson, H., & DeBruine, L. M. (2021). Data visualisation using R, for researchers who don’t use R. PsyArXiv. https://doi.org/10.31234/osf.io/4huvw",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Datenvisualisierung</span>"
    ]
  }
]