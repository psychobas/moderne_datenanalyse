{
  "hash": "b65995c72604b80077f5237a9fbda1a1",
  "result": {
    "markdown": "# Einführung in Tibbles\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n\n\nIn diesem Kapitel werden wir die Grundlagen von Tibbles kennenlernen, eine moderne Datenstruktur in R, die besonders im tidyverse verwendet wird. Tibbles sind eine Weiterentwicklung der traditionellen Dataframes und bieten einige Vorteile in der Handhabung und Datenmanipulation.\n\n## Tibbles als Datentyp\n\nTibbles sind ein Objekttyp in R, entwickelt, um mit dem Tidyverse kompatibel zu sein. Im Gegensatz zu traditionellen Dataframes bieten Tibbles eine vereinfachte, aber robustere Datenmanipulation, was sie ideal für Datenanalyse macht.\n\nTibbles sind eine moderne Variante von `dataframes`. `Dataframes` sind Teil der \"Grundausstattung\" von R (auch häufig \"base-R\" genannt). Wir haben bereits in Kapitel x kurz über dataframes gesprochen, hier nochmals die Definition: \n- Dataframe: enthalten Daten, im Grunde eine flexible Matrix, die unterschiedliche Vektoren mit unterschiedlichen R-Objekten enthalten kann und organisiert ist, als hätte sie Variablen und Beobachtungen. Wir werden dies im nächsten Kapitel genauer besprechen. Dataframes kann man wie folgt erstellen: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_base_r <- data.frame(\n  id = c(1,2,3,4,5,6),\n  age = c(25,30,33,NA,26,38),\n  grade = c('A','A+','B','B-','B+','A')\n)\n\nhead(df_base_r)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| age|grade |\n|--:|---:|:-----|\n|  1|  25|A     |\n|  2|  30|A+    |\n|  3|  33|B     |\n|  4|  NA|B-    |\n|  5|  26|B+    |\n|  6|  38|A     |\n\n</div>\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Tibble erstellen\ndf <- tibble(id = c(1, 2, 3, 4, 5, 6),\n             age = c(25, 30, 33, NA, 26, 38),\n             grade = c('A', 'A+', 'B', 'B-', 'B+', 'A'))\n\n# Daten überprüfen\nhead(df)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| age|grade |\n|--:|---:|:-----|\n|  1|  25|A     |\n|  2|  30|A+    |\n|  3|  33|B     |\n|  4|  NA|B-    |\n|  5|  26|B+    |\n|  6|  38|A     |\n\n</div>\n:::\n:::\n\n\n\n## Indexierung im Allgemeinen\n\n### Indexierung mit Ganzzahlen\n\nMan kann bestimmte Elemente auswählen, indem man Ganzzahlen verwendet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Erste Spalte als Tibble-Variable\ndf[1]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|\n|--:|\n|  1|\n|  2|\n|  3|\n|  4|\n|  5|\n|  6|\n\n</div>\n:::\n\n```{.r .cell-code}\n# Erste Spalte alle Beobachtungen\ndf[, 1]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|\n|--:|\n|  1|\n|  2|\n|  3|\n|  4|\n|  5|\n|  6|\n\n</div>\n:::\n\n```{.r .cell-code}\n# Zweite Zeile\ndf[2, ]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| age|grade |\n|--:|---:|:-----|\n|  2|  30|A+    |\n\n</div>\n:::\n\n```{.r .cell-code}\n# Spezifische Zelle (2. Beobachtung, 1. Variable)\ndf[2, 1]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|\n|--:|\n|  2|\n\n</div>\n:::\n\n```{.r .cell-code}\n# Mehrere Zeilen für mehrere Variablen\ndf[1:3, c(1, 3)]\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|grade |\n|--:|:-----|\n|  1|A     |\n|  2|A+    |\n|  3|B     |\n\n</div>\n:::\n:::\n\n\n### Indexierung mit logischen Werten\n\nMan kann einen logischen Vektor anstelle der Ganzzahlen-Indexierung verwenden, um bestimmte Elemente zu filtern.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Alter der Beobachtung mit id == 3\ndf$age[df$id == 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33\n```\n:::\n\n```{.r .cell-code}\n# Notenwerte für Schüler mit Alter zwischen 25 und 35\ndf$grade[df$age >= 25 & df$age < 35]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A\"  \"A+\" \"B\"  NA   \"B+\"\n```\n:::\n:::\n\n\n## Einfache Funktionen\n\nMan ist oft an bestimmten Eigenschaften der Daten interessiert. Funktionen wie `sum()`, `mean()` und `sd()` sind hierbei nützlich. Im Verlaufe des Semesters werden wir noch mehr solche Funktionen kennenlernen. \n\n::: {.cell}\n\n```{.r .cell-code}\n# Summe des Alters\nmean(df$age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nWie wir oben gesehen haben, enthält die Variable `age` fehlende Werte. Um den Mittelwert der nicht fehlenden Werte zu berechnen, müssen wir deshalb das Argument `na.rm = TRUE` hinzufügen:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mittelwert des Alters\nmean(df$age, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 30.4\n```\n:::\n\n```{.r .cell-code}\n# Summe des Alters\nsum(df$age, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 152\n```\n:::\n\n```{.r .cell-code}\n# Standardabweichung des Alters\nsd(df$age, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.319774\n```\n:::\n:::\n\n\n## Werte zurücksetzen, neue Spalten oder Zeilen hinzufügen\n\n### Werte zurücksetzen\n\nFehler in den Daten können einfach korrigiert werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setzt das Alter für id == 1 auf den Wert 40\ndf$age[df$id == 1] <- 40\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n     id   age grade\n  <dbl> <dbl> <chr>\n1     1    40 A    \n2     2    30 A+   \n3     3    33 B    \n4     4    NA B-   \n5     5    26 B+   \n6     6    38 A    \n```\n:::\n:::\n\n\n### Spalten hinzufügen\n\nNeue Variablen können leicht hinzugefügt werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Neue Variable 'gender' hinzufügen\ngender <- c('F', 'F', 'M', 'M', 'M', 'F')\ndf$gender <- gender\n\n# Alternativ mit add_column\ndf <- add_column(df, gender_new = gender)\n\n# Variable entfernen\ndf <- select(df, -gender_new)\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n     id   age grade gender\n  <dbl> <dbl> <chr> <chr> \n1     1    40 A     F     \n2     2    30 A+    F     \n3     3    33 B     M     \n4     4    NA B-    M     \n5     5    26 B+    M     \n6     6    38 A     F     \n```\n:::\n:::\n\n\n### Zeilen hinzufügen\n\nNeue Beobachtungen können mit der Funktion `add_row()` hinzugefügt werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Neue Zeile hinzufügen\ndf <- add_row(df, id = 7, age = 25, grade = 'C+', gender = 'M')\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 4\n     id   age grade gender\n  <dbl> <dbl> <chr> <chr> \n1     1    40 A     F     \n2     2    30 A+    F     \n3     3    33 B     M     \n4     4    NA B-    M     \n5     5    26 B+    M     \n6     6    38 A     F     \n7     7    25 C+    M     \n```\n:::\n\n```{.r .cell-code}\n# Zeile entfernen\n# df$id != 7 generiert den folgenden Vektor: TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE, der die Grundlage für die Indizierung bildet\ndf <- df[df$id != 7, ]\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n     id   age grade gender\n  <dbl> <dbl> <chr> <chr> \n1     1    40 A     F     \n2     2    30 A+    F     \n3     3    33 B     M     \n4     4    NA B-    M     \n5     5    26 B+    M     \n6     6    38 A     F     \n```\n:::\n:::\n\n\n\n\n\n\n## Tidy Data\n\nTidy Data ist ein Konzept in der Datenanalyse, das sicherstellt, dass Daten in einem klaren und konsistenten Format vorliegen. In Tidy Data hat jede Variable ihre eigene Spalte, jede Beobachtung ihre eigene Zeile und jede Art von beobachteter Einheit bildet eine Tabelle. Dies erleichtert die Manipulation, Visualisierung und Modellierung der Daten.\n\n### Prinzipien des Tidy Data Ansatzes\n\n1. **Jede Variable hat ihre eigene Spalte.**\n2. **Jede Beobachtung hat ihre eigene Zeile.**\n3. **Jede Art von beobachteter Einheit bildet eine Tabelle.**\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](_main_files/figure-html/clean_data.jpg){width=180}\n:::\n:::\n\n\n### Beispiel für Tidy Data\n\nSchauen wir uns ein Beispiel an, um die Prinzipien von Tidy Data zu verdeutlichen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Erstellen eines Tidy Data Tibble\ntidy_data <- tibble(\n  country = c('Afghanistan', 'Brazil', 'China', 'Afghanistan', 'Brazil', 'China'),\n  year = c(1999, 1999, 1999, 2000, 2000, 2000),\n  value = c(745, 37737, 212258, 2666, 80488, 213766)\n)\n\n# Daten anzeigen\ntidy_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|country     | year|  value|\n|:-----------|----:|------:|\n|Afghanistan | 1999|    745|\n|Brazil      | 1999|  37737|\n|China       | 1999| 212258|\n|Afghanistan | 2000|   2666|\n|Brazil      | 2000|  80488|\n|China       | 2000| 213766|\n\n</div>\n:::\n:::\n\n\n### Beispiel für Nicht-Tidy Data\n\nIm Gegensatz dazu sehen Nicht-Tidy Data oft unorganisiert aus und erschweren die Analyse. Hier ist ein Beispiel für Nicht-Tidy Data, das dem Datensatz `table4a` ähnelt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Erstellen eines Nicht-Tidy Data Frames\nnon_tidy_data <- tibble(\n  country = c('Afghanistan', 'Brazil', 'China'),\n  `1999` = c(745, 37737, 212258),\n  `2000` = c(2666, 80488, 213766)\n)\n\n# Daten anzeigen\nnon_tidy_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|country     |   1999|   2000|\n|:-----------|------:|------:|\n|Afghanistan |    745|   2666|\n|Brazil      |  37737|  80488|\n|China       | 212258| 213766|\n\n</div>\n:::\n:::\n\n\n\n### Umwandeln von Nicht-Tidy Data in Tidy Data\n\nUm Nicht-Tidy Data in Tidy Data zu konvertieren, kann man die Funktion `pivot_longer()` verwenden. Hier zeigen wir, wie man dies erreicht:\n\n#### Beispiel für Weites Format zu Langem Format\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Nicht-Tidy Data in Tidy Data umwandeln (Weit zu Lang)\ntidy_from_non_tidy <- pivot_longer(non_tidy_data, \n                                   cols = c(`1999`, `2000`),\n                                   names_to = \"year\",\n                                   values_to = \"value\")\n\n# Daten anzeigen\ntidy_from_non_tidy\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|country     |year |  value|\n|:-----------|:----|------:|\n|Afghanistan |1999 |    745|\n|Afghanistan |2000 |   2666|\n|Brazil      |1999 |  37737|\n|Brazil      |2000 |  80488|\n|China       |1999 | 212258|\n|China       |2000 | 213766|\n\n</div>\n:::\n:::\n\n\nMit diesen Prinzipien und Techniken können Sie sicherstellen, dass Ihre Daten stets im Tidy Format vorliegen, was die Datenanalyse erheblich erleichtert. Leider kommt \"non-tidy data\" in alle Farben und Formen. Deshalb gibt es kein einfaches Rezept, wie man von nicht-tidy zu tidy Data kommt. Wir werden aber im Verlauf des Semesters (vor allem im nächsten Kapitel) Funktionen kennenlernen, die dafür hilfreich sind.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](_main_files/figure-html/bad_data.jpg.webp)\n:::\n:::\n\n\n\nDurch das Verständnis dieser grundlegenden Operationen können Sie Daten in R effizient verwalten und analysieren.",
    "supporting": [
      "05-tibbles_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}