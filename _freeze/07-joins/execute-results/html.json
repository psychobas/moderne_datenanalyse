{
  "hash": "8984861ac51e8f43dabceb8bbabe4946",
  "result": {
    "engine": "knitr",
    "markdown": "# Datenbeziehungen {#sec-joins}\n\n\n\n\n\n\n\n\n\n\n\n* eingebaut (diese können immer verwendet werden, ohne Pakete zu laden)\n    * base:: `library()`, `dir.create()`, `list.files()`, `as.numeric()`, `as.factor()`, `as.character()`, `as.data.frame()`\n* tidyverse (alle diese können mit `library(tidyverse)` verwendet werden)\n    * readr:: `write_csv()`, `read_csv()`\n    * dplyr:: `left_join()`, `right_join()`, `inner_join()`, `full_join()`, `semi_join()`, `anti_join()`, `bind_rows()`, `bind_cols()`, `intersect()`, `union()`, `setdiff()`, `mutate()`\n    * tibble:: `tibble()`, `as_tibble()`\n    * purrr:: `map_df()`\n    * stringr:: `str_replace_all()`\n\n\n\n\nBis jetzt haben wir uns jeweils nur mit einer Datenquelle beschäftigt. In der Praxis sind unsere Daten jedoch häufig auf mehrere Quellen verteilt. Erst werden wirklich spannende Datenauswertungen erst durch die Kombination mehrere Datenquellen möglich. Vielleicht interessieren wir uns dafür, wieso ein bestimmtes Produkt in gewissen geografischen Gebieten mehr Absatz findet als in anderen. Um dieser Frage nachzugehen, müssen wir Daten über die Verkaufszahlen mit Daten über die geografischen Gebiete (Anzahl EinwohnerInnen etc.) kombinieren. In diesem Kapitel lernen wir, wie man verschiedene Daten zu einem Datensatz zusammenführen kann. \n\n\n\n\n\n::: {.cell layout-align=\"center\" verbatim='r setup, include=FALSE'}\n<div class='verbatim'><pre class='sourceCode r'><code class='sourceCode R'>&#96;&#96;&#96;{r setup, include=FALSE}</code></pre>\n\n```{.r .cell-code}\nlibrary(tidyverse)     # beinhaltet readr & tibble\n```\n\n<pre class='sourceCode r'><code class='sourceCode R'>&#96;&#96;&#96;</code></pre></div>\n:::\n\n\n\n\n\n## Daten laden {#sec-joins-data}\nWieder generieren wir zu Übungszwecken einen kleinen übersichtlichen Datensatz. Dies erleichtert es die Berechnungen/Datenmanipulationen nachzuvollziehen. Die Prinzipien sind jedoch, auch für riesige Datensätze, identisch. \n\nAls erstes generieren wir den Datensatz `customers`\n\nDieser hat folgende Spalten/Variablen: id, Stadt und Postleitzahl für fünf Kunden 1-5.\n\n-   `1:5` wird die Variable `id` mit allen ganzen Zahlen zwischen 1 und 5 füllen.\n-   `city` und `code` verwenden beide die Funktion `c()`, um mehrere Zeichenketten einzugeben. Beachten Sie, dass jeder Eintrag in eigenen Anführungszeichen steht, abgesehen von fehlenden Daten, die als `NA` aufgezeichnet werden.\n-   Bei der Eingabe von Daten auf diese Weise ist es wichtig, dass die Reihenfolge jeder Variable übereinstimmt. Also entspricht die Nummer 1 \"Port Ellen\" und \"PA42 7DU\".\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncustomers <- tibble(\n  id = 1:5,\n  city = c(\"Port Ellen\", \"Dufftown\", NA, \"Aberlour\", \"Tobermory\"),\n  postcode = c(\"PA42 7DU\", \"AB55 4DH\", NA, \"AB38 7RY\", \"PA75 6NR\")\n)\n```\n:::\n\n\n\n\n\n\nTable: Demo-Kundentabelle.\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Port Ellen |PA42 7DU |\n|  2|Dufftown   |AB55 4DH |\n|  3|NA         |NA       |\n|  4|Aberlour   |AB38 7RY |\n|  5|Tobermory  |PA75 6NR |\n\n\n\nNehmen wir an, dass wir neben der Datenbank der Kunden auch eine Datenbank der Bestellungen haben, die diese Kunden getätigt haben. Solche Daten werden in der Praxis tatsächlich so (also getrennt) in Datenbanken gespeichert. Wir generieren also einen zweiten Datensatz den wir `orders` nennen. Dieser Datensatz enthält eine Spalte mit den Kunden-IDs und eine Spalte mit der Anzahl der bestellten Artikel. Einige Kunden aus der vorherigen Tabelle haben keine Bestellungen, manche haben mehr als eine Bestellung und manche sind nicht in der Kundentabelle.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\norders <- tibble(\n  id = c(2, 3, 4, 4, 5, 5, 6, 6, 7),\n  items = c(10, 18, 21, 23, 9, 11, 11, 12, 3)\n)\n```\n:::\n\n\n\n\n\n\nTable: Demo-Bestelltabelle.\n\n| id| items|\n|--:|-----:|\n|  2|    10|\n|  3|    18|\n|  4|    21|\n|  4|    23|\n|  5|     9|\n|  5|    11|\n|  6|    11|\n|  6|    12|\n|  7|     3|\n\n\n\n## Mutierende Joins (Verknüpfungen)\n\n`Mutierende Joins` verhalten sich wie die `dplyr::mutate()`-Funktion, indem sie neue Spalten zu einer Tabelle auf Basis der Werte in einer anderen Tabelle hinzufügen. \n\nAlle mutierenden Joins haben diese grundlegende Syntax:\n\n`****_join(x, y, by = NULL, suffix = c(\".x\", \".y\"))`\n\n-   `x` = die erste (linke) Tabelle\n-   `y` = die zweite (rechte) Tabelle\n-   `by` = welche Spalten abgeglichen werden sollen. Wenn Sie dies leer lassen, wird es auf allen Spalten mit denselben Namen in den beiden Tabellen abgeglichen. Beobachtungen, die in diesen Spalten die selben Werte haben (z.B. die selbe ID), werden miteinander verknüpft\n-   `suffix` = wenn Spalten denselben Namen in beiden Tabellen haben, aber Sie nicht nach ihnen verbinden, erhalten sie ein Suffix, um sie eindeutig zu machen. Dies ist standardmäßig \".x\" und \".y\", aber Sie können es in etwas Sinnvolleres ändern.\n\n::: {.callout-note}\nSie können das Argument `by` weglassen, wenn Sie auf allen Spalten mit demselben Namen abgleichen, aber es ist gute Praxis, es immer anzugeben, damit Ihr Code robust gegenüber Änderungen in den geladenen Daten bleibt.\n:::\n\n### left_join() {#sec-left_join}\n\n::: join\n<img src=\"images/joins/left_join.png\"/>\n:::\n\nEin `left_join` behält alle Daten der ersten (linken) Tabelle bei und fügt alles hinzu, was mit der zweiten (rechten) Tabelle übereinstimmt. Die folgende Animation veranschaulicht einen `left_join()`:\n\n\n<!-- left join animation by Garrick Aden-Buie from the tidyexplain repo -->\n::: join\n<img src=\"images/joins/left-join.gif\"/>\n:::\n\n\nWenn die rechte Tabelle mehr als eine Übereinstimmung für eine Zeile in der linken Tabelle hat, gibt es mehr als eine Zeile in der verbundenen Tabelle (siehe IDs 4 und 5).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nleft_data <- left_join(customers, orders, by = \"id\")\nleft_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | items|\n|--:|:----------|:--------|-----:|\n|  1|Port Ellen |PA42 7DU |    NA|\n|  2|Dufftown   |AB55 4DH |    10|\n|  3|NA         |NA       |    18|\n|  4|Aberlour   |AB38 7RY |    21|\n|  4|Aberlour   |AB38 7RY |    23|\n|  5|Tobermory  |PA75 6NR |     9|\n|  5|Tobermory  |PA75 6NR |    11|\n\n</div>\n:::\n:::\n\n\n\n\n::: join\n<img src=\"images/joins/left_join_rev.png\"/>\n:::\n\nDie Reihenfolge, in der Sie die Tabellen angeben, ist wichtig. Im folgenden Code haben wir die Reihenfolge umgekehrt, sodass das Ergebnis alle Zeilen aus der `orders`-Tabelle enthält, die mit den passenden Zeilen aus der `customers`-Tabelle verbunden sind.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nleft2_data <- left_join(orders, customers, by = \"id\")\nleft2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| items|city      |postcode |\n|--:|-----:|:---------|:--------|\n|  2|    10|Dufftown  |AB55 4DH |\n|  3|    18|NA        |NA       |\n|  4|    21|Aberlour  |AB38 7RY |\n|  4|    23|Aberlour  |AB38 7RY |\n|  5|     9|Tobermory |PA75 6NR |\n|  5|    11|Tobermory |PA75 6NR |\n|  6|    11|NA        |NA       |\n|  6|    12|NA        |NA       |\n|  7|     3|NA        |NA       |\n\n</div>\n:::\n:::\n\n\n\n\n### right_join() {#sec-right_join}\n\n::: join\n<img src=\"images/joins/right_join.png\"/>\n:::\n\nEin `right_join` behält alle Daten der zweiten (rechten) Tabelle bei und fügt alles hinzu, was mit der ersten (linken) Tabelle übereinstimmt. Die folgende Animation veranschaulicht einen `right_join`:\n\n<!-- left join animation by Garrick Aden-Buie from the tidyexplain repo -->\n::: join\n<img src=\"images/joins/right-join.gif\"/>\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nright_data <- right_join(customers, orders, by = \"id\")\nright_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city      |postcode | items|\n|--:|:---------|:--------|-----:|\n|  2|Dufftown  |AB55 4DH |    10|\n|  3|NA        |NA       |    18|\n|  4|Aberlour  |AB38 7RY |    21|\n|  4|Aberlour  |AB38 7RY |    23|\n|  5|Tobermory |PA75 6NR |     9|\n|  5|Tobermory |PA75 6NR |    11|\n|  6|NA        |NA       |    11|\n|  6|NA        |NA       |    12|\n|  7|NA        |NA       |     3|\n\n</div>\n:::\n:::\n\n\n\n\n::: {.callout-note}\nDiese Tabelle enthält dieselben Informationen wie `left_join(orders, customers, by = \"id\")`, aber die Spalten sind in einer anderen Reihenfolge (zuerst linke Tabelle, dann rechte Tabelle).\n:::\n\n### inner_join() {#sec-inner_join}\n\n::: join\n<img src=\"images/joins/inner_join.png\"/>\n:::\n\nEin `inner_join` gibt alle Zeilen zurück, die in beiden Tabellen eine Übereinstimmung haben. Das Ändern der Reihenfolge der Tabellen ändert die Reihenfolge der Spalten, aber nicht, welche Zeilen erhalten bleiben.\n\nDie folgende Animation veranschaulicht einen `inner_join`:\n\n<!-- left join animation by Garrick Aden-Buie from the tidyexplain repo -->\n::: join\n<img src=\"images/joins/inner-join.gif\"/>\n:::\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninner_data <- inner_join(customers, orders, by = \"id\")\ninner_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city      |postcode | items|\n|--:|:---------|:--------|-----:|\n|  2|Dufftown  |AB55 4DH |    10|\n|  3|NA        |NA       |    18|\n|  4|Aberlour  |AB38 7RY |    21|\n|  4|Aberlour  |AB38 7RY |    23|\n|  5|Tobermory |PA75 6NR |     9|\n|  5|Tobermory |PA75 6NR |    11|\n\n</div>\n:::\n:::\n\n\n\n\n### full_join() {#sec-full_join}\n\n::: join\n<img src=\"images/joins/full_join.png\"/>\n:::\n\nEin `full_join` ermöglicht es, Zeilen in zwei Tabellen zu verbinden und dabei alle Informationen aus beiden Tabellen zu behalten. Wenn eine Zeile in der anderen Tabelle keine Übereinstimmung hat, werden die Spaltenwerte der anderen Tabelle auf `NA` gesetzt.\n\nDie folgende Animation veranschaulicht einen `full-join`:\n\n::: join\n<img src=\"images/joins/full-join.gif\"/>\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfull_data <- full_join(customers, orders, by = \"id\")\nfull_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | items|\n|--:|:----------|:--------|-----:|\n|  1|Port Ellen |PA42 7DU |    NA|\n|  2|Dufftown   |AB55 4DH |    10|\n|  3|NA         |NA       |    18|\n|  4|Aberlour   |AB38 7RY |    21|\n|  4|Aberlour   |AB38 7RY |    23|\n|  5|Tobermory  |PA75 6NR |     9|\n|  5|Tobermory  |PA75 6NR |    11|\n|  6|NA         |NA       |    11|\n|  6|NA         |NA       |    12|\n|  7|NA         |NA       |     3|\n\n</div>\n:::\n:::\n\n\n\n\n\n\n\n\n## Filternde Joins\n\n`Filternde Joins` verhalten sich wie die `dplyr::filter()`-Funktion, indem sie Zeilen aus den Daten in einer Tabelle auf Basis der Werte in einer anderen Tabelle behalten oder entfernen. Das Ergebnis eines filternden Joins enthält nur Zeilen aus der linken Tabelle und hat dieselbe Anzahl oder weniger Zeilen wie die linke Tabelle.\n\n### semi_join() {#sec-semi_join}\n\n::: join\n<img src=\"images/joins/semi_join.png\"/>\n:::\n\nEin `semi_join` gibt alle Zeilen aus der linken Tabelle zurück, bei denen es passende Werte in der rechten Tabelle gibt, wobei nur Spalten aus der linken Tabelle beibehalten werden.\n\nDie Folgende Animation veranschaulicht einen `semi_join`:\n\n::: join\n<img src=\"images/joins/semi-join.gif\"/>\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsemi_data <- semi_join(customers, orders, by = \"id\")\nsemi_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city      |postcode |\n|--:|:---------|:--------|\n|  2|Dufftown  |AB55 4DH |\n|  3|NA        |NA       |\n|  4|Aberlour  |AB38 7RY |\n|  5|Tobermory |PA75 6NR |\n\n</div>\n:::\n:::\n\n\n\n\n::: {.callout-note}\nIm Gegensatz zu einem inner_join wird ein semi_join niemals die Zeilen in der linken Tabelle duplizieren, wenn es mehr als eine passende Zeile in der rechten Tabelle gibt.\n:::\n\n\n\n\n::: join\n<img src=\"images/joins/semi_join_rev.png\"/>\n:::\n\nDa nur die Spalten der Linken Tabelle erhalten bleiben, ist die Reihenfolge bei einem semi_join wichtig.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsemi2_data <- semi_join(orders, customers, by = \"id\")\nsemi2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| items|\n|--:|-----:|\n|  2|    10|\n|  3|    18|\n|  4|    21|\n|  4|    23|\n|  5|     9|\n|  5|    11|\n\n</div>\n:::\n:::\n\n\n\n\n### anti_join() {#sec-anti_join}\n\n::: join\n<img src=\"images/joins/anti_join.png\"/>\n:::\n\nEin `anti_join` gibt alle Zeilen aus der linken Tabelle zurück, bei denen es *keine* passenden Werte in der rechten Tabelle gibt, wobei nur Spalten aus der linken Tabelle beibehalten werden.\n\nDie folgende Animation veranschaulicht einen `anti-join`:\n\n::: join\n<img src=\"images/joins/anti-join.gif\"/>\n:::\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanti_data <- anti_join(customers, orders, by = \"id\")\nanti_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Port Ellen |PA42 7DU |\n\n</div>\n:::\n:::\n\n\n\n\n\n\n\n\nDie Reihenfolge ist wichtig bei einem anti join.\n\n::: join\n<img src=\"images/joins/anti_join_rev.png\"/>\n:::\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nanti2_data <- anti_join(orders, customers, by = \"id\")\nanti2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| items|\n|--:|-----:|\n|  6|    11|\n|  6|    12|\n|  7|     3|\n\n</div>\n:::\n:::\n\n\n\n\n## Verknüpfung von mehr als zwei Tabellen\n\nDie `****_join()`-Funktionen sind alles **Zwei-Tabellen-Verben**, das heißt, Sie können jeweils nur zwei Tabellen miteinander verbinden. Wenn man jedoch mehrere Tabellen verbinden musst, kann man einfach weitere Joins hinzufügen. Dies kann man tun, indem man ein Zwischenobjekt erstellt oder effizienter durch die Verwendung einer Pipe:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# erstelle eine Tabelle mit Gesamtkundenzufriedenheitswerten\nsatisfaction <- tibble(\n  id = 1:5,\n  satisfaction = c(4, 3, 2, 3, 1)\n)\n\n# führe den ersten Join durch\njoin_1 <- left_join(customers, orders, by = \"id\")\n\n# führe den zweiten Join am neuen Objekt durch\njoin_2 <- left_join(join_1, satisfaction, \n                    by = \"id\")\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# effizientere Methode unter Verwendung der Pipe\npipe_join <- customers %>%\n  left_join(orders, by = \"id\") %>%\n  left_join(satisfaction, by = \"id\")\n```\n:::\n\n\n\n\n::: {.callout-warning}\nAuf jeder Stufe einer Analyse sollte man **die Ausgabe überprüfen**, um sicherzustellen, dass das, was man erstellt hat, auch das ist, was man beabsichtigt hat. Dies gilt insbesondere für Joins. Man sollte die Zwischenschritte durch routinemäßige Überprüfungen mit Funktionen wie `glimpse()`, `str()`, und `summary()` anschauen, um eine grobe Vorstellung davon zu haben, was der Join ergeben sollte. Mindestens sollte man wissen, ob das verbundene Objekt zu mehr oder weniger Variablen und Beobachtungen führen sollten.\n\nWenn Sie einen mehrzeiligen Join wie im obigen piped Beispiel haben, bauen Sie den Code schrittweise auf und überprüfen Sie die Ausgabe auf jeder Stufe.\n:::\n\n\n## Bindende Joins\n\n`Bindende Joins` binden eine Tabelle an eine andere, indem sie ihre Zeilen oder Spalten zusammenfügen.\n\n### bind_rows() {#sec-bind_rows}\n\nMit der Funktion `bind_rows` kann man die Zeilen von zwei Tabellen mit zusammenfügen. Hier fügen wir Kundendaten für die Kunden 6-9 hinzu und verbinden diese mit der ursprünglichen Kundentabelle.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_customers <- tibble(\n  id = 6:9,\n  city = c(\"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\"),\n  postcode = c(\"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\")\n)\n\nbindr_data <- bind_rows(customers, new_customers)\nbindr_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Port Ellen |PA42 7DU |\n|  2|Dufftown   |AB55 4DH |\n|  3|NA         |NA       |\n|  4|Aberlour   |AB38 7RY |\n|  5|Tobermory  |PA75 6NR |\n|  6|Falkirk    |FK1 4RS  |\n|  7|Ardbeg     |PA42 7EA |\n|  8|Doogal     |G81 4SJ  |\n|  9|Kirkwall   |KW15 1SE |\n\n</div>\n:::\n:::\n\n\n\n\nDie Spalten müssen nur dieselben Namen haben, sie müssen nicht in der gleichen Reihenfolge sein. Alle Spalten, die nicht in beiden Tabellen enthalten sind, haben einfach `NA`-Werte für Einträge aus der anderen Tabelle.\n\nWenn eine Zeile in beiden Tabellen vorkommt, wird die Zeile in der resultierenden Tabelle doppelt vorkommen. Wenn Ihre Tabellen genau dieselben Spalten haben, können Sie `union()` verwenden, um Duplikate zu vermeiden (werden wir gleich sehen).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_customers <- tibble(\n  id = 5:9,\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\"),\n  new = c(1,2,3,4,5)\n)\n\nbindr2_data <- bind_rows(customers, new_customers)\nbindr2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode | new|\n|--:|:----------|:--------|---:|\n|  1|Port Ellen |PA42 7DU |  NA|\n|  2|Dufftown   |AB55 4DH |  NA|\n|  3|NA         |NA       |  NA|\n|  4|Aberlour   |AB38 7RY |  NA|\n|  5|Tobermory  |PA75 6NR |  NA|\n|  5|Tobermory  |PA75 6NR |   1|\n|  6|Falkirk    |FK1 4RS  |   2|\n|  7|Ardbeg     |PA42 7EA |   3|\n|  8|Doogal     |G81 4SJ  |   4|\n|  9|Kirkwall   |KW15 1SE |   5|\n\n</div>\n:::\n:::\n\n\n\n\n### bind_cols() {#sec-bind_cols}\nMan kann Tabellen auch mit der Funktion `bind_cols` zusammenführen. Dies sollte man jedoch nur tun, wenn beide Tabllen die gleiche Anzahl Zeilen haben und diese genau die selbe Reihenfolge haben. Diese Funktion ist also mit Vorsicht zu geniessen und im Zweifelsfall sollte für solche Operationen eine Funktion wie `left_join` verwendet werden. \n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_info <- tibble(\n  colour = c(\"red\", \"orange\", \"yellow\", \"green\", \"blue\")\n)\n\nbindc_data <- bind_cols(customers, new_info)\nbindc_data \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |colour |\n|--:|:----------|:--------|:------|\n|  1|Port Ellen |PA42 7DU |red    |\n|  2|Dufftown   |AB55 4DH |orange |\n|  3|NA         |NA       |yellow |\n|  4|Aberlour   |AB38 7RY |green  |\n|  5|Tobermory  |PA75 6NR |blue   |\n\n</div>\n:::\n:::\n\n\n\n\n::: {.callout-note}\nDer einzige Vorteil von `bind_cols()` gegenüber einem mutierenden Join besteht darin, wenn die Tabellen keine IDs zum Verbinden haben und Sie sich ausschließlich auf ihre Reihenfolge verlassen müssen. Ansonsten sollten Sie einen mutierenden Join verwenden (alle vier mutierenden Joins ergeben das gleiche Ergebnis, wenn alle Zeilen in jeder Tabelle genau eine Übereinstimmung in der anderen Tabelle haben).\n:::\n\n\n\n## Mengenoperationen\n\n`Mengenoperationen` vergleichen zwei Tabellen und geben Zeilen zurück, die übereinstimmen (intersect), in einer der beiden Tabellen sind (union) oder in einer Tabelle, aber nicht in der anderen sind (setdiff).\n\n### intersect() {#sec-intersect}\n\n`dplyr::intersect()` gibt alle Zeilen in zwei Tabellen zurück, die genau übereinstimmen. Die Spalten müssen nicht in derselben Reihenfolge sein, müssen aber dieselben Namen haben.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_customers <- tibble(\n  id = 5:9,\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\")\n)\n\nintersect_data <- intersect(customers, new_customers)\nintersect_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city      |postcode |\n|--:|:---------|:--------|\n|  5|Tobermory |PA75 6NR |\n\n</div>\n:::\n:::\n\n\n\n\n::: {.callout-warning}\nWenn Sie vergessen haben, dplyr oder das tidyverse zu laden, hat `base R` auch eine `base::intersect()`-Funktion, die nicht wie `dplyr::intersect()` funktioniert. Die Fehlermeldung kann verwirrend sein und sieht ungefähr so aus:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase::intersect(customers, new_customers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlist()\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### union() {#sec-union}\n\n`dplyr::union()` gibt alle Zeilen aus beiden Tabellen zurück und entfernt dabei, im Gegensatz zu `bind_rows()`, doppelte Zeilen.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nunion_data <- union(customers, new_customers)\nunion_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Port Ellen |PA42 7DU |\n|  2|Dufftown   |AB55 4DH |\n|  3|NA         |NA       |\n|  4|Aberlour   |AB38 7RY |\n|  5|Tobermory  |PA75 6NR |\n|  6|Falkirk    |FK1 4RS  |\n|  7|Ardbeg     |PA42 7EA |\n|  8|Doogal     |G81 4SJ  |\n|  9|Kirkwall   |KW15 1SE |\n\n</div>\n:::\n:::\n\n\n\n\n::: {.callout-warning}\nWenn Sie vergessen haben, dplyr oder das tidyverse zu laden, hat `base R` auch eine `base::union()`-Funktion. Sie erhalten normalerweise keine Fehlermeldung, aber das Ergebnis wird nicht das sein, was Sie erwarten.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase::union(customers, new_customers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n[1] \"Port Ellen\" \"Dufftown\"   NA           \"Aberlour\"   \"Tobermory\" \n\n[[3]]\n[1] \"PA42 7DU\" \"AB55 4DH\" NA         \"AB38 7RY\" \"PA75 6NR\"\n\n[[4]]\n[1] 5 6 7 8 9\n\n[[5]]\n[1] \"PA75 6NR\" \"FK1 4RS\"  \"PA42 7EA\" \"G81 4SJ\"  \"KW15 1SE\"\n\n[[6]]\n[1] \"Tobermory\" \"Falkirk\"   \"Ardbeg\"    \"Doogal\"    \"Kirkwall\" \n```\n\n\n:::\n:::\n\n\n\n:::\n\n### setdiff() {#sec-setdiff}\n\n`dplyr::setdiff` gibt Zeilen zurück, die in der ersten Tabelle, aber nicht in der zweiten Tabelle sind.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetdiff_data <- setdiff(customers, new_customers)\nsetdiff_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|city       |postcode |\n|--:|:----------|:--------|\n|  1|Port Ellen |PA42 7DU |\n|  2|Dufftown   |AB55 4DH |\n|  3|NA         |NA       |\n|  4|Aberlour   |AB38 7RY |\n\n</div>\n:::\n:::\n\n\n\n\nDie Reihenfolge ist wichtig für `setdiff`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsetdiff2_data <- setdiff(new_customers, customers)\nsetdiff2_data\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id|postcode |city     |\n|--:|:--------|:--------|\n|  6|FK1 4RS  |Falkirk  |\n|  7|PA42 7EA |Ardbeg   |\n|  8|G81 4SJ  |Doogal   |\n|  9|KW15 1SE |Kirkwall |\n\n</div>\n:::\n:::\n\n\n\n\n::: {.callout-warning}\nWenn Sie vergessen haben, dplyr oder das tidyverse zu laden, hat `base R` auch eine `base::setdiff()`-Funktion. Sie erhalten normalerweise keine Fehlermeldung, aber das Ergebnis ist möglicherweise nicht das, was Sie erwarten, weil `base::setdiff()` erwartet, dass die Spalten in derselben Reihenfolge sind, sodass die ID 5 hier als unterschiedlich zwischen den beiden Tabellen registriert wird.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbase::setdiff(customers, new_customers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$id\n[1] 1 2 3 4 5\n\n$city\n[1] \"Port Ellen\" \"Dufftown\"   NA           \"Aberlour\"   \"Tobermory\" \n\n$postcode\n[1] \"PA42 7DU\" \"AB55 4DH\" NA         \"AB38 7RY\" \"PA75 6NR\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Konflikte bei Variablentypen\n\nBeim Verbinden von Datensätzen anhand gemeinsamer Spalten ist es wichtig, dass nicht nur die Variablennamen identisch sind, sondern auch der Datentyp dieser Variablen identisch ist.\n\nUm das zu veranschaulichen, erstellen wir unseren `new_customers`-Datenset erneut, aber diesmal spezifizieren wir, dass `id` eine `character`-Variable ist.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_customers2 <- tibble(\n  id = as.character(5:9),\n  postcode = c(\"PA75 6NR\", \"FK1 4RS\", \"PA42 7EA\", \"G81 4SJ\", \"KW15 1SE\"),\n  city = c(\"Tobermory\", \"Falkirk\", \"Ardbeg\", \"Doogal\", \"Kirkwall\")\n)\nstr(new_customers2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [5 × 3] (S3: tbl_df/tbl/data.frame)\n $ id      : chr [1:5] \"5\" \"6\" \"7\" \"8\" ...\n $ postcode: chr [1:5] \"PA75 6NR\" \"FK1 4RS\" \"PA42 7EA\" \"G81 4SJ\" ...\n $ city    : chr [1:5] \"Tobermory\" \"Falkirk\" \"Ardbeg\" \"Doogal\" ...\n```\n\n\n:::\n:::\n\n\n\n\nWenn wir versuchen, diesen Datensatz mit einem der anderen Datensätze zu verbinden, in denen `id` als `numeric`-Variable gespeichert ist, wird ein Fehler erzeugt.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#inner_join(customers, new_customers2)\n```\n:::\n\n\n\n\nDasselbe gilt für `bind_rows()`:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#bind_rows(customers, new_customers2)\n```\n:::\n\n\n\n\n\nUm dies zu vermeiden, müssen wir den Datentyp einer der beiden Variablen ändern. Dies kann man unter anderem mit den folgenden Funktionen tun: \n\n* `as.numeric()` - konvertiert eine Variable zu `numeric`. Nützlich, wenn Sie eine Variable aus Zahlen haben, die als Zeichen codiert wurden. Alle Werte, die nicht in Zahlen umgewandelt werden können (z. B. wenn Sie das Wort \"missing\" in Zellen haben, für die Sie keine Daten haben), werden als `NA` zurückgegeben.\n* `as.factor()` - konvertiert eine Variable zu einem `factor`. Sie können die Faktorstufen und -labels manuell festlegen oder die Standardreihenfolge (alphabetisch) verwenden.\n* `as.character()` - konvertiert eine Variable zu `character`-Daten.\n\nUm diese Funktionen auf eine Variable anzuwenden, können wir `mutate()` verwenden, um die Variable mit dieser Variablen als dem neuen Datentyp zu überschreiben:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_customers2 <- new_customers2 %>%\n  mutate(id = as.numeric(id))\n```\n:::\n\n\n\n\nSobald wir dies getan haben, funktionieren die Joins nun:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninner_join(orders, new_customers2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(id)`\n```\n\n\n:::\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| id| items|postcode |city      |\n|--:|-----:|:--------|:---------|\n|  5|     9|PA75 6NR |Tobermory |\n|  5|    11|PA75 6NR |Tobermory |\n|  6|    11|FK1 4RS  |Falkirk   |\n|  6|    12|FK1 4RS  |Falkirk   |\n|  7|     3|PA42 7EA |Ardbeg    |\n\n</div>\n:::\n:::\n\n\n\n\n\n## Übungen\n\nEs gibt viele verschiedene Anwendungsfälle für die `****_join()`-Funktionen. Diese Übungen ermöglichen es Ihnen, verschiedene Joins zu üben. Wenn Sie Beispiele haben, wo Joins in Ihrer eigenen Arbeit hilfreich sein könnten, teilen Sie diese bitte im Teams im Kanal der Woche 6 mit, da viele konkrete Beispiele dabei helfen können, zwischen den verschiedenen Joins zu unterscheiden.\n\n### Notendaten\n\nDas Bewertungsschema Schedule A der Universität Glasgow verwendet eine 22-stufige alphanumerische Skala (weitere Informationen finden Sie in Ihrem zusammenfassenden Bericht [Bewertungsinformationsblatt](https://sway.office.com/k0CnXGd6RjbVokkR){target=\"_blank\"}). Jede alphanumerische Note (z. B. B2) hat einen zugrunde liegenden numerischen Notenpunkt (z. B. 16).\n\nOft, wenn wir mit Studentennoten arbeiten, werden sie uns nur in einer dieser Formen zur Verfügung gestellt, aber wir müssen in der Lage sein, zwischen den beiden zu wechseln. Zum Beispiel benötigen wir die numerische Form, um deskriptive Statistiken über die Durchschnittsnote berechnen zu können, aber wir benötigen die alphanumerische Form, um sie den Studentenakten freizugeben.\n\n* Laden Sie <a href=\"data/grade_data1.csv\" download>grade_data.csv</a>, <a href=\"data/grade_data2.csv\" download>grade_data2.csv</a> und <a href=\"data/scheduleA.csv\" download>scheduleA.csv</a> in Ihren Datenordner.\n\n* Lesen Sie `scheduleA.csv` ein und speichern Sie es in einem Objekt namens `schedule`.\n* Lesen Sie `grade_data1.csv` ein und speichern Sie es in einem Objekt namens `grades1`.\n* Lesen Sie `grade_data2.csv` ein und speichern Sie es in einem Objekt namens `grades2`.\n\n\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nschedule <- read_csv(\"data/scheduleA.csv\")\ngrades1 <- read_csv(\"data/grade_data1.csv\") \ngrades2 <- read_csv(\"data/grade_data2.csv\")\n```\n\n:::\n:::\n\n\n\n\n\n### Übereinstimmung der Variablentypen\n\nAn der UofG erhält jeder Student eine GUID, eine numerische ID-Nummer. Diese ID-Nummer wird jedoch auch mit dem ersten Buchstaben Ihres Nachnamens kombiniert, um Ihren Benutzernamen zu erstellen, der zusammen mit Ihrer E-Mail-Adresse verwendet wird. Wenn beispielsweise Ihre ID 1234567 lautet und Ihr Nachname Nordmann ist, lautet Ihr Benutzername 1234567n. Aus Sicht der Datenbereinigung ist dies sehr ärgerlich, da die numerische ID als numerische Daten gespeichert wird, der Benutzername jedoch als Zeichen aufgrund des Buchstabens am Ende gespeichert wird. `grades1` hat eine numerische ID, während `grades2` den zusätzlichen Buchstaben hat. Um diese Datensätze zu verbinden, müssen wir die Variablen standardisieren.\n\nZuerst entfernen Sie den Buchstaben aus `id` mit der Funktion `stringr::str_replace_all()`, die Text ersetzt, der einem Muster entspricht. Hier verwenden wir das Muster `\"[a-z]\"`, das alle Kleinbuchstaben a bis z findet, und ersetzen sie mit `\"\"`. Siehe die Hilfe für `?about_search_regex` für weitere Informationen darüber, wie man Muster festlegt (diese können wirklich komplex werden).\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrades1 <- grades1 %>%\n  mutate(id = str_replace_all(\n    id, # die Variable, die Sie durchsuchen möchten\n    pattern = \"[a-z]\", # finde alle Buchstaben a-z\n    replacement = \"\" # ersetzen mit nichts\n  ))  \n```\n:::\n\n\n\n\n\nNun transformieren Sie den Datentyp von `id`, damit er mit dem Datentyp in `grades2` übereinstimmt.\n\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\n# überprüfen Sie die Variablentypen\nglimpse(grades1)\nglimpse(grades2) \n\ngrades1 <- grades1 %>%\n  mutate(id = as.numeric(id))\n```\n\n:::\n:::\n\n\n\n\n\n### Vollständige Datensätze\n\nIn diesem Beispiel möchten wir die Notendaten mit Schedule A verbinden, sodass jeder Student mit einer Note sowohl die Note als auch den Notenpunkt hat. Wir möchten aber auch einen vollständigen Datensatz aller Kursteilnehmer haben, also sollten Studenten mit fehlenden Noten trotzdem in den Daten enthalten sein.\n\n* Verbinden Sie `grades1` und `scheduleA` und speichern Sie diese Tabelle in einem Objekt namens `exam_all`.\n* Machen Sie dasselbe für `grades2` und speichern Sie es in `essay_all`.\n* Sowohl `exam_all` als auch `essay_all` sollten 100 Beobachtungen von 4 Variablen haben.\n\nHinweis:\nSie möchten alle Daten aus `grade_data1` und `grade_data2` behalten, aber Sie möchten nur die alphanumerischen Noten aus `schedule` für die Notenpunktwerte, die in `grades` vorhanden sind. Z. B., wenn niemand ein F1 verliehen wurde, sollten Ihre endgültigen Datensätze das nicht enthalten.\n\n\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nexam_all <- left_join(grades1, schedule, by = \"Points\")\nessay_all <- left_join(grades2, schedule, by = \"Points\")\n```\n\n:::\n:::\n\n\n\n\n\n### Fehlende Daten\n\nAlternativ möchten Sie möglicherweise einen Datensatz haben, der nur Daten für Studenten enthält, die jede Bewertung eingereicht haben und eine Note haben. Zuerst führen Sie `summary()` sowohl auf `exam_all` als auch auf `essay_all` aus. \n\n* Wie viele Prüfungsnoten fehlen? \n* Wie viele Aufsatznoten fehlen?\n\nNun erstellen Sie ein Objekt `exam_grades`, das `grades1` und `schedule` zusammenführt, aber diesmal sollte das resultierende Objekt nur Daten von Studenten enthalten, die eine Note haben. Machen Sie dasselbe für `grades2` und speichern Sie es in `essay_grades`.\n\nBevor Sie dies tun, angesichts dessen, was Sie über die Anzahl der fehlenden Datenpunkte in jedem Datensatz wissen:\n\n* Wie viele Beobachtungen sollte `exam_grades` haben?\n* Wie viele Beobachtungen sollte `essay_grades` haben?\n\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nexam_grades <- inner_join(grades1, schedule, by = \"Points\")\nessay_grades <- inner_join(grades2, schedule, by = \"Points\")\n```\n\n:::\n:::\n\n\n\n\nHide:\nEs ist erwähnenswert, dass Sie in der Realität nicht tatsächlich zu den Rohdaten zurückkehren und einen weiteren Join durchführen würden, um diesen Datensatz zu erhalten, sondern Sie könnten einfach alle fehlenden Antworten entfernen, indem Sie `%>% drop_na()` zu `exam_all` und `essay_all` hinzufügen. Wir werden dies jedoch aus didaktischen Gründen auf diese etwas künstliche Weise tun.\n\n\nNun erstellen Sie einen Datensatz `completes`, der die Noten für Studenten verbindet, die sowohl für den Aufsatz als auch für die Prüfung eine Note haben.  \n\n* Da sowohl `exam_grades` als auch `essay_grades` die Variablen `Assessment`, `Points` und `Grades` haben, die gleich benannt sind, aber unterschiedliche Daten haben, sollten Sie das Suffix ändern, damit die resultierenden Variablen `Points_exam` und `Points_essay` usw. benannt sind. Sie müssen möglicherweise die Hilfedokumentation konsultieren, um ein Beispiel zu sehen, um dies herauszufinden. \n* Bereinigen Sie die Datei mit `select()` und behalten Sie nur die Variablen `id`, `Grade_exam` und `Grade_essay`\n\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\ncompletes <- inner_join(exam_grades, essay_grades, \n                        by = \"id\", \n                        suffix = c(\"_exam\", \"_essay\")) %>%\n  select(id, Grade_exam, Grade_essay)\n```\n\n:::\n:::\n\n\n\n\n* Wie viele Studenten haben eine Note für sowohl die Prüfung als auch den Aufsatz?\n\nN\n\nun erstellen Sie einen Datensatz `no_essay`, der Studenten enthält, die eine Note für die Prüfung haben, aber nicht für den Aufsatz.\n\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nno_essay <- anti_join(exam_grades, essay_grades, by = \"id\")\n```\n\n:::\n:::\n\n\n\n\n-   Wie viele Studenten haben eine Note für die Prüfung, aber nicht für den Aufsatz? \n\n\nSchließlich erstellen Sie nun einen Datensatz `no_exam`, der Studenten enthält, die eine Note für den Aufsatz haben, aber nicht für die Prüfung\n\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nno_exam <- anti_join(essay_grades, exam_grades, by = \"id\")\n```\n\n:::\n:::\n\n\n\n\n-   Wie viele Studenten haben eine Note für den Aufsatz, aber nicht für die Prüfung?\n\n### Teilen auf Teams\n\nWenn Sie fertig sind, teilen Sie Ihre gestrickte HTML-Datei und die Rmd-Datei für die Übungen auf Teams im Kanal der Woche 07.\n\n\n\n## Weiterführende Ressourcen {#sec-resources-joins}\n\n* [Data transformation cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)\n* [Kapitel 19: Joins](https://r4ds.hadley.nz/joins) in *R für Datenwissenschaft*\n* [Kapitel 26: Iteration](https://r4ds.hadley.nz/iteration) in *R für Datenwissenschaft*.\n* [purrr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/purrr.pdf)\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}