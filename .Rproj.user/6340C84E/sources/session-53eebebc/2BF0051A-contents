# Datenvisualisierung {#sec-viz}


## link for tables: https://blog.djnavarro.net/posts/2024-06-21_table1/

## Beabsichtigte Lernergebnisse {#sec-ilo-viz .unnumbered}

* Kategorische und kontinuierliche Daten identifizieren können
* Plots schichtweise mit ggplot erstellen können
* Geeignete Plots für Daten auswählen können

## Verwendete Funktionen {#functions-viz}

```{r, include = FALSE}
# Lade tidyverse-Pakete separat, damit automatische Verlinkungen in `func()` funktionieren
library(readr)
library(dplyr)
library(ggplot2)
library(lubridate)
library(glossary)
library(knitr)
library(webexercises)
library(flipbookr)

```

* integriert (diese können immer verwendet werden, ohne Pakete zu laden)
    * base:: , `as.numeric()`, `c()`, `factor()`, `mean()`, `seq()`, 
    * grDevices:: `rgb()`
* tidyverse (alle diese können mit `library(tidyverse)` verwendet werden)
    * readr:: `col_character()`, `col_datetime()`, `col_double()`, `col_factor()`, `col_integer()`, `cols()`, `read_csv()`
    * lubridate:: `now()`, `today()`
    * dplyr:: `count()`, `glimpse()`, 
    * ggplot2:: `aes()`, `coord_cartesian()`, `element_blank()`, `facet_wrap()`, `geom_bar()`, `geom_boxplot()`, `geom_col()`, `geom_histogram()`, `geom_jitter()`, `geom_point()`, `geom_smooth()`, `ggplot()`, `ggtitle()`, `guides()`, `scale_fill_manual()`, `scale_x_continuous()`, `scale_x_date()`, `scale_x_discrete()`, `scale_y_continuous()`, `spec()`, `stat_summary()`, `theme()`, `theme_bw()`, `theme_minimal()`, `theme_set()`
* andere (jedes Paket muss geladen werden, um diese zu verwenden)
    * ggthemes:: `theme_gdocs()`
    * patchwork:: `plot_layout()`



```{r setup-viz, message=FALSE, verbatim="r setup, include=FALSE"}
library(tidyverse) # enthält ggplot2
library(patchwork) # für mehrteilige Plots
library(ggthemes)  # für Plot-Themen
library(lubridate) # für die Manipulation von Daten
```

In diesem Kapitel befassen wir uns mit der Datenvisualisierung mit dem Packet `ggplot2`. Laden Sie zuerst den [ggplot2-Spickzettel](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf) herunter. Bevor wir uns mit dem Erstellen von Abbildungen beschäftigen, machen wir einen kurzen Rückblick zu den verschiedenen Variablentypen. Denn für die Erstellung von Abbildungen ist es wichtig, dass man weiss, mit welchen Variablentypen man es zu tun hat. 

## Variablentypen
Wir gehen davon aus, dass unsere Daten bereits im `tidy` Format sind. Wie bereits besprochen heisst dies, dass jede Zeile eine Beobachtung ist, jede Spalte eine Variable und jede Zelle den Wert einer Beobachtung einer bestimmten Variable (Spalte) enthält. Die unten aufgeführte Tabelle mit Haustieren und ihren BesitzerInnen ist in einem solchen `tidy` Format. Jede Zeile ist eine Beobachtung eines Haustieres, jede Spalte ist eine Variable, und jede Zelle enthält den Wert der einer Variable eines bestimmten Haustieres. Es gibt 6 Variablen für jedes Haustier, ihren `name`, `owner`, `species`, `birthdate`, `weight` (in kg) und `rating` (auf einer 5-Punkte-Skala von "very evil" bis "very good").

```{r, echo = FALSE}
pets <- tribble(
  ~name,      ~owner,  ~species, ~birthdate,   ~weight, ~rating,
  "Darwin",   "Lisa",  "ferret", "1998-04-02",  1.2,    "a little evil",
  "Oy",       "Lisa",  "ferret", NA          ,  2.9,    "very good",
  "Khaleesi", "Emily", "cat",    "2014-10-01",  4.5,    "very good",
  "Bernie",   "Phil",  "dog",    "2017-06-01", 32.0,    "very good"
) %>%
  mutate(species = factor(species, c("dog", "cat", "ferret")),
         birthdate = as.Date(birthdate),
         rating = factor(rating, c("very evil", 
                                   "a little evil", 
                                   "neutral",
                                   "mostly good", 
                                   "very good")))

pets
```

Wie wir bereits besprochen haben, können Variablen entweder kontinuierlich (z.B. `weight`) oder kategorisch (z.B. `species`) sein. Beim Erstellen von Abbildungen muss man sich zuerst bewusst sein, mit was für Variablen man es zu tun hat. Denn einige Abbildungen eignen sich nur für bestimmte Variablentypen. Jede Variable hat auch einen `r glossary("data type")`, wie zum Beispiel `r glossary("numeric")` (Zahlen), `r glossary("character")` (Text) oder `r glossary("logical")` (Wahr/Falsch-Werte). Einige Plots funktionieren nur mit bestimmten Datentypen. Außerdem hat @sec-data-types mehr Details, da dieses Konzept wiederholt relevant sein wird.

```{r excel-format-cells, echo = FALSE, fig.cap="Datentypen sind wie die Kategorien, wenn Sie Zellen in Excel formatieren."}
include_graphics("images/appx/excel-format-cells.png")
```

### Kontinuierlich

`r glossary("Continuous")` Variablen sind Eigenschaften, die man genau messen und in einer natürlichen Reihenfolge ordnen kann, wie zum Beispiel das Gewicht. Sie können kontinuierliche Variablen in mathematischen Operationen verwenden, wie zum Beispiel die Gesamtsumme einer Spalte von Preisen oder die durchschnittliche Anzahl von Likes in sozialen Medien pro Tag berechnen.

Kontinuierliche Variablen haben immer einen `r glossary("numeric")` Datentyp. Sie sind entweder `r glossary("integer", "integers")` wie `42` oder `r glossary("double", "doubles")` wie `3.14159`. 


```{r, warning=TRUE, filename="Beispiel"}
integer_vector <- c(1L, 2L, 4L) #"integer"-Vektor (der Buchstabe "L" teilt R mit, dass es sich um eine Ganzzahl handelt)

double_vector <- c(1, 2, 4)

class(integer_vector)
```

### Kategorisch

`r glossary("Categorical")` Variablen sind Variablen, die nur eine bestimmte Anzahl an Kategorien haben (zum Beipsiel die Haustierart). Man unterscheidet dabei noch zwischen kategorialen Variablen, die keine natürliche Ordnung haben, sogenannte `nominale` Variablen `r glossary("nominal")`. Die Haustierart gehört zu diesem Typ. Es gibt aber auch kategoriale Variablen, die man ordnen kann. Dies sind dann sogenante `ordinale` Variablen `r glossary("ordinal")`. Aber auch hier gibt es nur eine begrenzte Anzahl Kategorien und die Abstände zwischen den verschiedenen Kategorien können oft nicht gleichgesetzt werden. Ein Beispiel dafür sind die Plätze 1 bis 3 an Sportwettkämpfen. Gold ist besser als Silber, was wiederum besser als Bronze ist. Der Abstand zwischen Gold-Silber und Silber-Bronze ist jedoch nicht identisch. Ein weiteres Beispiel für solche Variablen sind die Abstufungen auf `r glossary("Likert")` Bewertungsskala. Auch wenn eine Skale die Zahlen 1-7 verwendet, um ordinale Variablen darzustellen, sollten Sie sie nicht wie kontinuierliche Variablen behandeln (obwohl dies in der Praxis oft gemacht wird...).

In R kann man kategoriale Variablen auf zwei Arten speichern. Man kann sie mit dem Datentyp `r glossary("character")` oder auch `r glossary("string", "strings")` genannt, speichern. Solche Variablen werden durch das Platzieren von Text in Anführungszeichen erstellt. Dieser Text kann Buchstaben, Satzzeichen oder sogar Zahlen enthalten. Zum Beispiel ist `"January"` eine Zeichenkette, aber auch `"1"`, wenn Sie es in Anführungszeichen setzen. Dieser Datentyp ist am besten für Variablen geeignet, die viele verschiedene Werte haben können, die Sie nicht im Voraus vorhersagen können.

```{r, filename="character/string Variable"}
categorical_string <- c("Lisa", "Emily", "Phil")

categorical_string
```


Kategoriale Daten können auch `r glossary("factor", "factors")` sein, eine spezielle Art von Ganzzahl, die es Ihnen ermöglicht, die Kategorienamen und ihre Reihenfolge anzugeben. Dies ist nützlich, um Plots so anzuzeigen, dass die Kategorien in der von Ihnen gewünschten Reihenfolge erscheinen (ansonsten sind sie standardmäßig alphabetisch sortiert). Der Faktordatentyp ist am besten für Kategorien geeignet, die eine bestimmte Anzahl von Ebenen haben (z.B. "Gold", "Silber", "Bronze").




```{r, filename="factor Variable"}
categorical_factor <- factor(levels = c(1, 2, 3), labels = c("Gold", "Silber", "Bronze"))

categorical_factor
```




:::{.to-webr}
```{r}
#| autorun: false
1 + 1
```
:::


### Daten und Zeiten

Daten und Zeiten sind ein Sonderfall von Variablen. Sie können sich wie kategoriale oder kontinuierliche Variablen verhalten, und es gibt spezielle Möglichkeiten, sie zu plotten. Daten und Zeiten können schwierig zu handhaben sein, aber das [<pkg>lubridate</pkg>(https://lubridate.tidyverse.org/) Paket bietet Funktionen, um Ihnen dabei zu helfen.

```{r}
# das aktuelle Datum
lubridate::today()
```

```{r}
# das aktuelle Datum
lubridate::today() -  as.Date("2024-01-01")
```

```{r}
# das aktuelle Datum und die aktuelle Uhrzeit in der GMT-Zeitzone
lubridate::now(tzone = "GMT")
```

Wir gehen hier nicht näher auf diesen Datentyp ein. 

::: {.callout-note .try}
## Testen Sie Ihr Verständnis

Kehren Sie zum Haustierdatensatz zurück, welcher Variablentyp ist in jeder Spalte? Sie können die Funktion `glimpse()` verwenden, um eine Liste der Spaltennamen, ihrer Datentypen und der ersten Werte in jeder Spalte anzuzeigen - hier ist die Ausgabe von `glimpse()` auf dem Haustierdatensatz.

```{r}
glimpse(pets)
```


```{r, include = FALSE}
num <- c(answer = "numeric", x = "character", x = "factor", x = "date")
chr <- c(x = "numeric", answer = "character", x = "factor",  x = "date")
fctr <- c(x = "numeric", x = "character", answer = "factor", x = "date")
date <- c(x = "numeric", x = "character", x = "factor", answer = "date")

cont <- c(answer = "continuous", x = "nominal", x = "ordinal", x = "date")
nom <- c(x = "continuous", answer = "nominal", x = "ordinal", x = "date")
ord <- c(x = "continuous", x = "nominal", answer = "ordinal", x = "date")
date <- c(x = "continuous", x = "nominal", x = "ordinal", answer = "date")
```

| Spalte      | Variablentyp | Datentyp     |
|:------------|:--------------|:--------------|
| `name`      | `r mcq(nom)`  | `r mcq(chr)`  |
| `owner`     | `r mcq(nom)`  | `r mcq(chr)`  |
| `species`   | `r mcq(nom)`  | `r mcq(fctr)` |
| `birthdate` | `r mcq(date)` | `r mcq(date)` |
| `weight`    | `r mcq(cont)` | `r mcq(num)`  |
| `rating`    | `r mcq(ord)`  | `r mcq(fctr)` |

:::



## Erstellen von Plots

```{r sim-survey, include = FALSE, eval = FALSE}
# Code für die Simulation der in diesem Kapitel verwendeten Daten
# für Studenten verborgen und nicht bei jedem Stricken ausgeführt, nur hier zur Referenz
library(faux)
set.seed(8765309)

issues <- c(
  tech = 0, 
  sales = 2, 
  returns = 1,
  other = 1
)

survey_data <- add_random(employee_id = 10) %>%
  add_random(caller_id = sample(50:100, 10), 
             .nested_in = "employee_id") %>%
  add_between("caller_id", issue_category = names(issues), 
              .prob = c(.4, .1, .3, .1)) %>%
  add_ranef("caller_id", 
            wait_time = 1, 
            call_time = 1, 
            .cors = 0.5) %>%
  add_ranef("employee_id", 
            employee_quality = 1, 
            employee_time = 1, 
            .cors = -.5) %>%
  mutate(caller_id = gsub("caller_id", "C", caller_id),
         employee_id = gsub("employee_id", "E", employee_id)) %>%
  add_ranef(error = 1) %>%
  mutate(call_start = runif(nrow(.), 2020, 2021) %>% date_decimal()) %>%
  mutate(wait_time = norm2beta(wait_time, 2, 4, ncp=10) * 5,
         call_time = norm2beta(call_time + employee_time, 2, 4, ncp=0) * 2 + 0.1,
         # rundet ab und fügt Ausreißer hinzu
         wait_time = round(wait_time * 60) + 
           sample(c(0, 100), nrow(.), T, c(99, 1)),
         call_time = round(call_time * 60) + 
           sample(c(0, 100), nrow(.), T, c(99, 1))
  ) %>%
  mutate(satisfaction = (employee_quality + 
           recode(issue_category, !!!issues) -
           (wait_time * .1) +
           (month(call_start) * -.05) +
           error) %>% norm2likert(prob = c(1,3,4,5,2))) %>%
  select(caller_id, employee_id, call_start, wait_time, call_time,
         issue_category, satisfaction)

write_csv(survey_data, "data/survey_data.csv")
```

Es gibt mehrere Ansätze zur Datenvisualisierung in R; in diesem Kurs werden wir das beliebte Paket <pkg>ggplot2</pkg> verwenden, das Teil der größeren `tidyverse`-Sammlung von Paketen ist. Eine Grammatik der Grafiken (das "gg" in "ggplot") ist eine standardisierte Art, die Komponenten einer Grafik zu beschreiben. <pkg>ggplot2</pkg> verwendet eine geschichtete Grammatik der Grafiken, bei der Plots in einer Reihe von Schichten ("layers") aufgebaut werden. Es kann hilfreich sein, sich jeden Plot als mehrere Elemente vorzustellen, die halbtransparent übereinander liegen. 

@fig-layers zeigt die Entwicklung eines einfachen Streudiagramms mit diesem geschichteten Ansatz. Zuerst wird der Plot-Raum erstellt (Schicht 1); die Variablen werden angegeben (Schicht 2); die Art der Visualisierung (bekannt als `geom`), die für diese Variablen gewünscht wird, wird angegeben (Schicht 3) - in diesem Fall wird `geom_point()` aufgerufen, um einzelne Datenpunkte zu visualisieren; ein zweites Geom wird hinzugefügt, um eine Linie der besten Anpassung einzusch

ließen (Schicht 4), die Achsenbeschriftungen werden für eine bessere Lesbarkeit bearbeitet (Schicht 5), und schließlich wird ein Thema angewendet, um das Gesamterscheinungsbild des Plots zu ändern (Schicht 6).

```{r fig-layers, fig.cap="Evolution eines geschichteten Plots", echo = FALSE, message=FALSE}
survey_data <- read_csv(file = "data/survey_data.csv",
                        show_col_types = FALSE)

x_breaks <- seq(from = 0, to = 600, by = 60)
y_breaks <- seq(from = 0, to = 600, by = 30)

a <- ggplot() + labs(subtitle = "Schicht 1")
b <- ggplot(survey_data, aes(x = wait_time, y = call_time)) + 
  labs(subtitle = "Schicht 2")
c <- b + geom_point(alpha = 0.2, color = "dodgerblue") + 
  labs(subtitle = "Schicht 3")
d <- c + geom_smooth(method = "lm", color = rgb(0, .5, .8)) + 
  labs(subtitle = "Schicht 4")
e <- d + scale_x_continuous(name = "Wartezeit (Sekunden)", breaks = x_breaks) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)", breaks = y_breaks) + 
  coord_cartesian(xlim = c(0, 360), ylim = c(0, 180)) +
  labs(subtitle = "Schicht 5")
f <- e + ggthemes::theme_gdocs(base_size = 10) + 
  theme(axis.line.x = element_blank(),
        plot.background = element_blank()) +
  labs(subtitle = "Schicht 6") +
  theme(plot.subtitle =  element_text(color = "black"))

a + b + c + d + e + f + plot_layout(nrow = 2)
```

Jede Schicht ist unabhängig und individuell anpassbar. Beispielsweise können die Größe, Farbe und Position jeder Komponente angepasst werden, oder man könnte beispielsweise das erste Geom (die Datenpunkte) entfernen, um nur die Linie der besten Anpassung zu visualisieren, indem man einfach die Schicht entfernt, die die Datenpunkte zeichnet (@fig-remove-layer). Die Verwendung von Schichten erleichtert den schrittweisen Aufbau komplexer Plots und die Anpassung oder Erweiterung von Plots aus vorhandenem Code.


```{r fig-remove-layer, fig.cap="Endplot mit entfernter Streudiagramm-Schicht.", echo = FALSE}

ggplot(survey_data, aes(x = wait_time, y = call_time)) + 
  #geom_point(alpha = 0.15, color = "dodgerblue") +
  geom_smooth(method = "lm", formula = y~x, color = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wartezeit (Sekunden)", breaks = seq(from = 0, to = 600, by = 60)) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)", breaks = seq(from = 0, to = 600, by = 30)) + 
  coord_cartesian(xlim = c(0, 360), ylim = c(0, 180)) +
  ggthemes::theme_gdocs(base_size = 11) +
  theme(axis.line.x = element_blank(),
        plot.background = element_blank())
```

### Plotdaten laden {#sec-plots-loading-data}
Um ein Gefühl für 'ggplot' zu bekommen, werden wir den obigen Plot Schritt-für-Schritt zusammen nachbauen. Als erstes laden wir die Daten:

```{r}
survey_data <- read_csv("https://psyteachr.github.io/ads-v2/data/survey_data.csv")
```

`read_csv()` zeigt uns direkt, wie viele Zeilen uns Spalten die eingelsenen Daten haben und mit welchem Datentyp die Zeilen gespeichert wurden ("Column specification"). 

Bei diesen Daten handelt es sich um simulierte Daten einer Kundenzufriedenheitsumfrage eines Callcenters. Bevor wir die Daten plotten, müssen wir uns mit ihnen vertraut machen. Was genau enthalten die Daten? Hier repräsentiert jede Zeile einen Anruf an das Zentrum.

* `caller_id` ist eine einzigartige ID für jeden Anrufer
* `employee_id` ist eine einzigartige ID für jeden Mitarbeiter, der Anrufe entgegennimmt
* `call_start` ist das Datum und die Uhrzeit, zu der der Anruf einging
* `wait_time` ist die Anzahl der Sekunden, die der Anrufer warten musste
* `call_time` ist die Anzahl der Sekunden, die der Anruf dauerte, nachdem der Mitarbeiter abgehoben hatte
* `issue_category` ist, ob das Problem technischer Natur war, Verkauf, Rücksendungen oder anderes
* `satisfaction` ist die Kundenzufriedenheitsbewertung auf einer Skala von 1 (sehr unzufrieden) bis 5 (sehr zufrieden)

Wenn man die Spaltentypen beim Einlesen nicht spezifiziert, werden Datenimportfunktionen einfach raten, um welche Typen es sich handelt, und normalerweise standardmäßig auf Double für Spalten mit Zahlen und Character für Spalten mit Buchstaben setzen. Verwenden Sie die Funktion `spec()`, um alle Spaltentypen herauszufinden und sie bei Bedarf zu bearbeiten.

```{r}
spec(survey_data)
```

Lassen Sie uns `issue_category` als Faktor festlegen und die Reihenfolge der Kategorien festlegen. Standardmäßig ordnet R die Kategorien eines Faktors alphanumerisch. Oft möchte man die Reihenfolge jedoch selber festlegen. In diesen Daten macht es am meisten Sinn, die Kategorie "other" am Ende der Liste zu haben. Nachdem Sie die Spaltentypen aktualisiert haben, müssen Sie die Daten erneut importieren, indem Sie den `read_csv()`-Code anpassen, um das Argument `col_types` auf die neuen Spaltentypen zu setzen.

::: {.callout-note}
## Definieren Sie Objekte, bevor Sie sie verwenden

Da `read_csv()` das Objekt `survey_col_types` verwenden wird, müssen Sie `survey_col_types` erstellen, bevor Sie den angepassten `read_csv()`-Code ausführen. Wenn Sie jemals Ihren Code anpassen müssen, versuchen Sie, über die Reihenfolge nachzudenken, in der der Code ausgeführt wird, wenn Sie von vorne beginnen, und stellen Sie sicher, dass er angemessen organisiert ist.
:::

```{r}
# aktualisierte Spaltentypen
survey_col_types <- cols(
  caller_id = col_character(),
  employee_id = col_character(),
  call_start = col_datetime(format = ""),
  wait_time = col_double(),
  call_time = col_double(),
  issue_category = col_factor(levels = c("tech", "sales", "returns", "other")),
  satisfaction = col_integer()
)

# Daten erneut importieren mit korrekten Spaltentypen
survey_data <- read_csv("https://psyteachr.github.io/ads-v2/data/survey_data.csv",
                        col_types = survey_col_types)
```


### Plot-Setup

#### Daten {#sec-plot-setup-data}

Jeder Plot beginnt mit der Funktion `ggplot()` und einem Datensatz. Für Übungszwecke ist es zu Beginn gut, den Plot schrittweise aufzubauen. Wie spezifizieren als ersten Schritt also nur, welche Daten für den Plot verwendet werden sollen. Dies genriert ein weisses Feld, sozusagen ein Platzhalter für den zu erschaffenden Plot. 

```{r fig-build-plot-setup, fig.cap = "Ein leerer ggplot."}
ggplot(data = survey_data)
```

#### Mapping

Das nächste `r glossary("argument")` zu `ggplot()` ist das `mapping`. Dies teilt dem Plot mit, welche Spalten/Variablen in den Daten durch welche Aspekte des Plots repräsentiert werden sollen. Diese Aspekte oder "Ästhetiken" werden innerhalb der Funktion `aes()` aufgelistet. Dabei handelt es sich um Sachen wie die x-Achse, y-Achse, Linienfarbe, Objektfüllung oder Linienstil. 

Im Folgenden sagen wir ggplot durch das `mapping` Argument via die Funktion `aes`, dass die Variable `wait_time` auf der x-Achse und die Variable `call_time` auf der y-Achse abgebildet werden soll. 


Legen Sie die Argumente `x` und `y` auf die Namen der Spalten fest, die Sie auf diesen Achsen plotten möchten. Hier möchten wir die Wartezeit auf der x-Achse und die Anrufzeit auf der y-Achse plotten. Dies füllt den Plot nun mit zwei Beschrifteten Achsen. In einem nächsten Schritt werden wir den Plot mit sogenannten `geoms` füllen. 

```{r fig-build-plot-mapping, fig.cap = "Ein leerer Plot mit zugeordneten x- und y-Achsen."}
# den Plot mit Mapping einrichten
ggplot(
  data = survey_data, 
  mapping = aes(x = wait_time, y = call_time)
)
```

::: {.callout-note}
## ggplot-Argumentnamen

Im obigen Beispiel haben wir die Namen der `r glossary("argument", "arguments")` `data` und `mapping` ausgeschrieben, aber in der Praxis lassen fast alle diese weg. Stellen Sie einfach sicher, dass Sie die Daten und das Mapping in der richtigen Reihenfolge platzieren.

```{r, eval = FALSE}
ggplot(survey_data,  aes(x = wait_time, y = call_time))
```
:::

#### Geoms

Nun können wir unsere Plot-Elemente schichtenweise hinzufügen. Diese Elemente werden als `r glossary("geom", "geoms")` bezeichnet und ihre Funktionen beginnen mit `geom_`. Man fügt Schichten zum Basis-Plot, der von `ggplot()` erstellt wurde, mit einem Plus (`+`) hinzu. 

```{r fig-build-plot-geoms, fig.cap="Einen Streudiagramm mit geom_point() hinzufügen."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point() # Streudiagramm
```

::: {.callout-warning collapse="true"}
## Position des +

Etwas ärgerlicherweise muss das Plus am Ende der vorherigen Zeile stehen, nicht am Anfang der nächsten Zeile. Wenn Sie diesen Fehler machen, wird die erste Zeile des Codes ausgeführt, um die Basisschicht zu produzieren, aber dann erhalten Sie die folgende Fehlermeldung, anstatt `geom_point()` hinzuzufügen.

```{r, error = TRUE}
ggplot(survey_data, aes(x = wait_time, y = call_time))
+ geom_point() # Streudiagramm
```
:::

#### Mehrere Geoms

Ein Teil der Stärke von <pkg>ggplot2</pkg> ist, dass man mehr als ein Geom zu einem Plot hinzufügen kann, indem man einfach weitere `geom_` Teile spezifiziert. Geoms, die zuerst spezifiziert werden, werden auch zuerst angezeigt. Das kann dazu führen, dass spätere hinzugefügte Geoms früher hinzugefügte Geoms überdecken:

```{r fig-build-plot-geom2-code, eval = FALSE}

# Punkte zuerst
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point() + # Streudiagramm
  geom_smooth(method = lm) # Linie der besten Anpassung

# Linie zuerst
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_smooth(method = lm) + # Linie der besten Anpassung
  geom_point() # Streudiagramm

```


```{r fig-build-plot-geom2, fig.cap="Punkte zuerst gegen Linie zuerst.", message = FALSE, echo  = FALSE}
point_first <- 
  ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point() + # Streudiagramm
  geom_smooth(method = lm) # Linie der besten Anpassung
  
line_first <-
  ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_smooth(method = lm) + # Linie der besten Anpassung
  geom_point() # Streudiagramm

# fügt Plots zusammen in 1 Reihe
point_first + line_first + plot_layout(nrow = 1)
```

#### Speichern von Plots

Genau wie man Zahlen und Datentabellen als Objekte speichern kann, kann man auch den durch`ggplot()` erstellten plot speichern. Der untenstehende Code produziert dieselben Plots, die wir oben erstellt haben, speichert sie aber zu Objekten namens `point_first` und `line_first`. Wenn wir nur diesen Code ausführen, werden die Plots nicht angezeigt wie zuvor. Stattdessen sehen Sie die Objektnamen im Umgebungsbereich.

```{r, message = FALSE}
point_first <- 
  ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point() + # Streudiagramm
  geom_smooth(method = lm) # Linie der besten Anpassung
  
line_first <-
  ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_smooth(method = lm) + # Linie der besten Anpassung
  geom_point() # Streudiagramm
```

Diese plots sind nun also Objekte, die wir zu einem späteren Zeitpunkt wieder abrufen oder weiterbearbeiten können. 

Um die Plots anzuzeigen, rufen wir die Objekte beim Namen auf. Dies gibt jeden Plot separat aus.

```{r, eval = FALSE}
point_first # ersten Plot anzeigen
line_first # zweiten Plot anzeigen
```

#### Kombinieren von Plots

Einer der Gründe, wieso wir Plots in Objekten speichern besteht darin, dass man mehrere Plots mithilfe von Funktionen aus dem `patchwork`-Paket kombinieren kann. Der untenstehende Code produziert den schon oben gesehenen Plot (Figure 8.6), indem er die beiden Plots mit `+` kombiniert und dann angibt, dass wir die Plots auf einer einzigen Reihe mit dem `nrow`-Argument in `plot_layout()` produzieren möchten.


```{r, fig-build-plot-geom2b, fig.cap="Kombinieren von Plots mit patchwork.", message = FALSE}
# fügt Plots zusammen in 1 Reihe
point_first + line_first + plot_layout(nrow = 1)
```


::: {.callout-note .try}
## Versuchen Sie, nrow auf 2 zu ändern
:::


### Anpassen von Plots

Es gibt nahezu endlose Möglichkeiten, ggplots anzupassen. Wir werden hier einige der grundlegenden Anpassungen behandeln.

#### Styling von Geoms

Wir sollten definitiv die Linie vor den Punkten platzieren, aber die Punkte sind immer noch etwas dunkel. Wenn man den allgemeinen Stil eines Geoms ändern möchten, kann man die Argumente `colour`, `alpha`, `shape`, `size` und `linetype` innerhalb der Geom-Funktion festlegen. Es gibt viele verschiedene Werte, auf die man diese einstellen kann; @sec-plotstyle gibt Details dazu. Probieren Sie verschiedene Werte unten aus und finden Sie heraus, was die `r glossary("default value", "default values")` für `shape` und `size` sind. 

```{r fig-build-plot-style, fig.cap="Ändern von Geom-Stilen."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2, # 20 % Transparenz
             shape = 18,  # solider Diamant
             size = 2) + 
  geom_smooth(method = lm, 
              formula = y~x, # Formel zum Zeichnen der Linie, 
              # Festlegung von Methode und Formel vermeidet eine ärgerliche Nachricht
              colour = rgb(0, .5, .8),
              linetype = 3) 
```

::: {.callout-warning}
## Ästhetik insgesamt versus nach Kategorie festlegen

Diese Methode dient nur dazu, den Stil aller Elemente zu ändern, die mit diesem Geom erstellt wurden. Wenn Sie möchten, dass zum Beispiel Punkte je nach Ausgabekategorie unterschiedliche Farben haben, legen Sie das Argument `colour = issue_category` innerhalb der Funktion `aes()` für das Mapping fest. Sie können die verwendeten Farben mit `scale_`-Funktionen anpassen, die Sie unten und in @sec-plotstyle lernen werden).
:::

#### Achsen formatieren

Nun müssen wir die Achsen ordentlicher beschriften Es gibt mehrere Funktionen, mit denen man die Achsenbeschriftungen ändern kann, aber die leistungsfähigsten sind die `scale_`-Funktionen. Sie müssen eine Skalenfunktion verwenden, die zu den Daten passt, die Sie auf dieser Achse plotten, und hier wird es besonders wichtig zu wissen, mit welchem Datentyp man arbeitet. Beide Achsen hier sind `r glossary("continuous")`, daher verwenden wir `scale_x_continuous()` und `scale_y_continuous()`.

Das Argument `name` ändert die Achsenbeschriftung. Das Argument `breaks` legt die Haupteinheiten fest und benötigt einen `r glossary("vector")` möglicher Werte, der auch über den Bereich der Daten hinausgehen kann. Die Funktion `seq()` erstellt eine Folge von Zahlen `from` einer `to` einer anderen `by` festgelegten Schritten:

```{r, filename="Beispiel von seq()"}
seq(from = 0, to = 600, by = 60)
```


```{r fig-build-plot-axes, fig.cap="Formatierung von Plotachsen mit scale_-Funktionen."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  # Achsenbeschriftungen und Unterbrechungen anpassen
  scale_x_continuous(name = "Wartezeit (Sekunden)", 
                     breaks = seq(from = 0, to = 600, by = 60)) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)",
                     breaks = seq(from = 0, to = 600, by = 30))
```

::: {.callout-note .try}
## Kleinere Unterbrechungen

Überprüfen Sie die Hilfe zu `?scale_x_continuous`, um zu sehen, wie Sie die kleineren Einheiten festlegen oder angeben würden, wie viele Unterbrechungen Sie möchten.
:::

::: {.callout-note .try}
## Die `labs` Funktion

Man kann die Achsen auch über die `labs` Funktion beschriften. Dies kann dann nützlich sein, wenn man an den Achsen sonst nichts anpassen muss:
```{r}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  labs(x = "Wartezeit (Sekunden)",
       y = "Anrufzeit (Sekunden)")
```

:::


#### Achsengrenzen

Wenn man die minimalen und maximalen Werte auf einer Achse ändern möchte, verwendet man die Funktion `coord_cartesian()`. Viele Plots sind sinnvoller, wenn die minimalen und maximalen Werte den Bereich möglicher Werte darstellen, auch wenn diese Werte nicht in den Daten vorhanden sind. Hier können Warte- und Anrufzeiten nicht weniger als 0 Sekunden betragen, also legen wir die Minimalwerte auf 0 und die Maximalwerte auf die erste Unterbrechung über dem höchsten Wert fest.

```{r fig-build-plot-limits, fig.cap="Ändern der Achsengrenzen."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wartezeit (Sekunden)", 
                     breaks = seq(from = 0, to = 600, by = 60)) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)",
                     breaks = seq(from = 0, to = 600, by = 30)) +
  # Achsengrenzen festlegen
  coord_cartesian(xlim = c(0, 360), 
                  ylim = c(0, 180))
```

::: {.callout-caution}
## Grenzen mit der scale_-Funktion festlegen

Sie können auch das Argument `limits` innerhalb der `scale_`-Funktionen festlegen, aber dies entfernt tatsächlich alle Daten, die außerhalb dieser Grenzen liegen, anstatt Ihren Plot zu beschneiden, und dies kann das Erscheinungsbild bestimmter Plot-Typen wie Violin-Plots und Dichtegraphen ändern. Deshalb sollte die `scale_` Funktion dafür nicht verwendet werden.
:::

#### Themes {#sec-themes}
Damit man für das ästhetische "Finetuning" des Plots nicht immer alle Werte selber spezifizieren muss, gibt es eine Reihe von sogenannten `Themes` die Plots in einem besetimmten Design erscheinen lassen. <pkg>ggplot2</pkg> kommt mit mehreren integrierten Themen, wie `theme_minimal()` und `theme_bw()`, aber das [<pkg>ggthemes</pkg>](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) Paket bietet noch mehr Themen, die verschiedenen Softwareprogrammen entsprechen, wie GoogleDocs, Excel oder Stata. Im folgenden wenden wir das Excel theme an und ändern die Schriftgrösse mit dem Argument `base_size`.


```{r fig-build-plot-theme, fig.cap="Ändern des Themes zum Google Docs-Stil."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wartezeit (Sekunden)", 
                     breaks = seq(from = 0, to = 600, by = 60)) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)",
                     breaks = seq(from = 0, to = 600, by = 30)) +
  coord_cartesian(xlim = c(0, 360), 
                  ylim = c(0, 180)) +
  # das Theme ändern
  ggthemes::theme_excel(base_size = 20)
```

Das Resultat ist nicht gerade ansprechend. Das steht auch ausdrücklich in der Dokumentation der Funktion `ggthemes::theme_excel`: "Theme to replicate the ugly monstrosity that was the old gray-background Excel chart. Please never use this."

Versuchen wir es also mit einem anderen theme:
```{r fig-build-plot-theme-economist, fig.cap="Ändern des Themes zum Google Docs-Stil."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wartezeit (Sekunden)", 
                     breaks = seq(from = 0, to = 600, by = 60)) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)",
                     breaks = seq(from = 0, to = 600, by = 30)) +
  coord_cartesian(xlim = c(0, 360), 
                  ylim = c(0, 180)) +
  # das Theme ändern
  ggthemes::theme_economist(base_size = 20)
```

Der Plot sieht mit dem Theme der Zeitschrift Economist schon deutlich besser aus. 


#### Theme-Anpassungen

Wenn wir mit einem Theme immer noch nicht ganz zufrieden sind, können wir es mit der Funktion `themes()` weiter anpassen. Überprüfen Sie die Hilfe für diese Funktion, um alle möglichen Optionen zu sehen (mit `?themes`, die Liste der zu ändernden Elemente ist ziemlich lang). Oft will man, anstatt ein Elment zu ändern, ein Element komplett entfernen. Dies tut man, indem man das relvante Argument auf `element_blank()` setzt. Unten entfernen wir die x-Achsenlinie und den Plot-Hintergrund:

```{r fig-build-plot-custom-theme, fig.cap="Anpassen des Themes, um die x-Achsenlinie und den Hintergrundumriss zu entfernen."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wartezeit (Sekunden)", 
                     breaks = seq(from = 0, to = 600, by = 60)) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)",
                     breaks = seq(from = 0, to = 600, by = 30)) +
  coord_cartesian(xlim = c(0, 360), 
                  ylim = c(0, 180)) +
  theme_gdocs(base_size = 11) +
  # Theme-Elemente anpassen
  theme(axis.line.x = element_blank(),
        plot.background = element_blank())
```

### Plotbeschriftungen {#sec-captions}

Oft möchte man Plots auch mit Titel und/oder Untertitel versehen. Dies können wir mit der bereits kennengelernten Funktion `labs` tun:

```{r fig-caption, fig.cap="Hinzufügen eines Titels, Untertitels und einer Bildunterschrift."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(colour = "dodgerblue", 
             alpha = 0.2) + 
  geom_smooth(method = lm, 
              formula = y~x, 
              colour = rgb(0, .5, .8)) +
  scale_x_continuous(name = "Wartezeit (Sekunden)", 
                     breaks = seq(from = 0, to = 600, by = 60)) +
  scale_y_continuous(name = "Anrufzeit (Sekunden)",
                     breaks = seq(from = 0, to

 = 600, by = 30)) +
  coord_cartesian(xlim = c(0, 360), 
                  ylim = c(0, 180)) +
  theme_gdocs(base_size = 11) +
  theme(axis.line.x = element_blank(),
        plot.background = element_blank()) +
  labs(title = "Die Beziehung zwischen Wartezeit und Anrufzeit",
       subtitle = "Anrufdaten 2020",
       caption = "Abbildung 1. Mit zunehmender Wartezeit steigt die Anrufzeit.")
```


## Geeignete Plots
Der Aufbau von Plots, wie wir ihn gerade gelernt haben, ist immer gleich. Man muss jedoch die Art des Plots den Daten(typen) anpassen, die man plotten will. Entsprechend ist dieser Abschnitt nach Datentypen strukturiert. 

Der [ggplot2-Spickzettel](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf) ist eine großartige Ressource die dabei hilft, Plots zu finden, die zu den Daten passen. 


Die untenstehenden Beispiele verwenden alle dieselben Kundenzufriedenheitsdaten, aber jeder Plot kommuniziert etwas anderes. 

Es wird nicht erwartet, dass Sie sich alle Plot-Typen oder die Methoden zur Anpassung merken, aber es wird hilfreich sein, den Code in den folgenden Beispielen selbst auszuprobieren, indem Sie Werte ändern, um Ihr Verständnis zu testen.

### Kategorien zählen

#### Balkendiagramm

Wenn Sie die Anzahl Beobachtungen pro Kategorie zählen möchten, können Sie `geom_bar()` verwenden. Sie müssen nur eine `x`-Zuordnung zu `geom_bar()` bereitstellen, denn standardmäßig verwendet `geom_bar()` die Anzahl der Beobachtungen in jeder Gruppe von `x` als Wert für `y`, sodass Sie `ggplot` nicht mitteilen müssen, was auf der y-Achse stehen soll.

```{r fig-bar, fig.cap="Ein einfaches Balkendiagramm."}
ggplot(survey_data, aes(x = issue_category)) +
  geom_bar()
```

::: {.callout-note .try}
## Anpassen des Aussehens von Balkendiagrammen

Sie möchten wahrscheinlich einige Dinge anpassen, wie die Farben, die Reihenfolge der Spalten und ihre Beschriftungen. Untersuchen Sie den untenstehenden Code und versuchen Sie, ihn Schicht für Schicht auszuführen, um herauszufinden, wo sich diese Dinge ändern. Die Funktionen `scale_fill_manual()` und `scale_x_discrete()` sind neu, funktionieren aber auf die gleiche Weise wie die anderen `scale_`-Funktionen. Sie lernen mehr darüber in @sec-custom-viz.

```{r custom-bar, webex.hide = "Code"}

ggplot(survey_data, aes(x = issue_category, 
                        fill = issue_category)) +
  geom_bar() +
  scale_x_discrete(
    # Achsentitel ändern
    name = "Issue-Kategorie", 
    # Reihenfolge ändern
    limits = c("tech", "returns", "sales", "other"), 
    # Beschriftungen ändern
    labels = c("Technisch", "Rückgaben", "Verkäufe", "Andere") 
  ) +
  scale_fill_manual(
    # Farben ändern
    values = c(tech = "goldenrod", 
                returns = "darkgreen", 
                sales = "dodgerblue3", 
                other = "purple3"),
    # die Legende entfernen
    guide = "none" 
  ) +
  scale_y_continuous(
    name = "", # Achsentitel entfernen
    # den Raum oberhalb und unterhalb der y-Achse entfernen
    expand = expansion(add = 0)
  ) +
  # Minimum = 0, Maximum = 350
  coord_cartesian(ylim = c(0, 350)) + 
  ggtitle("Anzahl der Probleme pro Kategorie") # einen Titel hinzufügen
```
:::

#### Säulendiagramm

Wenn Ihre Daten bereits eine Spalte mit der Anzahl enthalten, die Sie plotten möchten, können Sie `geom_col()` verwenden, um sie zu plotten. Wir können die Funktion `count()` verwenden, um eine Tabelle mit einer Zeile für jede `issue_category` und einer Spalte namens `n` mit der Anzahl der Beobachtungen in dieser Kategorie zu erstellen.

```{r}
count_data <- count(survey_data, issue_category)
```

`r kable(count_data)`

Das Mapping für `geom_col()` erfordert, dass Sie sowohl die `x`- als auch die `y`-Ästhetik festlegen. Setzen Sie `y = n`, weil wir die Anzahl der Probleme in jeder Kategorie plotten möchten, und diese Information befindet sich in der Spalte namens `n`.

```{r fig-col, fig.cap="Ein einfaches Säulendiagramm."}
ggplot(count_data, aes(x = issue_category, y = n)) +
  geom_col()
```


#### Tortendiagramm

Tortendiagramme sind eine [irreführende Form der Datenvisualisierung](https://www.data-to-viz.com/caveat/pie.html){target="_blank"}, daher werden wir sie nicht behandeln. Wir werden andere Methoden behandeln, die sich besser für die Visualisierung von Anteilen handeln. 


::: {.callout-note .try}
## Testen Sie Ihr Verständnis

```{r, include = FALSE}
bar <- c(answer = "geom_bar", x = "geom_col")
col <- c(x = "geom_bar", answer = "geom_col")
```


Hier ist eine kleine Datentabelle.

country             | population      | island
:-------------------|----------------:|:--------------
Nordirland    | 1,895,510       | Irland
Wales               | 3,169,586       | Großbritannien
Republik Irland | 4,937,786       | Irland
Schottland            | 5,466,000       | Großbritannien
England             | 56,550,138      | Großbritannien


* Welches Geom würden Sie verwenden, um die Bevölkerung für jedes der 5 Länder zu plotten? `r mcq(col)`
```{r test-counting-categories, echo = FALSE, results='asis'}
opt <- c(answer = "aes(x = country, y = population)",
         x = "aes(x = population, y = country)",
         x = "aes(x = country)",
         x = "aes(x = island)",
         x = "aes(y = population)")
cat("* Welches Mapping würden Sie verwenden? ", longmcq(opt))
```
* Welches Geom würden Sie verwenden, um die Anzahl der Länder auf jeder Insel zu plotten? `r mcq(bar)`
```{r, echo = FALSE, results='asis'}
opt <- c(x = "aes(x = country, y = population)",
         x = "aes(x = population, y = country)",
         x = "aes(x = country)",
         answer = "aes(x = island)",
         x = "aes(y = population)")
cat("* Welches Mapping würden Sie verwenden? ", longmcq(opt))
```
:::

### Plots mit einer kontinuierlichen Variable {#sec-histogram}

Wenn Sie eine kontinuierliche Variable haben, wie die Anzahl der Sekunden, die Anrufer warten mussten, können Sie `geom_histogram()` verwenden, um die Verteilung der Variable zu visualisieren. Genau wie bei `geom_bar()` muss man dabei nur die `x`-Variable angeben. 

Ein Histogramm teilt die Daten in "Bins" entlang der x-Achse auf und zeigt die Anzahl der Beobachtungen in jedem Bin entlang der y-Achse.

```{r fig-histogram, fig.cap="Histogramm der Wartezeiten."}
ggplot(survey_data, aes(x = wait_time)) +
  geom_histogram()
```

Sie sollten immer die `binwidth` oder die Anzahl der `bins` auf etwas Sinnvolles für Ihre Daten festlegen (wie per Mitteilung angegeben ist der Default 30 `bins`, was mehr oder meist weniger sinnvoll sein kann). Sie müssen möglicherweise einige Optionen ausprobieren, bevor Sie etwas finden, das gut aussieht und die Verteilung der Variable gut darstellt -- versuchen Sie, die Werte von `binwidth` und `bins` unten zu ändern, um zu sehen, was am besten funktioniert.

```{r eval = FALSE}
# Breite jeder Leiste anpassen
ggplot(survey_data, aes(x = wait_time)) +
  geom_histogram(binwidth = 30)

# Anzahl der Leisten anpassen
ggplot(survey_data, aes(x = wait_time)) +
  geom_histogram(bins = 5)
```


Standardmäßig beginnen die Balken *zentriert* auf 0, also wenn `binwidth` auf 30 eingestellt ist, würde der erste Balken -15 bis 15 Sekunden umfassen, was keinen Sinn macht. Wir können `boundary = 0` setzen, damit jeder Balken 30-Sekunden-Inkremente *ab* 0 darstellt. 

```{r fig-histogram-boundary0, fig.cap="Ein Histogramm mit der Grenze auf 0 gesetzt."}
ggplot(survey_data, aes(x = wait_time)) +
  geom_histogram(binwidth = 30, boundary = 0)
```


Schließlich ist der Standardstil von grauen Balken hässlich, also können Sie das ändern, indem Sie `fill` und `colour` festlegen, sowie `scale_x_continuous()` verwenden, um die Achsenbeschriftungen zu aktualisieren. 

```{r fig-histogram-custom, fig.cap="Histogramm mit benutzerdefinierten Stilen."}
ggplot(survey_data, aes(x = wait_time)) +
  geom_histogram(binwidth = 15, 
                 boundary = 0, 
                 fill = "white", 
                 color = "black") +
  scale_x_continuous(name = "Wartezeit (Sekunden)",
                     breaks = seq(0, 600, 60))
```

::: {.callout-note .try}
## Testen Sie Ihr Verständnis

Stellen Sie sich vor, Sie haben eine Tabelle mit der [Bevölkerung für jedes Land der Welt](https://population.un.org/wpp/Download/Standard/Population/){target="_blank"} mit den Spalten `country` und `population`. Wir werden uns nur die 76 Länder mit Bevölkerungen unter einer Million ansehen.

```{r test-one-continuous, echo = FALSE}
# Daten laden
pop_data <- readxl::read_excel("data/WPP2019_POP_F01_1_TOTAL_POPULATION_BOTH_SEXES.xlsx", skip = 16) %>%
  filter(Type == "Country/Area") %>%
  select(country = 3, population = `2020`) %>%
  mutate(population = round(as.numeric(population) * 1000)) %>%
  filter(population < 1e6)
  
# Plots erstellen
ggplot(pop_data, aes(x = population)) +
  scale_x_continuous(breaks = seq(0, 1e6, 1e5),
                     labels = c(paste0(0:9*100, "K"), "1M")) +
  scale_y_continuous(name = "Anzahl der Länder") + 
  geom_histogram(binwidth = 1e5, boundary = 0, fill = "white", color = "black")
```


```{r, echo = FALSE, results='asis'}
opts <- c(x = "aes(x = country, y = population)",
          x = "aes(x = population, y = country)",
          answer = "aes(x = population)",
          x = "aes(x = population, y = count)")
cat("* Wie würden Sie das Mapping für diesen Plot festlegen? ", longmcq(opts))
```
* Was ist die `binwidth` des Histogramms? `r mcq(c("1", "100", answer = "100K", "1M"))`
:::

::: {.callout-tip collapse="true"}
## Anpassung der Achsenbeschriftung

Wenn Sie neugierig sind, wie wir die x-Achsenbeschriftungen auf "100K" anstelle von "100000" eingestellt haben, müssen Sie nur einen Vektor von `labels` derselben Länge wie `breaks` hinzufügen.

```{r, eval = FALSE}
  scale_x_continuous(breaks = seq(0, 1e6, 1e5),
                     labels = c(paste0(0:9*100, "K"), "1M"))
```
:::

### Gruppierte kontinuierliche Variablen

Es gibt mehrere Möglichkeiten, kontinuierliche Daten über Gruppen hinweg zu vergleichen. Welche Sie wählen, hängt davon ab, was sie mit dem Plot zeigen möchten. 

#### Gestapeltes Histogramm

In vorherigen Plots haben wir `fill` rein aus optischen Gründen verwendet, z. B. haben wir die Farbe der Histogrammbalken geändert, um sie schöner zu machen. Sie können jedoch auch `fill` verwenden, um eine andere Variable darzustellen, so dass die Farben bedeutungsvoll werden. 

Das Festlegen der `fill`-Ästhetik **im Mapping** erzeugt unterschiedlich gefärbte Balken für jede Kategorie der `fill`-Variablen, in diesem Fall `issue_category`. Somit sehen wir die Verteilung der Wartezeit für jede `issue_category`. Dadurch lassen sich gut Unterschiede in den Wartezeiten zwischen den `issue_category` Kategorien erkennen. 

```{r, fig.cap="Histogramm mit Kategorien, die durch Füllung dargestellt werden."}
ggplot(survey_data, aes(x = wait_time, fill = issue_category)) +
  geom_histogram(boundary = 0, 
                 binwidth = 15,
                 color = "black")
```


::: {.callout-warning}
## Argumente innerhalb von aes()

Wenn Sie einen Aspekt festlegen, um die Daten darzustellen, tun Sie dies innerhalb der Funktion `aes()` für das Mapping, nicht als Argument zum Geom. Wenn Sie versuchen, dies in einem Geom zu setzen, erhalten Sie die folgende Fehlermeldung (es sei denn, Sie haben zufällig ein Objekt namens `issue_category`, das ein Farbwort ist).

```{r, error = TRUE}
ggplot(survey_data, aes(x = wait_time)) +
  geom_histogram(boundary = 0, 
                 binwidth = 15, 
                 color = "black",
                 fill = issue_category)
```

:::

::: {.callout-tip collapse="true"}
## Alternative zum Histogramm

Die Funktion `geom_area()` gibt einen ähnlichen Effekt, wenn `stat = "bin"`. 

```{r, fig.cap="Gestapeltes Flächendiagramm."}
# Flächendiagramm
ggplot(survey_data, mapping = aes(x = wait_time, fill = issue_category)) +
  geom_area(stat = "bin", 
            boundary = 0, 
            binwidth = 15, 
            color = "black")
```

:::

#### Ausgewürfeltes Histogramm

Standardmäßig werden die Kategorien übereinander gestapelt positioniert. Wenn Sie mehr als eine Verteilung vergleichen möchten, können Sie das Argument `position` von `geom_histogram()` auf "dodge" setzen, um die Balken für jede Gruppe nebeneinander statt übereinander zu platzieren. Dies kann jedoch mit mehreren Kategorien verwirrend aussehen. 

```{r fig-histogram-dodge, fig.cap = "Ein Histogramm mit mehreren Gruppen."}

# ausgewürfeltes Histogramm
ggplot(survey_data, aes(x = wait_time, 
                        fill = issue_category,
                        colour = issue_category))+
  geom_histogram(boundary = 0, 
                 binwidth = 15, 
                 position = "dodge") +
  scale_x_continuous(name = "Wartezeit (Sekunden)",
                     breaks = seq(0, 600, 60))
```


::: {.callout-tip collapse="true"}
## Alternative zum Häufigkeitsplot

Alternativ können Sie `geom_freqpoly()` verwenden, um eine Linie zu zeichnen, die die Oberseite jedes Bins verbindet (siehe @sec-freqpoly).

```{r fig-groups-freqpoly, fig.cap = "Ein Häufigkeitsplot mit mehreren Gruppen."}
# Häufigkeitsplot
ggplot(survey_data, aes(x = wait_time,
                        colour = issue_category)) +
  geom_freqpoly(binwidth = 15, 
                boundary = 0,
                size = 1) +
  scale_x_continuous(name = "Wartezeit (Sekunden)",
                     breaks = seq(0, 600, 60))
```

:::


#### Boxplot

Eine weitere Möglichkeit, Gruppen von kontinuierlichen Variablen zu vergleichen, sind Boxplots. Sie zeigen nicht die Form der Verteilung, sondern visualisieren einige aussagekräftige Statistiken darüber. Die mittlere Linie stellt den `r glossary("median")` dar; die Hälfte der Daten/Beobachtungen liegt über dieser Linie und die Hälfte darunter. Die Box umschließt das 25. bis 75. Perzentil der Daten, also fallen 50% der Daten in die Box. Die "Whisker", die ober- und unterhalb der Box herausragen, erstrecken sich 1,5-mal so hoch wie die Box, obwohl Sie dies mit dem Argument `coef` ändern können. Die Punkte zeigen `r glossary("outlier", "outliers")` -- einzelne Datenpunkte, die außerhalb dieses Bereichs liegen.

Boxplots können horizontal sein, wenn Sie die x- und y-Spalten tauschen, und es gibt viele andere Anpassungen, die Sie anwenden können.

```{r fig-box-plot, fig.width = 8, fig.height = 2.5, fig.cap = "Boxplots."}
boxplot <- ggplot(survey_data, aes(x = issue_category, y = wait_time)) +
 geom_boxplot() +
  ggtitle("Standard-Vertikal-Boxplot")

custom <- ggplot(survey_data, aes(y = issue_category,x = wait_time)) +
 geom_boxplot(fill = "grey80", 
              outlier.colour = "red",
              outlier.shape = 8,
              coef = 1,   # Länge der Whisker relativ zur Box
              varwidth = TRUE, # Breite proportional zur Stichprobengröße setzen
              notch = TRUE) +
  ggtitle("Angepasster Horizontal-Boxplot")

boxplot + custom
```


::: {.callout-caution collapse="true"}
## Irreführende Balkendiagramme
Häufig werden anstatt Verteilungen, wie zum Beispiel mit dem Boxplot, nur einzelne Statistiken, zum Beispiel der Mittelwert, geplottet. Dies kann sehr irreführend sein, da es die Verteilung der Rohwerte nicht veranschaulicht und die Unterschiede deshalb grösser aussehen können, als sie tatsächlich sind. So sehen die Unterschiede in den Mittelwerten im Plot unten links deutlich dramatischer aus, als dies aus den Daten eigentlich hervorgeht (vgl. Boxplot oben). 

Der Effekt sieht aber nur so dramatisch aus, weil die x-Achse nicht bei 0 beginnt. Plotten wir den gesamten Range der Daten (rechter plot) sehen wir, dass es fast keine Unterschiede gibt. Achten sie immer darauf, was sie mit einer Abbildung aussagen möchten. Und wie man sieht, kann man den plot entsprechend der gewünschten Aussage wählen. Später werden wir sehen, wie mann solche Plots mit Massen wie Konfidenzintervallen ergänzen kann, um dem etwas entgegenzuwirken. 

```{r fig-col-plot-bad, fig.height = 2.5, fig.width = 8, message=FALSE, echo = FALSE, fig.cap="Plotten Sie kontinuierliche Daten nicht mit Säulendiagrammen. Sie sind nur für Zähldaten geeignet."}
tall_col <- ggplot(survey_data, aes(x = issue_category, 
                                    y = wait_time,
                                    fill = issue_category)) +
  scale_x_discrete(name = "Issue-Kategorie") +
  scale_y_continuous(name = "Wartezeit (Sekunden)",
                     breaks = seq(0, 600, 60)) +
  guides(fill = "none", colour = "none") +
  stat_summary(fun = "mean", 
               geom = "col") # zeichnet eine Säule, die den Mittelwert darstellt

short_col <- tall_col +
  scale_y_continuous(name = "Wartezeit (Sekunden)",
                     breaks = seq(0, 600, 1)) +
  coord_cartesian(ylim = c(185, 189))

short_col + tall_col 
```


:::

::: {.callout-note .try}
## Testen Sie Ihr Verständnis

```{r test-grouped-continuous, echo=FALSE, fig.height = 2.5}
box <- c(x = "geom_box()",
         answer = "geom_boxplot()",
         x = "geom_violin()",
         x = "geom_violinplot()")

median <- c(x = "mean",
            answer = "median",
            x = "mode")

e04 <- setNames(faux::make_id(10, "e", 2), rep("x", 10))
e07 <- e04
names(e04)[4] <- "answer"
names(e07)[7] <- "answer"

aes <- sample(c(
  answer = "aes(x = employee_id, y = call_time, fill = employee_id)",
  x = "aes(x = employee_id, y = call_time, fill = call_time)",
  x = "aes(x = employee_id, y = call_time, colour = call_time)",
  x = "aes(x = employee_id, y = call_time, colour = employee_id)"
))

g <- ggplot(survey_data, aes(x = employee_id, y = call_time, fill = employee_id)) +
  guides(fill = "none")
  
v <- g + geom_violin(draw_quantiles = 0.5)
b <- g + geom_boxplot()

 b 
```

* Wie würden Sie den Plot erstellen? `r mcq(box)`
* Wie sieht das Mapping für den Plot aus? `r longmcq(aes)`
* Welcher Mitarbeiter hat die längste mediane Anrufzeit? `r mcq(e04)`
* Welcher Mitarbeiter hat die längste Anrufzeit? `r mcq(e07)`
:::


### Zwei kontinuierliche Variablen

Wenn Sie sehen möchten, wie zwei kontinuierliche Variablen zusammenhängen, legen Sie eine als x-Achse und die andere als y-Achse fest. Normalerweise, wenn eine Variable die andere verursacht, plotten Sie die Ursache auf der x-Achse und die Wirkung auf der y-Achse. Hier möchten wir sehen, ob längere Wartezeiten dazu führen, dass die Anrufe länger dauern. 

#### Streudiagramm

Die Funktion zur Erstellung eines Streudiagramms heißt `geom_point()`.

```{r fig-demo-point, fig.cap="Streudiagramm mit geom_point()."}
ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point()
```

#### Trendlinien

In @fig-layers haben wir die Beziehung zwischen Wartezeit und Anrufzeit mit einer Trendlinie betont, die durch `geom_smooth()` mit dem Argument `method = lm` erstellt wurde ("lm" steht für "lineares Modell", also die Trendlinie einer linearen Regression). Sie können auch `method = loess` einstellen, um eine nichtlineare Beziehung zu visualisieren.

```{r fig-2-continuous, fig.cap="Verschiedene Möglichkeiten, die Beziehung zwischen zwei kontinuierlichen Variablen zu zeigen."}

lm_plot <- 
  ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = lm, formula = y~x) +
  ggtitle("method = lm")

loess_plot <- 
  ggplot(survey_data, aes(x = wait_time, y = call_time)) +
  geom_point(alpha = 0.2) +
  geom_smooth(method = loess, formula = y~x) +
  ggtitle("method = loess")

lm_plot + loess_plot
```

::: {.callout-warning}
## Fehler-Schattierung

Wenn es nicht viele Daten an den Extremen der x-Achse gibt, kann die Kurve sehr unsicher sein. Dies wird durch den breiteren schattierten Bereich dargestellt, was bedeutet, dass die wahre Beziehung irgendwo innerhalb dieses Bereichs liegen könnte. Fügen Sie das Argument `se = FALSE` zu `geom_smooth()` hinzu, um diese "Standardfehler"-Schattierung zu entfernen.
:::


#### Daten

Die Spalte `call_start` enthält sowohl ein Datum als auch eine Uhrzeit, also verwenden wir die Funktion `date()` aus <pkg>lubridate</pkg>, um sie nur in ein Datum zu konvertieren. Wir benötigen es in diesem Format, um die x-Achse unten transformieren zu können.

```{r fig-date-x, fig.cap="Plotting dates."}
ggplot(survey_data, aes(x = lubridate::date(call_start), 
                        y = satisfaction)) + 
  geom_smooth(method = lm, formula = y~x)
```

Wir können `scale_x_date()` verwenden, um die `date_breaks` auf "1 Monat" Abstand einzustellen. Das Argument `date_labels` verwendet einen Code für verschiedene Datumsformate; Sie können die vollständige Liste der Möglichkeiten in der Hilfe für `?strptime` sehen. Zum Beispiel bedeutet `%b` "Abgekürzter Monatsname", während Sie für ein Format wie "2020/01/31" `"%Y/%m/%d"` ausprobieren könnten.

```{r fig-date-month, fig.cap="Plotting dates with breaks one month apart."}
ggplot(survey_data, aes(x = lubridate::date(call_start), 
                        y = satisfaction)) +
  geom_smooth(method = lm, formula = y~x) +
  scale_x_date(name = "",
               date_breaks = "1 month", 
               date_labels = "%b") +
  scale_y_continuous(name = "Kundenzufriedenheit") +
  ggtitle("Kundenzufriedenheit 2020")
```

::: {.callout-note .try}
## Testen Sie sich selbst

Es sieht so aus, als würde die Kundenzufriedenheit im Laufe des Jahres abnehmen, aber ist diese Änderung bedeutend? Sehen Sie, wie der Plot aussieht, wenn die y-Achse den vollen Bereich möglicher Zufriedenheitswerte von 1 bis 5 umfasst. Sie können auch die einzelnen Datenpunkte plotten, um den Bereich der Werte zu betonen. 

```{r, webex.hide = TRUE}
ggplot(survey_data, aes(x = lubridate::date(call_start), 
                        y = satisfaction)) +
  # einzelne Daten anzeigen, die Höhe leicht versetzen, um Überlappungen zu vermeiden
  geom_jitter(width = 0, height = .1, alpha = 0.2) + 
  geom_smooth(method = lm,  formula = y~x) +
  scale_x_date(name = "",
               date_breaks = "1 month", 
               date_labels = "%b") +
  scale_y_continuous(name = "Kundenzufriedenheit",
                     breaks = 1:5) +
  coord_cartesian(ylim = c(1, 5)) + # Grenzen ändern
  ggtitle("Kundenzufriedenheit 2020")
```

::: 

### Überlagerung

Wenn Sie einen begrenzten Bereich numerischer Werte haben, wie z.B. eine ordinale Bewertungsskala, könnnen manchmal überlappende Daten das Verständnis eines Punktdiagramms erschweren. Zum Beispiel zeigt der folgende Plot Zufriedenheitsbewertungen nach Anrufzeit, aber weil alle Bewertungen 1, 2, 3, 4 oder 5 sind, ist es schwer zu sehen, wie viele Datenpunkte an jedem Punkt sind.

In diesem Abschnitt werden wir einige Optionen zur Bewältigung des Überlagerungsproblems erkunden.

```{r fig-over-plot, fig.cap="Überlappende Daten erschweren das Verständnis von Plots."}
ggplot(survey_data, aes(x = call_time, y = satisfaction)) + 
  geom_point()
```

#### Jitter-Diagramm

Sie können `geom_jitter()` verwenden, um die Punkte etwas zu verschieben, um sie besser sichtbar zu machen. Hier ist die x-Achse kontinuierlich, daher besteht keine Notwendigkeit, die `width` zu jittern, aber die y-Achse sind ordinale Kategorien, daher wird die `height` zwischen -0,2 und +0,2 vom wahren y-Wert gejittert. Eine andere oder weitere Möglichkeit ist es, die Punkte etwas transparent zu machen. 

::: {.callout-note .try}
## Ändern Sie diese Werte, um zu verstehen, was Jitter tut
:::

```{r fig-jitter-plot, fig.cap = "Jitter-Diagramm."}
ggplot(survey_data, aes(x = call_time, y = satisfaction)) +
  geom_jitter(width = 0, height = .2, alpha = 0.5)
```

#### Facetten

Alternativ können wir `facet_wrap()` verwenden, um für jede Zufriedenheitsstufe ein separates Diagramm zu erstellen. `facet_wrap()` verwendet das Tilde (~) Symbol, das Sie grob als "nach" übersetzen können, z.B. facettiere das Diagramm *nach* Zufriedenheitsbewertung. Die `labeller`-Funktion steuert die Beschriftungen über jedem Plot. `label_both` gibt an, dass wir sowohl den Variablennamen (satisfaction) als auch den Wert (z.B. 1) auf dem Plot abbilden möchten, um es einfacher lesbar zu machen.

```{r fig-fact-plot, fig.height = 8, fig.cap = "Ein Histogramm mit Facetten."}
ggplot(survey_data, aes(x = call_time)) +
  geom_histogram(binwidth = 10, 
                 boundary = 0, 
                 fill = "dodgerblue", 
                 color = "black") +
  facet_wrap(~satisfaction, 
             ncol = 1, # versuchen Sie dies auf 2 zu ändern
             labeller = label_both) +
  scale_x_continuous(name = "Anrufzeit (Sekunden)",
                     breaks = seq(0, 600, 30))
```

::: {.callout-note}
## Weitere Plot-Stile

Dies sind nicht alle Plot-Typen, die Sie in R erstellen können. Dieses Kapitel gab Ihnen nur einen grundlegenden Überblick, und wir werden im Detail in @sec-custom-viz eingehen. Der Abschnitt [weitere Ressourcen](#resources-viz) am Ende dieses Kapitels listet viele Ressourcen auf, aber die [R Graph Gallery](http://www.r-graph-gallery.com/){target="_blank"} ist besonders nützlich, um Inspiration für die Arten von schönen Plots zu erhalten, die Sie in R erstellen können.
:::

## Übungen

Als letzten Schritt in diesem Kapitel werden wir einen Bericht über Datenvisualisierungen erstellen. Möglicherweise müssen Sie auf @sec-reports zurückgreifen, um Ihnen bei der Durchführung dieser Übungen zu helfen, und Sie möchten vielleicht auch eine Pause einlegen, bevor Sie diesen Abschnitt bearbeiten. Wir empfehlen Ihnen auch, bei jedem Schritt `r glossary("knit")` zu verwenden, damit Sie sehen können, wie sich Ihre Ausgabe ändert.

### Neues Markdown {#sec-exercises-new-rmd-3}

Erstellen und speichern Sie ein neues R Markdown-Dokument mit dem Namen `plots_report.Rmd` und geben Sie ihm den Titel "Bericht zur Kundenzufriedenheit". Entfernen Sie den Standardvorlagentext und laden Sie dann die unten stehenden Pakete und Code im Setup-Code-Block:

```{r setup-report, message=FALSE}
library(tidyverse) 
library(patchwork) 
library(ggthemes)  
library(lubridate) 
library(knitr)
library(kableExtra)

survey_data <- read_csv("https://psyteachr.github.io/ads-v2/data/survey_data.csv")
```

### Zusammenfassung {#sec-exercises-summary}

Erstellen Sie eine Überschrift der Ebene 1 mit dem Titel "Überblick". Unter dieser Überschrift schreiben Sie eine kurze Zusammenfassung dessen, was der Datensatz enthält und was jede der Variablen bedeutet (Sie können die Informationen aus @sec-plots-loading-data verwenden, wenn Sie möchten).

### Präsentation von Plots

Wählen Sie Ihre beiden Lieblingsplots aus allen Beispielen, die wir in diesem Kapitel erstellt haben. Für jeden Plot:

* Erstellen Sie eine Überschrift der Ebene 2 in Ihrem R Markdown-Dokument und geben Sie ihr einen informativen Titel.
* Schreiben Sie eine kurze Zusammenfassung, die die in den Plots dargestellten Daten interpretiert - es reicht nicht aus, nur Visualisierungen zu präsentieren, effektive Berichte werden dem Leser auch helfen, die Schlussfolgerungen zu verstehen, die sie aus den präsentierten Plots ziehen sollten.
* Sehen Sie sich die verschiedenen verfügbaren Themen mit [<pkg>ggtheme</pkg>](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/) an und wählen Sie eines aus, um es auf Ihre Plots anzuwenden.
* Stellen Sie sicher, dass jeder Plot eine Bildunterschrift hat (entweder indem Sie diese zum `ggplot()`-Code hinzufügen oder sie zu den Code-Block-Optionen hinzufügen).
* Organisieren Sie Ihr Markdown so, dass die Plots **nach** der Textzusammenfassung angezeigt werden.

### Kombination von Plots

Wählen Sie nun Ihre beiden am wenigsten bevorzugten Plots aus:

* Passen Sie die visuellen Ästhetiken an, um sie so schlecht und so schwer lesbar wie möglich zu machen.
* Kombinieren Sie die Plots mit der Originalversion unter Verwendung von Patchwork-Funktionen.
* Schreiben Sie eine kurze Zusammenfassung, die erklärt, warum Sie diese Plots so schlecht finden.
* Organisieren Sie Ihr Markdown so, dass die Plots **nach** der Textzusammenfassung angezeigt werden.

### Bearbeiten Ihrer Markdown-Anzeige

Passen Sie das Setup Ihres Markdowns so an, dass Ihr gestrickter Bericht keinen Code, keine Nachrichten oder Warnungen anzeigt und alle Abbildungen 8 x 5 groß sind (siehe @sec-rmd-setup).

### Teilen Sie Ihre Arbeit

Sobald Sie diese Aktivität abgeschlossen haben, posten Sie sie im Kanal Woche 3 auf Teams, damit Sie vergleichen können, welche Plots Sie ausgewählt haben und welchen visuellen Stil mit anderen Lernenden auf dem Kurs.

## Glossar {#sec-glossary-viz}

```{r, echo = FALSE}
glossary_table()
```

## Weitere Ressourcen {#sec-resources-viz}

* [ggplot2-Spickzettel](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-visualization.pdf)
* [Datenvisualisierung mit R für Forscher, die kein R verwenden](https://psyteachr.github.io/introdataviz/) [@nordmann_2021]
* [Kapitel 1: Datenvisualisierung](https://r4ds.hadley.nz/data-visualize) aus *R für Datenwissenschaft*
* [ggplot2 FAQs](https://ggplot2.tidyverse.org/articles/)
* [ggplot2-Dokumentation](https://ggplot2.tidyverse.org/reference/)
* [Hack Your Data Beautiful](https://psyteachr.github